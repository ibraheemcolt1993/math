math/dumb.txt
(SKIPPED: self-referential file)

math/public/assets/cert/certificate.css
/* =========================================================
   certificate.css â€” Certificate Page Styles (Light Material)
   Ù‡Ø¯Ù Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©:
   - Ø§Ù„Ø´Ù‡Ø§Ø¯Ø© ØªØ¸Ù‡Ø± ÙƒØ§Ù…Ù„Ø© Ø¯Ø§Ø®Ù„ Ø´Ø§Ø´Ø© Ø§Ù„Ø¬ÙˆØ§Ù„ (Screenshot ÙˆØ§Ø­Ø¯ Ø¨Ø¯ÙˆÙ† Ø³ÙƒØ±ÙˆÙ„)
   - Ø¥Ø®ÙØ§Ø¡ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø£ÙƒØ´Ù† Ø¹Ù„Ù‰ Ø§Ù„Ø¬ÙˆØ§Ù„ Ø¹Ø´Ø§Ù† Ù…Ø§ ØªØ²ÙˆØ¯ Ø§Ù„Ø§Ø±ØªÙØ§Ø¹
   ========================================================= */

.cert-app {
  background: #f6f7fb;
}

.cert-shell {
  max-width: 980px;
  margin: 0 auto;
}

/* Certificate Paper */
.cert-paper {
  position: relative;
  background: #fff;
  border-radius: 16px;
  padding: 40px 36px 32px;
  box-shadow: 0 18px 40px rgba(15, 23, 42, 0.12);
  overflow: hidden;
}

/* Subtle background */
.cert-bg {
  position: absolute;
  inset: -20% -10% auto auto;
  width: 420px;
  height: 420px;
  background: radial-gradient(closest-side, rgba(37, 99, 235, 0.12), rgba(37, 99, 235, 0));
  pointer-events: none;
}

/* Header */
.cert-head {
  display: grid;
  grid-template-columns: auto 1fr;
  gap: 16px;
  align-items: center;
  margin-bottom: 24px;
}

.cert-badge {
  font-size: 44px;
  line-height: 1;
}

.cert-title {
  font-size: 32px;
  margin: 0;
}

.cert-sub {
  margin: 4px 0 0;
  color: #64748b;
}

/* Body */
.cert-body {
  margin-top: 8px;
}

.cert-line {
  margin: 18px 0 6px;
  color: #475569;
  font-size: 14px;
}

.cert-name {
  font-size: 34px;
  font-weight: 800;
  letter-spacing: 0.2px;
  color: #0f172a;
  padding: 6px 0 2px;
}

.cert-card {
  font-size: 22px;
  font-weight: 700;
  color: #1e293b;
  padding: 4px 0 10px;
}

/* Meta */
.cert-meta {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 12px;
  margin-top: 20px;
}

.cert-meta-item {
  background: #f8fafc;
  border: 1px dashed #e5e7eb;
  border-radius: 12px;
  padding: 10px 12px;
  text-align: center;
}

.cert-meta-k {
  display: block;
  font-size: 12px;
  color: #64748b;
}

.cert-meta-v {
  display: block;
  margin-top: 2px;
  font-weight: 700;
  color: #0f172a;
}

/* Footer */
.cert-footer {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 16px;
  align-items: center;
  margin-top: 28px;
}

.cert-sign {
  display: flex;
  gap: 8px;
  align-items: baseline;
}

.cert-sign-k {
  font-size: 12px;
  color: #64748b;
}

.cert-sign-v {
  font-weight: 700;
}

/* Stamp */
.cert-stamp {
  position: relative;
  width: 86px;
  height: 86px;
}

.cert-stamp-ring {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  border: 3px solid #2563eb;
  opacity: 0.9;
}

.cert-stamp-text {
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  font-weight: 800;
  color: #2563eb;
  transform: rotate(-12deg);
}

/* Actions */
.cert-actions {
  display: grid;
  gap: 10px;
  margin-top: 16px;
}

/* Empty */
#certEmpty.card {
  margin-top: 16px;
}

/* Print */
@media print {
  body {
    background: #fff;
  }

  .topbar,
  .cert-actions {
    display: none !important;
  }

  .cert-paper {
    box-shadow: none;
    border-radius: 0;
    padding: 24mm 20mm;
  }

  @page {
    size: A4;
    margin: 10mm;
  }
}

/* =========================================================
   Mobile Screenshot Mode (default on small screens)
   - Center certificate
   - Fit inside viewport (no scroll)
   - Hide actions to keep one-shot screenshot
   ========================================================= */
@media (max-width: 640px) {
  /* make page fit screen */
  html, body {
    height: 100%;
    overflow: hidden; /* screenshot Ø¨Ø¯ÙˆÙ† Ø³ÙƒØ±ÙˆÙ„ */
  }

  .container.section {
    padding-block: 12px;
  }

  .cert-shell {
    height: calc(100vh - 72px); /* ØªÙ‚Ø±ÙŠØ¨Ù‹Ø§ Ø§Ø±ØªÙØ§Ø¹ topbar */
    display: grid;
    place-items: center;
  }

  /* Hide actions on mobile for one-screen screenshot */
  .cert-actions {
    display: none !important;
  }

  /* Fit paper into viewport */
  .cert-paper {
    width: min(94vw, 420px);
    max-height: calc(100vh - 92px);
    padding: 18px 16px 14px;
    box-shadow: 0 14px 30px rgba(15, 23, 42, 0.10);
    overflow: hidden;
  }

  .cert-bg {
    width: 320px;
    height: 320px;
    inset: -25% -20% auto auto;
  }

  .cert-head {
    gap: 12px;
    margin-bottom: 14px;
  }

  .cert-badge {
    font-size: 34px;
  }

  .cert-title {
    font-size: 22px;
  }

  .cert-sub {
    font-size: 12px;
  }

  .cert-line {
    margin: 10px 0 4px;
    font-size: 12px;
  }

  .cert-name {
    font-size: 22px;
    padding: 2px 0 2px;
  }

  .cert-card {
    font-size: 15px;
    padding: 2px 0 6px;
  }

  .cert-meta {
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-top: 10px;
  }

  .cert-meta-item {
    padding: 8px 8px;
    border-radius: 10px;
  }

  .cert-meta-k {
    font-size: 11px;
  }

  .cert-meta-v {
    font-size: 12px;
  }

  .cert-footer {
    margin-top: 12px;
    grid-template-columns: 1fr auto;
    gap: 10px;
  }

  .cert-stamp {
    width: 64px;
    height: 64px;
  }

  .cert-stamp-ring {
    border-width: 2px;
  }

  .cert-sign-k {
    font-size: 11px;
  }

  .cert-sign-v {
    font-size: 12px;
  }
}

math/public/assets/cert/certificate.html
<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2563eb" />
  <title>math â€” Ø´Ù‡Ø§Ø¯Ø© Ø¥Ù†Ø¬Ø§Ø²</title>

  <link rel="stylesheet" href="/assets/css/base.css" />
  <link rel="stylesheet" href="/assets/cert/certificate.css" />
</head>

<body>
  <div class="app cert-app">
    <header class="topbar">
      <div class="container topbar-inner">
        <div class="brand">
          <div class="brand-mark" aria-hidden="true"></div>
          <div class="brand-title">
            <b>math</b>
            <span>Ø´Ù‡Ø§Ø¯Ø© Ø¥Ù†Ø¬Ø§Ø²</span>
          </div>
        </div>

        <a class="btn btn-ghost btn-sm" href="/" aria-label="Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª">Ø§Ù„Ø¹ÙˆØ¯Ø©</a>
      </div>
    </header>

    <main class="container section">
      <div class="cert-shell">
        <!-- Certificate Paper -->
        <section id="certPaper" class="cert-paper" aria-label="Ø´Ù‡Ø§Ø¯Ø©">
          <div class="cert-bg"></div>

          <!-- ØªØ­Ø³ÙŠÙ† Ø¨ØµØ±ÙŠ Ø¨Ø³ÙŠØ· Ø¨Ø¯ÙˆÙ† ØªØºÙŠÙŠØ± CSS: Ø¥Ø·Ø§Ø± Ø¯Ø§Ø®Ù„ÙŠ -->
          <div aria-hidden="true" style="position:absolute; inset:18px; border-radius:14px; border:1px solid rgba(37,99,235,.18); pointer-events:none;"></div>
          <div aria-hidden="true" style="position:absolute; inset:26px; border-radius:12px; border:1px dashed rgba(212,175,55,.35); pointer-events:none;"></div>

          <div class="cert-head">
            <div class="cert-badge" aria-hidden="true">ğŸ…</div>
            <div>
              <h1 class="cert-title">Ø´Ù‡Ø§Ø¯Ø© Ø¥Ù†Ø¬Ø§Ø²</h1>
              <p class="cert-sub">ØªÙÙ…Ù†Ø­ Ù‡Ø°Ù‡ Ø§Ù„Ø´Ù‡Ø§Ø¯Ø© ØªÙ‚Ø¯ÙŠØ±Ù‹Ø§ Ù„Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­</p>
            </div>
          </div>

          <div class="cert-body">
            <p class="cert-line">Ù†ÙØ¨Ø§Ø±Ùƒ Ù„Ù„Ø·Ø§Ù„Ø¨/Ø©</p>
            <div id="certName" class="cert-name">...</div>

            <p class="cert-line">Ø¥ØªÙ…Ø§Ù…</p>
            <div id="certCardTitle" class="cert-card">...</div>

            <div class="cert-meta">
              <div class="cert-meta-item">
                <span class="cert-meta-k">Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹</span>
                <span id="certWeek" class="cert-meta-v">â€”</span>
              </div>
              <div class="cert-meta-item">
                <span class="cert-meta-k">Ø§Ù„ØªØ§Ø±ÙŠØ®</span>
                <span id="certDate" class="cert-meta-v">â€”</span>
              </div>
              <div class="cert-meta-item">
                <span class="cert-meta-k">Ø§Ù„Ø´Ø¹Ø¨Ø©</span>
                <span id="certClass" class="cert-meta-v">â€”</span>
              </div>
            </div>

            <div class="cert-footer">
              <div class="cert-sign">
                <span class="cert-sign-k">Ø§Ù„Ù…Ø¹Ù„Ù…</span>
                <span class="cert-sign-v">Ø§Ù„Ù…Ø¹Ù„Ù… Ø¥Ø¨Ø±Ø§Ù‡ÙŠÙ… Ø£Ø­Ù…Ø¯</span>
              </div>
              <div class="cert-stamp" aria-hidden="true">
                <div class="cert-stamp-ring"></div>
                <div class="cert-stamp-text">math</div>
              </div>
            </div>
          </div>
        </section>

        <!-- Actions -->
        <section class="cert-actions">
          <button id="btnDownload" class="btn btn-primary btn-lg w-100">ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ø´Ù‡Ø§Ø¯Ø©</button>
          <button id="btnShare" class="btn btn-outline w-100" disabled>Ù…Ø´Ø§Ø±ÙƒØ© ÙˆØ§ØªØ³Ø§Ø¨ (Ù‚Ø±ÙŠØ¨Ù‹Ø§)</button>
          <p class="small center muted">Ø§Ù„Ù…ØµØ¯Ø±: Ø¢Ø®Ø± Ø¥Ù†Ø¬Ø§Ø² Ù…Ø­ÙÙˆØ¸ ÙÙŠ Ø§Ù„Ø¬Ù‡Ø§Ø² (math:lastCertificate)</p>
          <p id="dlHint" class="small center muted hidden">Ø¬Ø§Ø±ÙŠ ØªØ¬Ù‡ÙŠØ² Ø§Ù„Ù…Ù„Ùâ€¦</p>
        </section>

        <!-- Fallback message -->
        <section id="certEmpty" class="card hidden">
          <div class="card-header">
            <div>
              <h2 class="h2">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø´Ù‡Ø§Ø¯Ø© Ø¨Ø¹Ø¯</h2>
              <p class="p">Ø£Ù†Ù‡Ù Ø¨Ø·Ø§Ù‚Ø© Ø£ÙˆÙ„Ù‹Ø§ØŒ ÙˆØ¨Ø¹Ø¯ÙŠÙ† Ø§Ø±Ø¬Ø¹ Ù„Ù‡ÙˆÙ†.</p>
            </div>
          </div>
          <div class="card-body">
            <a href="/" class="btn btn-primary w-100">Ø§Ø°Ù‡Ø¨ Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</a>
          </div>
        </section>
      </div>
    </main>
  </div>

  <script>
    (function () {
      const LS_LAST_CERTIFICATE = 'math:lastCertificate';

      const elPaper = document.getElementById('certPaper');
      const elEmpty = document.getElementById('certEmpty');

      const elName = document.getElementById('certName');
      const elCard = document.getElementById('certCardTitle');
      const elWeek = document.getElementById('certWeek');
      const elDate = document.getElementById('certDate');
      const elClass = document.getElementById('certClass');

      const btnDownload = document.getElementById('btnDownload');
      const btnShare = document.getElementById('btnShare');
      const dlHint = document.getElementById('dlHint');

      let currentPayload = null;

      function readPayload() {
        try {
          const raw = localStorage.getItem(LS_LAST_CERTIFICATE);
          return raw ? JSON.parse(raw) : null;
        } catch (e) {
          return null;
        }
      }

      function fmtDate(iso) {
        try {
          const d = new Date(iso);
          if (isNaN(d.getTime())) return 'â€”';
          const y = d.getFullYear();
          const m = String(d.getMonth() + 1).padStart(2, '0');
          const day = String(d.getDate()).padStart(2, '0');
          return `${y}-${m}-${day}`;
        } catch {
          return 'â€”';
        }
      }

      function safeFileName(s) {
        return String(s || '')
          .trim()
          .replace(/[\\/:*?"<>|]+/g, '')
          .replace(/\s+/g, '_')
          .slice(0, 80);
      }

      function setBusy(isBusy) {
        btnDownload.disabled = isBusy;
        dlHint.classList.toggle('hidden', !isBusy);
        btnDownload.textContent = isBusy ? 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ†Ø²ÙŠÙ„â€¦' : 'ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ø´Ù‡Ø§Ø¯Ø©';
      }

      // --- RENDER DATA ---
      currentPayload = readPayload();

      if (!currentPayload || !currentPayload.fullName) {
        elPaper.classList.add('hidden');
        elEmpty.classList.remove('hidden');
        btnDownload.disabled = true;
        btnShare.disabled = true;
        return;
      }

      elName.textContent = currentPayload.fullName || currentPayload.firstName || 'â€”';
      elCard.textContent = currentPayload.cardTitle || 'Ø¨Ø·Ø§Ù‚Ø©';
      elWeek.textContent = (currentPayload.week != null) ? String(currentPayload.week) : 'â€”';
      elDate.textContent = fmtDate(currentPayload.issuedAt);
      elClass.textContent = currentPayload.class || 'â€”';

      // --- DOWNLOAD AS IMAGE (PNG) ---
      // We create an SVG foreignObject snapshot with inline computed styles so it looks the same.
      function inlineComputedStyles(rootEl) {
        const all = rootEl.querySelectorAll('*');
        const toCopy = [
          'font', 'fontFamily', 'fontSize', 'fontWeight', 'lineHeight',
          'color', 'textAlign', 'letterSpacing',
          'background', 'backgroundColor', 'backgroundImage',
          'border', 'borderTop', 'borderRight', 'borderBottom', 'borderLeft',
          'borderRadius', 'boxShadow',
          'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',
          'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft',
          'display', 'position', 'top', 'right', 'bottom', 'left',
          'width', 'height', 'minWidth', 'minHeight', 'maxWidth', 'maxHeight',
          'alignItems', 'justifyContent', 'gap', 'gridTemplateColumns',
          'overflow', 'opacity', 'transform',
          'direction'
        ];

        // root too
        all.forEach((node) => {
          const cs = window.getComputedStyle(node);
          let style = node.getAttribute('style') || '';
          // prevent duplicate ; formatting issues
          if (style && !style.trim().endsWith(';')) style += ';';

          toCopy.forEach((p) => {
            const v = cs[p];
            if (v && v !== 'initial' && v !== 'none' && v !== 'normal') {
              style += `${kebab(p)}:${v};`;
            }
          });

          // make sure backgrounds render in SVG snapshot
          style += `-webkit-print-color-adjust:exact;print-color-adjust:exact;`;
          node.setAttribute('style', style);
        });

        function kebab(prop) {
          return prop.replace(/[A-Z]/g, (m) => '-' + m.toLowerCase());
        }
      }

      async function nodeToPngBlob(node, scale = 2) {
        // Clone certificate to avoid mutating the real DOM with style inlining
        const clone = node.cloneNode(true);

        // Put clone offscreen to compute styles correctly
        const sandbox = document.createElement('div');
        sandbox.style.position = 'fixed';
        sandbox.style.left = '-10000px';
        sandbox.style.top = '0';
        sandbox.style.width = node.offsetWidth + 'px';
        sandbox.style.pointerEvents = 'none';
        sandbox.style.opacity = '0';
        sandbox.appendChild(clone);
        document.body.appendChild(sandbox);

        // Inline styles
        inlineComputedStyles(clone);

        const width = node.offsetWidth;
        const height = node.offsetHeight;

        const xhtml = new XMLSerializer().serializeToString(clone);
        const svg = `
          <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
            <foreignObject x="0" y="0" width="100%" height="100%">
              <div xmlns="http://www.w3.org/1999/xhtml">${xhtml}</div>
            </foreignObject>
          </svg>
        `.trim();

        document.body.removeChild(sandbox);

        const svgBlob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
        const url = URL.createObjectURL(svgBlob);

        try {
          const img = await loadImage(url);
          const canvas = document.createElement('canvas');
          canvas.width = Math.round(width * scale);
          canvas.height = Math.round(height * scale);
          const ctx = canvas.getContext('2d');

          // white background
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.setTransform(scale, 0, 0, scale, 0, 0);
          ctx.drawImage(img, 0, 0);

          return await new Promise((resolve) => {
            canvas.toBlob((b) => resolve(b), 'image/png', 1);
          });
        } finally {
          URL.revokeObjectURL(url);
        }
      }

      function loadImage(url) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error('ÙØ´Ù„ ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø´Ù‡Ø§Ø¯Ø© Ù„ØµÙˆØ±Ø©'));
          img.src = url;
        });
      }

      function downloadBlob(blob, filename) {
        const a = document.createElement('a');
        const url = URL.createObjectURL(blob);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 4000);
      }

      btnDownload.addEventListener('click', async () => {
        try {
          setBusy(true);

          const fileBase =
            safeFileName(`Ø´Ù‡Ø§Ø¯Ø©_${currentPayload.fullName}_${currentPayload.week}_${fmtDate(currentPayload.issuedAt)}`) ||
            'certificate';

          const blob = await nodeToPngBlob(elPaper, 2);

          if (!blob) throw new Error('ØªØ¹Ø°Ø± Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ù„Ù');

          downloadBlob(blob, `${fileBase}.png`);
        } catch (e) {
          console.error(e);
          alert('ØµØ§Ø± Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ø´Ù‡Ø§Ø¯Ø©. Ø¬Ø±Ù‘Ø¨ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©.');
        } finally {
          setBusy(false);
        }
      });

      // placeholder for Phase 2 share
      btnShare.addEventListener('click', () => {});
    })();
  </script>
</body>
</html>

math/public/assets/css/admin-builder.css
.builder {
  min-height: 60vh;
}

.builder-meta {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

.builder-meta .builder-helper {
  margin-top: 6px;
}

.builder-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  margin-top: 16px;
}

.builder-block {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.builder-block-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.builder-sections {
  display: flex;
  flex-direction: column;
  gap: 18px;
}

.builder-section {
  border: 1px solid var(--border);
  border-radius: var(--r-sm);
  background: var(--surface);
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 14px;
}

.builder-section-header {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.builder-section-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.builder-question {
  border: 1px solid var(--border);
  border-radius: var(--r-sm);
  background: var(--surface-2);
  padding: 14px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  position: relative;
}

.builder-question-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  flex-wrap: wrap;
}

.builder-card-actions {
  display: flex;
  gap: 8px;
  align-items: center;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.builder-question:hover .builder-card-actions,
.builder-question:focus-within .builder-card-actions,
.builder-section:hover .builder-card-actions,
.builder-section:focus-within .builder-card-actions {
  opacity: 1;
}

.builder-card-handle {
  cursor: grab;
}

.builder-question-meta {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 10px;
}

.builder-question-options {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.builder-option {
  display: grid;
  grid-template-columns: 1fr auto;
  gap: 8px;
  align-items: center;
}

.builder-option-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.builder-pairs {
  display: grid;
  gap: 10px;
}

.builder-pair {
  display: grid;
  gap: 8px;
  grid-template-columns: 1fr 1fr auto;
  align-items: center;
}

.builder-order {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.builder-order-item {
  display: grid;
  grid-template-columns: auto 1fr auto;
  gap: 8px;
  align-items: center;
  padding: 10px;
  border-radius: var(--r-xs);
  border: 1px dashed var(--border);
  background: rgba(255, 255, 255, 0.6);
}

.builder-order-item.is-dragging {
  opacity: 0.6;
}

.drag-handle {
  cursor: grab;
  font-size: 18px;
  line-height: 1;
  padding: 0 6px;
  color: var(--muted);
}

.builder-helper {
  font-size: 12px;
  color: var(--muted);
}

.floating-actions {
  position: fixed;
  inset: auto 16px 16px 16px;
  display: flex;
  gap: 12px;
  align-items: center;
  justify-content: flex-end;
  z-index: 50;
  pointer-events: none;
}

.floating-save,
.floating-add,
.floating-apply,
.floating-preview {
  pointer-events: auto;
  border-radius: 999px;
  box-shadow: 0 10px 24px rgba(15, 23, 42, 0.18);
}

.floating-save {
  background: var(--primary);
  color: #fff;
  padding: 10px 18px;
  border: none;
  font-size: 13px;
}

.floating-save.is-dirty {
  background: #f59e0b;
}

.floating-save.is-saving {
  background: #64748b;
}

.floating-save:disabled,
.floating-save.is-disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.floating-apply {
  background: #0ea5e9;
  color: #fff;
  padding: 10px 16px;
  border: none;
  font-size: 13px;
}

.floating-apply:disabled,
.floating-apply.is-disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.floating-preview.is-disabled,
.floating-add.is-disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.floating-preview {
  background: #111827;
  color: #fff;
  padding: 10px 16px;
  border: none;
  font-size: 13px;
}

.topbar .btn.is-disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.floating-add {
  width: 46px;
  height: 46px;
  border-radius: 50%;
  border: none;
  background: #fff;
  font-size: 22px;
}

.floating-menu {
  position: absolute;
  bottom: 60px;
  right: 0;
  min-width: 220px;
  background: #fff;
  border-radius: 12px;
  padding: 8px;
  box-shadow: 0 20px 40px rgba(15, 23, 42, 0.18);
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.floating-menu button {
  border: none;
  background: transparent;
  text-align: right;
  padding: 8px 10px;
  border-radius: 8px;
  cursor: pointer;
}

.floating-menu button:hover {
  background: var(--surface-2);
}

.builder-collapsed .builder-question-meta,
.builder-collapsed .builder-question-options,
.builder-collapsed .builder-pairs,
.builder-collapsed .builder-order,
.builder-collapsed .field,
.builder-collapsed .builder-helper {
  display: none;
}

math/public/assets/css/admin.css
.admin-tabs {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.admin-tabs .btn.is-active {
  background: var(--primary);
  color: #fff;
  border-color: var(--primary);
}

.admin-panel {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.admin-security {
  border: 1px solid var(--border);
  border-radius: var(--r-sm);
  padding: 16px;
  background: var(--surface-2);
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.admin-security .builder-meta {
  display: grid;
  gap: 12px;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

.admin-security .row {
  justify-content: flex-start;
}

.panel-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 16px;
  flex-wrap: wrap;
}

.table-wrap {
  width: 100%;
  overflow: auto;
  border-radius: var(--r-sm);
  border: 1px solid var(--border);
  background: var(--surface);
}

.table {
  width: 100%;
  border-collapse: collapse;
  min-width: 720px;
}

.table th,
.table td {
  padding: 12px 14px;
  border-bottom: 1px solid var(--border);
  text-align: right;
  vertical-align: middle;
  white-space: nowrap;
}

.table th {
  color: var(--muted);
  font-weight: 600;
  font-size: 0.85rem;
}

.table tr:last-child td {
  border-bottom: none;
}

.table input,
.table textarea {
  width: 100%;
  min-width: 140px;
}

.table .btn {
  white-space: nowrap;
}

.admin-card-list {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.admin-card-group {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.admin-card-group-title {
  font-size: 0.95rem;
  color: var(--muted);
  margin: 0;
}

.admin-card {
  border: 1px solid var(--border);
  border-radius: var(--r-sm);
  background: var(--surface);
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.admin-card h4 {
  margin: 0;
  font-size: 1rem;
}

.admin-card .card-actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

@media (max-width: 720px) {
  .panel-header {
    align-items: flex-start;
  }

  .table {
    min-width: 640px;
  }
}

math/public/assets/css/base.css
/* =========================================================
   base.css â€” Light Material Design System (Arabic-first)
   - Daylight theme, soft shadows, rounded buttons/cards
   - Mobile-first, responsive container
   - Works for index.html + lesson.html
   ========================================================= */

/* ---------- Fonts (system + Arabic-friendly fallbacks) ---------- */
:root{
  /* Typography */
  --font-sans: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans Arabic", "Noto Kufi Arabic", "Cairo", "Tajawal", Arial, sans-serif;

  /* Colors (Light Material) */
  --bg: #f6f8fc;
  --surface: #ffffff;
  --surface-2: #eef2f9;
  --text: #0b1324;
  --muted: #586174;
  --border: rgba(15, 23, 42, 0.08);

  /* Brand */
  --primary: #2563eb;
  --primary-600: #1d4ed8;
  --primary-100: rgba(37, 99, 235, 0.12);

  --success: #16a34a;
  --warning: #f59e0b;
  --danger:  #dc2626;

  /* Completion (Gold) */
  --gold: #d4af37;
  --gold-2: #f5d76e;
  --gold-surface: rgba(212, 175, 55, 0.12);

  /* Radii */
  --r-xs: 10px;
  --r-sm: 14px;
  --r-md: 18px;
  --r-lg: 24px;

  /* Shadows (soft) */
  --shadow-xs: 0 1px 2px rgba(15,23,42,.05), 0 1px 1px rgba(15,23,42,.03);
  --shadow-sm: 0 10px 20px rgba(15,23,42,.08);
  --shadow-md: 0 18px 36px rgba(15,23,42,.10);
  --shadow-lg: 0 30px 68px rgba(15,23,42,.14);
  --shadow-soft: 0 12px 34px rgba(15,23,42,.08);

  /* Spacing */
  --container: 1040px;
  --pad: 18px;

  /* Focus */
  --focus: 0 0 0 4px rgba(37, 99, 235, 0.18);
}

/* ---------- Reset & Base ---------- */
*{ box-sizing: border-box; }
html, body{ height:100%; }
html{ -webkit-text-size-adjust:100%; }
body{
  margin:0;
  font-family: var(--font-sans);
  background: radial-gradient(1200px 700px at 80% -10%, rgba(37,99,235,.08), transparent 60%),
              radial-gradient(900px 600px at 10% 0%, rgba(56,189,248,.08), transparent 55%),
              var(--bg);
  color: var(--text);
  line-height: 1.75;
  direction: rtl;
  font-weight: 500;
  letter-spacing: 0;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}

body.is-loading #screen-id,
body.is-loading #screen-welcome,
body.is-loading #screen-cards{
  display: none !important;
}

.loading-overlay {
  position: fixed;
  inset: 0;
  background: rgba(15, 23, 42, 0.35);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 200;
}

.loading-overlay.hidden {
  display: none;
}

.loading-panel {
  background: var(--surface);
  padding: 18px 22px;
  border-radius: var(--r-md);
  box-shadow: var(--shadow-md);
  display: flex;
  align-items: center;
  gap: 12px;
}

.loading-spinner {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  border: 3px solid rgba(37, 99, 235, 0.2);
  border-top-color: var(--primary);
  animation: spin 0.9s linear infinite;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

img{ max-width:100%; display:block; }
a{ color: inherit; text-decoration: none; }
button, input, select, textarea{
  font: inherit;
  color: inherit;
}
::selection{
  background: rgba(37, 99, 235, 0.18);
}

/* ---------- Layout ---------- */
.app{
  min-height: 100%;
  display:flex;
  flex-direction: column;
}
.container{
  width: min(var(--container), calc(100% - (var(--pad) * 2)));
  margin-inline: auto;
}
.section{
  padding-block: 28px;
}
.stack{ display:flex; flex-direction: column; gap: 18px; }
.row{ display:flex; gap: 12px; align-items: center; flex-wrap: wrap; }
.grid{
  display:grid;
  gap: 18px;
}
.grid.cards{
  grid-template-columns: repeat(1, minmax(0, 1fr));
}
@media (min-width: 560px){
  .grid.cards{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}
@media (min-width: 920px){
  .grid.cards{ grid-template-columns: repeat(3, minmax(0, 1fr)); }
}

/* ---------- Top Bar ---------- */
.topbar{
  position: sticky;
  top: 0;
  z-index: 10;
  background: rgba(246,248,252,.92);
  backdrop-filter: blur(14px);
  border-bottom: 1px solid rgba(15,23,42,.08);
  box-shadow: 0 6px 14px rgba(15,23,42,.04);
}
.topbar-inner{
  padding: 14px 0;
  display:flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
}
.brand{
  display:flex;
  align-items:center;
  gap: 10px;
  user-select:none;
}
.brand-mark{
  width: 38px;
  height: 38px;
  border-radius: 14px;
  background: linear-gradient(135deg, rgba(37,99,235,.95), rgba(99,102,241,.90));
  box-shadow: var(--shadow-sm);
  position: relative;
  overflow:hidden;
}
.brand-mark::after{
  content:"";
  position:absolute;
  inset: -40% -40% auto auto;
  width: 70px;
  height: 70px;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), transparent 55%);
  transform: rotate(25deg);
}
.brand-title{
  display:flex;
  flex-direction: column;
  line-height: 1.2;
}
.brand-title b{
  font-size: 16px;
  letter-spacing: .2px;
}
.brand-title span{
  font-size: 12px;
  color: var(--muted);
}

/* ---------- Typography ---------- */
.h1{
  font-size: 25px;
  font-weight: 800;
  margin: 0;
  letter-spacing: .1px;
}
.h2{
  font-size: 20px;
  font-weight: 800;
  margin: 0;
}
.p{
  margin: 0;
  color: var(--muted);
  font-size: 15px;
}
.small{ font-size: 12px; color: var(--muted); }
.kbd{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 999px;
  background: var(--surface);
  font-size: 12px;
  box-shadow: var(--shadow-xs);
}

/* ---------- Card ---------- */
.card{
  position: relative;
  overflow: hidden;
  background: linear-gradient(180deg, #ffffff 0%, #fbfcff 100%);
  border: 1px solid var(--border);
  border-radius: var(--r-lg);
  box-shadow: var(--shadow-sm);
  padding: 20px;
  transition: box-shadow .2s ease, transform .2s ease;
}
.card::after{
  content:"";
  position:absolute;
  inset: 0;
  background: radial-gradient(320px 120px at 15% -20%, rgba(37,99,235,.08), transparent 70%);
  opacity: .7;
  pointer-events: none;
}
@media (hover: hover){
  .card:hover{
    transform: translateY(-2px);
    box-shadow: var(--shadow-soft);
  }
}
.card.soft{
  background: linear-gradient(180deg, var(--surface), var(--surface-2));
}
.card-header{
  display:flex;
  align-items:flex-start;
  justify-content: space-between;
  gap: 12px;
  flex-wrap: wrap;
  margin-bottom: 12px;
}
.card-title{
  font-weight: 800;
  font-size: 16px;
  margin: 0;
}
.card-subtitle{
  margin: 6px 0 0;
  font-size: 13px;
  color: var(--muted);
}
.card-body{ display:flex; flex-direction: column; gap: 12px; }
.card-footer{
  display:flex;
  align-items:center;
  justify-content: space-between;
  gap: 10px;
  margin-top: 14px;
}

/* ---------- Buttons ---------- */
.btn{
  appearance:none;
  border: 1px solid transparent;
  border-radius: 999px;
  padding: 12px 18px;
  min-height: 44px;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap: 10px;
  font-weight: 800;
  font-size: 15px;
  user-select:none;
  transition: transform .08s ease, box-shadow .18s ease, background .18s ease, border-color .18s ease, opacity .18s ease;
}
.btn:active{ transform: translateY(1px); }
.btn:disabled{
  opacity: .55;
  cursor:not-allowed;
  transform:none;
}
.btn-primary{
  background: linear-gradient(180deg, rgba(37,99,235,1), rgba(29,78,216,1));
  color:#fff;
  box-shadow: 0 12px 26px rgba(37,99,235,.20);
}
.btn-primary:hover{ box-shadow: 0 16px 34px rgba(37,99,235,.26); }
.btn-outline{
  background: rgba(255,255,255,.9);
  border-color: rgba(15,23,42,.14);
  color: var(--text);
  box-shadow: var(--shadow-xs);
}
.btn-outline:hover{
  background: var(--surface);
  box-shadow: var(--shadow-sm);
}
.btn-ghost{
  background: transparent;
  border-color: transparent;
  color: var(--text);
}
.btn-ghost:hover{
  background: rgba(17,24,39,.06);
}
.btn-sm{ padding: 9px 12px; font-size: 13px; min-height: 36px; }
.btn-lg{ padding: 14px 20px; font-size: 16px; }

/* ---------- Inputs ---------- */
.field{
  display:flex;
  flex-direction: column;
  gap: 8px;
}
.label{
  font-size: 14px;
  color: var(--muted);
  font-weight: 700;
}
.input{
  width: 100%;
  border: 1px solid rgba(15,23,42,.14);
  background: linear-gradient(180deg, #ffffff 0%, #f7faff 100%);
  border-radius: 16px;
  padding: 13px 14px;
  min-height: 44px;
  box-shadow: var(--shadow-xs);
  outline: none;
  transition: box-shadow .18s ease, border-color .18s ease, background .18s ease;
  font-size: 15px;
}
.input.is-static{
  display:flex;
  align-items:center;
  color: var(--text);
  user-select: text;
}
.input::placeholder{ color: rgba(107,114,128,.85); }
.input:focus{
  border-color: rgba(37,99,235,.55);
  box-shadow: var(--focus), var(--shadow-sm);
  background: #fff;
}
.help{
  font-size: 12px;
  color: var(--muted);
}

/* ---------- Badges & Status ---------- */
.badge{
  display:inline-flex;
  align-items:center;
  gap: 6px;
  padding: 6px 12px;
  border-radius: 999px;
  font-size: 12px;
  font-weight: 800;
  border: 1px solid var(--border);
  background: rgba(255,255,255,.8);
}
.badge.primary{
  border-color: rgba(37,99,235,.22);
  background: rgba(37,99,235,.10);
  color: var(--primary-600);
}
.badge.locked{
  border-color: rgba(17,24,39,.14);
  background: rgba(17,24,39,.06);
  color: var(--muted);
}
.badge.done{
  border-color: rgba(212,175,55,.40);
  background: var(--gold-surface);
  color: #6b4f00;
}

/* ---------- Card States (Locked / Done) ---------- */
.card.is-locked{
  opacity: .72;
  filter: grayscale(.05);
}
.card.is-locked .card-title{ color: rgba(17,24,39,.80); }
.card.is-done{
  border-color: rgba(212,175,55,.65);
  background:
    radial-gradient(700px 220px at 80% -40%, rgba(245,215,110,.28), transparent 65%),
    linear-gradient(180deg, rgba(255,255,255,1), rgba(255,248,226,1));
}
.star{
  width: 26px;
  height: 26px;
  border-radius: 10px;
  background: linear-gradient(180deg, var(--gold-2), var(--gold));
  box-shadow: 0 10px 18px rgba(212,175,55,.22);
  display:inline-flex;
  align-items:center;
  justify-content:center;
  flex: 0 0 auto;
}
.star svg{
  width: 16px;
  height: 16px;
  fill: #6b4f00;
}

/* ---------- Divider ---------- */
.hr{
  border: none;
  height: 1px;
  background: rgba(15,23,42,.10);
  margin: 12px 0;
}

/* ---------- Focus ring for buttons/links ---------- */
:focus-visible{
  outline: none;
  box-shadow: var(--focus);
  border-radius: 14px;
}

/* ---------- Utility ---------- */
.hidden,
[hidden]{ display:none !important; }
.center{ text-align:center; }
.muted{ color: var(--muted); }
.spacer{ height: 10px; }
.w-100{ width:100%; }
.nowrap{ white-space:nowrap; }
.ltr{ direction:ltr; }
.rtl{ direction:rtl; }

@media (max-width: 640px){
  .topbar-inner{ padding: 12px 0; }
  .section{ padding-block: 22px; }
  .card{ padding: 16px; }
  .card-header{ flex-direction: column; align-items: flex-start; }
  .h1{ font-size: 22px; }
  .h2{ font-size: 18px; }
  .p{ font-size: 14px; }
  .btn{ width: 100%; }
  .btn.btn-sm{ width: auto; }
}

math/public/assets/css/db-template-edit.css
:root {
  --db-border: #e2e8f0;
  --db-muted: #64748b;
  --db-bg: #f8fafc;
}

body {
  background: var(--db-bg);
}

.db-layout {
  display: grid;
  grid-template-columns: 1fr;
  gap: 16px;
  margin-top: 20px;
}

@media (min-width: 960px) {
  .db-layout {
    grid-template-columns: 320px 1fr;
    align-items: start;
  }
}

.note {
  background: #eff6ff;
  border: 1px solid #bfdbfe;
  color: #1e3a8a;
  padding: 12px 16px;
  border-radius: 12px;
  font-size: 14px;
}

.tables-list {
  margin: 16px 0 0;
  padding: 0;
  list-style: none;
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.table-item {
  border: 1px solid var(--db-border);
  border-radius: 12px;
  padding: 10px 12px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  background: #fff;
  cursor: pointer;
  transition: border 0.2s ease, box-shadow 0.2s ease;
}

.table-item.is-active {
  border-color: #2563eb;
  box-shadow: 0 4px 14px rgba(37, 99, 235, 0.15);
}

.table-item span {
  font-weight: 600;
  color: #0f172a;
}

.table-item button {
  border: none;
  background: transparent;
  color: #ef4444;
  font-size: 14px;
}

.actions {
  display: grid;
  gap: 8px;
}

.columns-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-top: 18px;
}

.columns-list {
  margin-top: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.column-card {
  border: 1px solid var(--db-border);
  border-radius: 12px;
  padding: 12px;
  background: #fff;
}

.column-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
  gap: 10px;
}

.column-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 10px;
  color: var(--db-muted);
  font-size: 12px;
}

.column-footer button {
  border: none;
  background: transparent;
  color: #ef4444;
  font-weight: 600;
}

.empty-state {
  text-align: center;
  padding: 30px 10px;
  color: var(--db-muted);
}

.json-preview {
  background: #0f172a;
  color: #e2e8f0;
  padding: 16px;
  border-radius: 12px;
  max-height: 320px;
  overflow: auto;
  font-size: 12px;
}

.hidden {
  display: none !important;
}

math/public/assets/css/lesson.css
/* =========================================================
   lesson.css â€” Lesson Page Layout & Progress (Light Material)
   Depends on base.css
   ========================================================= */

/* ---------- Header (Lesson Title) ---------- */
.lesson-header{
  margin-top: 14px;
}
.lesson-title{
  display:flex;
  flex-direction: column;
  gap: 6px;
}
.lesson-title .h1{
  font-size: 23px;
}
.lesson-meta{
  display:flex;
  gap: 12px;
  align-items:center;
  flex-wrap: wrap;
}
.lesson-student{
  display:inline-flex;
  align-items:center;
  gap: 8px;
  padding: 6px 12px;
  border-radius: 999px;
  background: rgba(37,99,235,.10);
  border: 1px solid rgba(37,99,235,.18);
  font-size: 12px;
  font-weight: 800;
}

/* ---------- Progress Bar ---------- */
.progress-wrap{
  margin: 20px 0 24px;
}
.progress-label{
  display:flex;
  align-items:center;
  justify-content: space-between;
  margin-bottom: 8px;
}
.progress-label span{
  font-size: 12px;
  color: var(--muted);
  font-weight: 800;
}
.progress{
  height: 14px;
  border-radius: 999px;
  background: rgba(17,24,39,.10);
  overflow: hidden;
  box-shadow: inset 0 1px 2px rgba(17,24,39,.12);
}
.progress > i{
  display:block;
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, rgba(37,99,235,1), rgba(99,102,241,1));
  border-radius: 999px;
  transition: width .28s ease;
}

/* ---------- Concept Card ---------- */
.concept{
  margin-bottom: 22px;
}
.concept .card{
  padding: 20px;
}
.concept-header{
  display:flex;
  align-items:flex-start;
  justify-content: space-between;
  gap: 12px;
  margin-bottom: 14px;
  flex-wrap: wrap;
}
.concept-index{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width: 34px;
  height: 34px;
  border-radius: 14px;
  background: rgba(37,99,235,.12);
  border: 1px solid rgba(37,99,235,.18);
  font-weight: 900;
  font-size: 14px;
}
.concept-title{
  font-size: 18px;
  font-weight: 900;
  margin: 0;
}
.concept-body{
  display:flex;
  flex-direction: column;
  gap: 16px;
}
.lesson-stage{
  display:flex;
  flex-direction: column;
  gap: 16px;
  padding: 20px;
}
.stage-header{
  display:flex;
  flex-direction: column;
  gap: 6px;
}
.stage-badge{
  align-self: flex-start;
  padding: 4px 10px;
  border-radius: 999px;
  background: rgba(37,99,235,.12);
  border: 1px solid rgba(37,99,235,.18);
  font-size: 12px;
  font-weight: 800;
}
.stage-title{
  font-size: 18px;
  font-weight: 900;
  margin: 0;
}
.stage-desc{
  margin: 0;
  color: var(--muted);
  font-size: 14px;
}
.stage-body{
  display:flex;
  flex-direction: column;
  gap: 12px;
}
.stage-empty{
  padding: 12px;
  border-radius: 12px;
  background: rgba(17,24,39,.04);
  border: 1px dashed rgba(17,24,39,.12);
  font-size: 14px;
  color: var(--muted);
}
.stage-progress{
  display:flex;
  flex-direction: column;
  gap: 12px;
  padding-bottom: 12px;
  margin-bottom: 12px;
  border-bottom: 1px solid rgba(17,24,39,.08);
}
.goal-list,
.goal-progress{
  list-style: none;
  padding: 0;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.goal-item{
  display:flex;
  gap: 10px;
  align-items:center;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid rgba(17,24,39,.08);
  background: rgba(255,255,255,.9);
}
.goal-index{
  width: 28px;
  height: 28px;
  border-radius: 10px;
  background: rgba(37,99,235,.12);
  border: 1px solid rgba(37,99,235,.2);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 12px;
  font-weight: 900;
}
.goal-progress-item{
  display:flex;
  flex-direction: column;
  gap: 4px;
  padding: 12px;
  border-radius: 12px;
  border: 1px solid rgba(17,24,39,.08);
  background: rgba(255,255,255,.9);
}
.goal-progress-item .goal-text{
  font-size: 15px;
}
.goal-progress-item.done{
  border-color: rgba(16,185,129,.4);
  background: rgba(16,185,129,.08);
}
.goal-progress-item.current{
  border-color: rgba(37,99,235,.4);
  background: rgba(37,99,235,.08);
}
.goal-progress-item.current .goal-text{
  font-weight: 900;
}
.goal-progress-item.upcoming{
  color: rgba(17,24,39,.6);
  background: rgba(17,24,39,.03);
}
.goal-progress-item.muted{
  color: rgba(17,24,39,.5);
}
.goal-status{
  font-size: 12px;
  font-weight: 800;
  color: var(--muted);
}
.goal-progress-item.current .goal-status{
  color: #1d4ed8;
}
.goal-progress-item.done .goal-status{
  color: #16a34a;
}

/* ---------- Steps ---------- */
.step{
  border-radius: 16px;
  padding: 16px;
  border: 1px dashed rgba(17,24,39,.14);
  background: rgba(255,255,255,.86);
  box-shadow: var(--shadow-xs);
}
.step-title{
  font-weight: 900;
  font-size: 14px;
  margin: 0 0 6px;
}
.step-text{
  font-size: 15px;
  color: var(--text);
}
.step.muted{
  background: rgba(17,24,39,.04);
}
.step.example{
  background: rgba(37,99,235,.06);
  border-style: solid;
}
.step.warning{
  background: rgba(245,158,11,.10);
  border-style: solid;
}
.step.note{
  background: rgba(16,185,129,.08);
  border-style: solid;
}
.step.detail{
  background: rgba(99,102,241,.08);
  border-style: solid;
}
.step-details{
  margin: 10px 0 0;
  padding-inline-start: 18px;
  color: var(--muted);
  font-size: 14px;
}
.step.video{
  display:flex;
  flex-direction: column;
  gap: 10px;
}
.video-frame{
  border-radius: 16px;
  overflow: hidden;
  border: 1px solid rgba(17,24,39,.12);
  background: rgba(17,24,39,.04);
}
.video-embed{
  width: 100%;
  min-height: 240px;
  border: 0;
  display: block;
}
.video-empty{
  padding: 16px;
  font-size: 14px;
  color: var(--muted);
}

/* ---------- Question Area ---------- */
.question-wrap{
  margin-top: 10px;
  padding: 18px;
  border-radius: 18px;
  background: linear-gradient(180deg, rgba(255,255,255,1), rgba(243,245,251,1));
  border: 1px solid rgba(17,24,39,.14);
  box-shadow: var(--shadow-sm);
}
.question-title{
  font-size: 17px;
  font-weight: 900;
  margin: 0 0 10px;
}
.question-actions{
  display:flex;
  gap: 10px;
  align-items:center;
  justify-content: space-between;
  flex-wrap: wrap;
  margin-top: 12px;
}

/* ---------- Attempts / Status ---------- */
.attempts{
  display:flex;
  gap: 6px;
  align-items:center;
}
.dot{
  width: 8px;
  height: 8px;
  border-radius: 999px;
  background: rgba(17,24,39,.18);
}
.dot.used{
@@ -173,49 +175,54 @@
}

/* ---------- Solution Box ---------- */
.solution{
  margin-top: 12px;
  padding: 12px;
  border-radius: 16px;
  background: rgba(220,38,38,.06);
  border: 1px solid rgba(220,38,38,.18);
}
.solution-title{
  font-size: 13px;
  font-weight: 900;
  margin: 0 0 6px;
}
.solution-text{
  font-size: 14px;
}

/* ---------- Navigation Buttons ---------- */
.lesson-nav{
  display:flex;
  gap: 10px;
  justify-content: space-between;
  margin-top: 16px;
  flex-wrap: wrap;
}
.lesson-nav .btn{
  min-width: 120px;
}
.assessment{
  border: 1px solid rgba(37,99,235,.12);
}
.assessment-body{
  display:flex;
  flex-direction: column;
  gap: 14px;
}
.assessment-question{
  border-radius: 14px;
  padding: 12px;
  border: 1px dashed rgba(17,24,39,.12);
  background: rgba(255,255,255,.92);
}
.assessment-title{
  font-weight: 800;
  margin: 0 0 8px;
}
.assessment-result{
  margin-top: 16px;
  padding: 12px;
  border-radius: 12px;
  background: rgba(59,130,246,.08);
  border: 1px solid rgba(37,99,235,.2);
  display:flex;
  flex-direction: column;
  gap: 8px;
}
.assessment-score{
  font-size: 15px;
}
.assessment-note{
  font-size: 13px;
  color: var(--muted);
}

/* ---------- Completion State ---------- */
.lesson-complete{
  margin-top: 18px;
}
.lesson-complete .card{
  border-color: rgba(212,175,55,.65);
  background:
    radial-gradient(800px 240px at 80% -40%, rgba(245,215,110,.28), transparent 65%),
    linear-gradient(180deg, rgba(255,255,255,1), rgba(255,248,226,1));
}
.lesson-complete .h2{
  color: #6b4f00;
}

/* ---------- Responsive tweaks ---------- */
@media (max-width: 480px){
  .lesson-title .h1{ font-size: 20px; }
  .lesson-meta{ gap: 8px; }
  .progress{ height: 12px; }
  .question-wrap{ padding: 12px; }
  .lesson-nav{ flex-direction: column; }
  .lesson-nav .btn{ width: 100%; }
}

math/public/assets/css/questions.css
/* =========================================================
   questions.css â€” Question Types Styling (Light Material)
   Depends on base.css
   ========================================================= */

/* ---------- Common Question Block ---------- */
.q{
  display:flex;
  flex-direction: column;
  gap: 10px;
}
.q-desc{
  font-size: 15px;
  color: var(--text);
  line-height: 1.75;
}

/* ---------- Input Question ---------- */
.q-input{
  display:flex;
  flex-direction: column;
  gap: 10px;
}
.q-input .input{
  font-size: 18px;
  font-weight: 600;
  text-align: center;
  letter-spacing: .3px;
}
.q-input .hint{
  font-size: 12px;
  color: var(--muted);
}

/* ---------- MCQ ---------- */
.q-mcq{
  display:grid;
  grid-template-columns: 1fr;
  gap: 10px;
}
.q-mcq .choice{
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 14px 16px;
  min-height: 48px;
  border-radius: 16px;
  border: 1px solid rgba(17,24,39,.14);
  background: rgba(255,255,255,.9);
  box-shadow: var(--shadow-xs);
  cursor:pointer;
  transition: background .18s ease, box-shadow .18s ease, border-color .18s ease;
}
.q-mcq .choice:hover{
  background: #fff;
  box-shadow: var(--shadow-sm);
}
.q-mcq .choice input{
  accent-color: var(--primary);
  cursor:pointer;
}
.q-mcq .choice.correct{
  border-color: rgba(22,163,74,.45);
  background: rgba(22,163,74,.10);
}
.q-mcq .choice.wrong{
  border-color: rgba(220,38,38,.45);
  background: rgba(220,38,38,.10);
}

/* ---------- Match (Structure only / future) ---------- */
.q-match{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}
.q-match .col{
  display:flex;
  flex-direction: column;
  gap: 8px;
}
.q-match .item{
  padding: 12px;
  border-radius: 14px;
  border: 1px solid rgba(17,24,39,.14);
  background: rgba(255,255,255,.9);
  box-shadow: var(--shadow-xs);
}

/* ---------- Feedback ---------- */
.q-feedback{
  font-size: 13px;
  font-weight: 800;
}
.q-feedback.ok{
  color: var(--success);
}
.q-feedback.err{
  color: var(--danger);
}

@media (max-width: 560px){
  .q-match{
    grid-template-columns: 1fr;
  }
}

math/public/assets/css/toast.css
/* =========================================================
   toast.css â€” Material Light Toast + Countdown Bar
   used by assets/js/ui/toast.js

   UPDATE (2026-01-14):
   - Toast host is anchored to the TOP of the *visual viewport*
     (handled by JS via translateY + height adjustment).
   ========================================================= */

:root{
  --toast-max: 420px;
  --toast-pad: 12px;
  --toast-gap: 10px;

  --toast-bg: rgba(255,255,255,.86);
  --toast-border: rgba(17,24,39,.12);
  --toast-shadow: 0 18px 40px rgba(17,24,39,.16);
  --toast-blur: 12px;

  --toast-title: #111827;
  --toast-text: #4b5563;
  --toast-bar-bg: rgba(17,24,39,.10);
  --toast-bar: rgba(37,99,235,1);

  --toast-ok: rgba(22,163,74,1);
  --toast-warn: rgba(245,158,11,1);
  --toast-err: rgba(220,38,38,1);
}

/* Container fixed on viewport */
.toast-host{
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 9999;
  display:flex;
  align-items:flex-start;          /* top */
  justify-content:center;

  /* JS will place us at top of VISUAL viewport; keep a small inner padding */
  padding: 12px 16px;
}

/* Toast element */
.toast{
  width: min(var(--toast-max), calc(100vw - 32px));
  pointer-events: auto;
  background: var(--toast-bg);
  border: 1px solid var(--toast-border);
  border-radius: 18px;
  box-shadow: var(--toast-shadow);
  backdrop-filter: blur(var(--toast-blur));
  -webkit-backdrop-filter: blur(var(--toast-blur));
  overflow: hidden;

  transform: translateY(-10px) scale(.98);
  opacity: 0;
  transition: transform .22s ease, opacity .22s ease;
}

.toast.is-show{
  transform: translateY(0) scale(1);
  opacity: 1;
}

.toast-inner{
  display:flex;
  gap: var(--toast-gap);
  padding: var(--toast-pad);
  align-items:flex-start;
}

/* Icon pill */
.toast-ic{
  width: 34px;
  height: 34px;
  border-radius: 14px;
  flex: 0 0 auto;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(37,99,235,.12);
  border: 1px solid rgba(37,99,235,.18);
  box-shadow: 0 10px 18px rgba(37,99,235,.10);
}

.toast-ic svg{
  width: 18px;
  height: 18px;
  fill: rgba(29,78,216,1);
}

.toast-content{
  flex: 1 1 auto;
  min-width: 0;
}

.toast-title{
  margin: 0;
  font-weight: 900;
  font-size: 14px;
  color: var(--toast-title);
  line-height: 1.2;
}

.toast-msg{
  margin: 6px 0 0;
  font-size: 13px;
  color: var(--toast-text);
  line-height: 1.45;
  word-wrap: break-word;
}

/* Progress bar (countdown) */
.toast-bar{
  height: 4px;
  width: 100%;
  background: var(--toast-bar-bg);
  position: relative;
}

.toast-bar > i{
  display:block;
  height: 100%;
  width: 100%;
  background: var(--toast-bar);
  transform-origin: right center; /* RTL feel */
  transform: scaleX(0);
}

/* Variants */
.toast[data-type="info"] .toast-ic{
  background: rgba(37,99,235,.12);
  border-color: rgba(37,99,235,.18);
}
.toast[data-type="info"] .toast-ic svg{ fill: rgba(29,78,216,1); }
.toast[data-type="info"] .toast-bar > i{ background: rgba(37,99,235,1); }

.toast[data-type="success"] .toast-ic{
  background: rgba(22,163,74,.12);
  border-color: rgba(22,163,74,.18);
  box-shadow: 0 10px 18px rgba(22,163,74,.10);
}
.toast[data-type="success"] .toast-ic svg{ fill: var(--toast-ok); }
.toast[data-type="success"] .toast-bar > i{ background: var(--toast-ok); }

.toast[data-type="warning"] .toast-ic{
  background: rgba(245,158,11,.14);
  border-color: rgba(245,158,11,.22);
  box-shadow: 0 10px 18px rgba(245,158,11,.10);
}
.toast[data-type="warning"] .toast-ic svg{ fill: var(--toast-warn); }
.toast[data-type="warning"] .toast-bar > i{ background: var(--toast-warn); }

.toast[data-type="danger"] .toast-ic,
.toast[data-type="error"] .toast-ic{
  background: rgba(220,38,38,.12);
  border-color: rgba(220,38,38,.18);
  box-shadow: 0 10px 18px rgba(220,38,38,.10);
}
.toast[data-type="danger"] .toast-ic svg,
.toast[data-type="error"] .toast-ic svg{ fill: var(--toast-err); }
.toast[data-type="danger"] .toast-bar > i,
.toast[data-type="error"] .toast-bar > i{ background: var(--toast-err); }

/* Reduced motion */
@media (prefers-reduced-motion: reduce){
  .toast{ transition: none; }
}

/* Mobile spacing tweak */
@media (max-width: 420px){
  .toast-inner{ padding: 10px; }
}

math/public/assets/js/admin.js
import { API_PATHS } from './core/constants.js';
import { normalizeDigits } from './core/normalizeDigits.js';
import { showToast } from './ui/toast.js';

const LS_ADMIN_SESSION = 'math:admin:session';
const LS_ADMIN_STUDENTS = 'math:admin:students';
const LS_ADMIN_CARDS = 'math:admin:cards';
const ADMIN_STUDENTS_API = [API_PATHS.ADMIN_STUDENTS];
const ADMIN_CARDS_API = [API_PATHS.ADMIN_CARDS];
const ADMIN_LOGIN_API = API_PATHS.ADMIN_LOGIN;
const ADMIN_PASSWORD_API = API_PATHS.ADMIN_PASSWORD;
let students = [];
let cards = [];

document.addEventListener('DOMContentLoaded', () => {
  const loginScreen = document.getElementById('screen-admin-login');
  const adminScreen = document.getElementById('screen-admin');

  const btnLogin = document.getElementById('btnAdminLogin');
  const btnLogout = document.getElementById('btnAdminLogout');

  const inputUser = document.getElementById('adminUser');
  const inputPass = document.getElementById('adminPass');
  const inputOldPass = document.getElementById('adminOldPass');
  const inputNewPass = document.getElementById('adminNewPass');
  const inputNewPassConfirm = document.getElementById('adminNewPassConfirm');
  const btnChangePassword = document.getElementById('btnAdminChangePassword');
  const adminLoading = document.getElementById('adminLoading');

  const tabs = Array.from(document.querySelectorAll('[data-tab]'));
  const panelStudents = document.getElementById('tab-students');
  const panelCards = document.getElementById('tab-cards');

  const studentsTable = document.getElementById('studentsTable');
  const btnAddStudent = document.getElementById('btnAddStudent');
  const btnSaveStudents = document.getElementById('btnSaveStudents');

  const cardsList = document.getElementById('cardsList');
  const btnAddCard = document.getElementById('btnAddCard');
  const btnSaveCards = document.getElementById('btnSaveCards');

  hideAllScreens();

  if (isLoggedIn()) {
    showAdmin();
  } else {
    showLogin();
  }

  btnLogin?.addEventListener('click', async () => {
    const user = String(inputUser?.value || '').trim();
    const pass = String(inputPass?.value || '').trim();

    if (!user || !pass) {
      showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±', 'warning');
      return;
    }
    try {
      setLoading(adminLoading, true, 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„...');
      const result = await loginAdmin(user, pass);
      if (!result?.ok || !result.token) {
        showToast('ØªØ¹Ø°Ø± ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„', 'ØªØ£ÙƒØ¯ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆØ§ØªØµØ§Ù„ Ø§Ù„Ø®Ø§Ø¯Ù…', 'error');
        return;
      }
      localStorage.setItem(
        LS_ADMIN_SESSION,
        JSON.stringify({ user, token: result.token || null, at: new Date().toISOString() })
      );
      showAdmin();
      showToast('Ù…Ø±Ø­Ø¨Ù‹Ø§', 'ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­', 'success');
    } catch (error) {
      showToast('Ø®Ø·Ø£', formatAdminErrorMessage(error, 'ØªØ¹Ø°Ø± ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„'), 'error');
    } finally {
      setLoading(adminLoading, false);
    }
  });

  btnLogout?.addEventListener('click', () => {
    localStorage.removeItem(LS_ADMIN_SESSION);
    showLogin();
    showToast('ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø®Ø±ÙˆØ¬', 'ÙŠÙ…ÙƒÙ†Ùƒ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø¬Ø¯Ø¯Ù‹Ø§', 'info');
  });

  btnChangePassword?.addEventListener('click', async () => {
    const user = getCurrentAdminUser();
    if (!user) {
      showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ù‹Ø§', 'warning');
      return;
    }

    const currentPassword = String(inputOldPass?.value || '').trim();
    const newPassword = String(inputNewPass?.value || '').trim();
    const confirmPassword = String(inputNewPassConfirm?.value || '').trim();

    if (!currentPassword || !newPassword || !confirmPassword) {
      showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ÙŠØ±Ø¬Ù‰ ØªØ¹Ø¨Ø¦Ø© Ø¬Ù…ÙŠØ¹ Ø­Ù‚ÙˆÙ„ ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±', 'warning');
      return;
    }

    if (newPassword !== confirmPassword) {
      showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© ØºÙŠØ± Ù…ØªØ·Ø§Ø¨Ù‚Ø©', 'warning');
      return;
    }

    try {
      setLoading(adminLoading, true, 'Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±...');
      await changeAdminPassword(user, currentPassword, newPassword);
      inputOldPass.value = '';
      inputNewPass.value = '';
      inputNewPassConfirm.value = '';
      showToast('ØªÙ… Ø§Ù„ØªØ­Ø¯ÙŠØ«', 'ØªÙ… ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ø¨Ù†Ø¬Ø§Ø­', 'success');
    } catch (error) {
      showToast('Ø®Ø·Ø£', formatAdminErrorMessage(error, 'ØªØ¹Ø°Ø± ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±'), 'error');
    } finally {
      setLoading(adminLoading, false);
    }
  });

  tabs.forEach((tabBtn) => {
    tabBtn.addEventListener('click', async () => {
      const tab = tabBtn.dataset.tab;
      tabs.forEach((btn) => btn.classList.toggle('is-active', btn === tabBtn));
      setScreenVisibility(panelStudents, tab === 'students');
      setScreenVisibility(panelCards, tab === 'cards');

      if (tab === 'students') {
        const cached = readLocalJson(LS_ADMIN_STUDENTS);
        if (cached && Array.isArray(cached)) {
          students = cached.map(normalizeStudent);
        }
        renderStudents(studentsTable);
        await refreshStudents({ silent: Boolean(cached), showStatus: true });
        renderStudents(studentsTable);
      }

      if (tab === 'cards') {
        const cachedCards = readLocalJson(LS_ADMIN_CARDS);
        if (cachedCards && Array.isArray(cachedCards)) {
          cards = cachedCards.map(normalizeCard);
        }
        renderCards(cardsList);
        await refreshCards({ silent: Boolean(cachedCards), showStatus: true });
        renderCards(cardsList);
      }
    });
  });

  btnAddStudent?.addEventListener('click', () => {
    students.unshift({
      id: '',
      birthYear: '',
      firstName: '',
      fullName: '',
      class: '',
    });
    renderStudents(studentsTable);
  });

  btnSaveStudents?.addEventListener('click', async () => {
    if (!btnSaveStudents) return;
    const original = btnSaveStudents.textContent;
    btnSaveStudents.disabled = true;
    btnSaveStudents.textContent = 'Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸...';
    try {
      showToast('Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸', 'Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨', 'info');
      await saveStudents();
      showToast('ØªÙ… Ø§Ù„Ø­ÙØ¸', 'ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'success');
    } catch (error) {
      showToast('Ø®Ø·Ø£', formatAdminErrorMessage(error, 'ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨'), 'error');
    } finally {
      btnSaveStudents.disabled = false;
      btnSaveStudents.textContent = original || 'Ø­ÙØ¸ Ø§Ù„Ø¢Ù†';
    }
  });

  btnAddCard?.addEventListener('click', () => {
    const maxWeek = cards.reduce((max, card) => {
      const value = Number(card.week);
      return Number.isFinite(value) ? Math.max(max, value) : max;
    }, 0);

    const newCard = {
      week: maxWeek + 1,
      title: 'Ø¨Ø·Ø§Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø©',
      prereq: null,
      className: '',
      sections: [],
    };

    cards.unshift(newCard);
    localStorage.setItem(LS_ADMIN_CARDS, JSON.stringify(cards));
    renderCards(cardsList);
    window.location.href = `/admin-card-builder.html?id=${encodeURIComponent(newCard.week)}`;
  });

  btnSaveCards?.addEventListener('click', async () => {
    if (!btnSaveCards) return;
    const original = btnSaveCards.textContent;
    btnSaveCards.disabled = true;
    btnSaveCards.textContent = 'Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸...';
    try {
      showToast('Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸', 'Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª', 'info');
      await saveCards();
      showToast('ØªÙ… Ø§Ù„Ø­ÙØ¸', 'ØªÙ… Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª', 'success');
    } catch (error) {
      showToast('Ø®Ø·Ø£', formatAdminErrorMessage(error, 'ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª'), 'error');
    } finally {
      btnSaveCards.disabled = false;
      btnSaveCards.textContent = original || 'Ø­ÙØ¸ Ø§Ù„Ø¢Ù†';
    }
  });

  studentsTable?.addEventListener('input', (event) => {
    const target = event.target;
    if (!(target instanceof HTMLInputElement)) return;

    const index = Number(target.dataset.index);
    const field = target.dataset.field;

    if (!Number.isFinite(index) || !field) return;

    if (!students[index]) return;

    if (field === 'id' || field === 'birthYear') {
      const cleaned = normalizeDigits(target.value).replace(/[^0-9]/g, '');
      target.value = cleaned;
    }

    students[index][field] = target.value.trim();
  });

  studentsTable?.addEventListener('click', (event) => {
    const target = event.target;
    if (!(target instanceof HTMLButtonElement)) return;

    if (target.dataset.action !== 'delete-student') return;
    const index = Number(target.dataset.index);
    if (!Number.isFinite(index)) return;

    students.splice(index, 1);
    renderStudents(studentsTable);
  });

  cardsList?.addEventListener('click', (event) => {
    const target = event.target;
    if (!(target instanceof HTMLButtonElement)) return;

    const action = target.dataset.action;
    if (action !== 'delete-card') return;
    const index = Number(target.dataset.index);
    if (!Number.isFinite(index)) return;

    cards.splice(index, 1);
    localStorage.setItem(LS_ADMIN_CARDS, JSON.stringify(cards));
    renderCards(cardsList);
  });

  function hideAllScreens() {
    setScreenVisibility(loginScreen, false);
    setScreenVisibility(adminScreen, false);
  }

  function showLogin() {
    hideAllScreens();
    setScreenVisibility(loginScreen, true);
    setScreenVisibility(adminScreen, false);
    document.body.classList.remove('is-loading');
    btnLogout?.classList.add('hidden');
  }

  async function showAdmin() {
    hideAllScreens();
    setScreenVisibility(adminScreen, true);
    document.body.classList.remove('is-loading');
    btnLogout?.classList.remove('hidden');

    const { hasCachedStudents, hasCachedCards } = loadData();
    renderStudents(studentsTable);
    renderCards(cardsList);

    refreshStudents({ silent: hasCachedStudents, showStatus: true })
      .then(() => renderStudents(studentsTable))
      .catch(() => {});
    refreshCards({ silent: hasCachedCards, showStatus: true })
      .then(() => renderCards(cardsList))
      .catch(() => {});
  }

  function setScreenVisibility(screen, isVisible) {
    if (!screen) return;
    screen.classList.toggle('hidden', !isVisible);
    screen.toggleAttribute('hidden', !isVisible);
    if (isVisible) {
      screen.style.removeProperty('display');
      if (!screen.getAttribute('style')) {
        screen.removeAttribute('style');
      }
    } else {
      screen.style.display = 'none';
    }
  }
});

function isLoggedIn() {
  return Boolean(getAdminToken());
}

function loadData() {
  const cachedStudents = readLocalJson(LS_ADMIN_STUDENTS);
  if (cachedStudents && Array.isArray(cachedStudents)) {
    students = cachedStudents.map(normalizeStudent);
  }

  const cachedCards = readLocalJson(LS_ADMIN_CARDS);
  if (cachedCards && Array.isArray(cachedCards)) {
    cards = cachedCards.map(normalizeCard);
  }
  return {
    hasCachedStudents: Boolean(cachedStudents),
    hasCachedCards: Boolean(cachedCards),
  };
}

async function refreshStudents({ silent = false, showStatus = false } = {}) {
  const adminLoading = document.getElementById('adminLoading');
  if (showStatus) {
    showToast('Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„', 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨', 'info');
  }
  try {
    setLoading(adminLoading, true, 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨...');
    students = await loadStudentsFromApi();
    localStorage.setItem(LS_ADMIN_STUDENTS, JSON.stringify(students));
    if (showStatus) {
      showToast('ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„', 'ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¨Ù†Ø¬Ø§Ø­', 'success');
    }
  } catch (error) {
    if (!silent) {
      if (isNetworkError(error)) {
        showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ØªØ¹Ø°Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…ØŒ ØªÙ… Ø¹Ø±Ø¶ Ù†Ø³Ø®Ø© Ù…Ø­Ù„ÙŠØ© Ù„Ù„Ø·Ù„Ø§Ø¨', 'warning');
        return;
      }

      showToast('Ø®Ø·Ø£', formatAdminErrorMessage(error, 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨'), 'error');
    }
    students = [];
  } finally {
    setLoading(adminLoading, false);
  }
}

async function refreshCards({ silent = false, showStatus = false } = {}) {
  const adminLoading = document.getElementById('adminLoading');
  if (showStatus) {
    showToast('Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„', 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª', 'info');
  }
  try {
    setLoading(adminLoading, true, 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª...');
    cards = mergeCardMetadata(await loadCardsFromApi());
    localStorage.setItem(LS_ADMIN_CARDS, JSON.stringify(cards));
    if (showStatus) {
      showToast('ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„', 'ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø¨Ù†Ø¬Ø§Ø­', 'success');
    }
  } catch (error) {
    if (!silent) {
      if (isNetworkError(error)) {
        showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ØªØ¹Ø°Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…ØŒ ØªÙ… Ø¹Ø±Ø¶ Ù†Ø³Ø®Ø© Ù…Ø­Ù„ÙŠØ© Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª', 'warning');
        return;
      }

      showToast('Ø®Ø·Ø£', formatAdminErrorMessage(error, 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª'), 'error');
    }
    cards = [];
  } finally {
    setLoading(adminLoading, false);
  }
}

function renderStudents(container) {
  if (!container) return;
  container.innerHTML = '';

  students.forEach((student, index) => {
    const row = document.createElement('tr');
    row.innerHTML = `
      <td><input class="input ltr" data-index="${index}" data-field="id" value="${escapeValue(student.id)}" placeholder="Ù…Ø«Ø§Ù„: 123456" /></td>
      <td><input class="input ltr" data-index="${index}" data-field="birthYear" value="${escapeValue(student.birthYear)}" placeholder="2012" /></td>
      <td><input class="input" data-index="${index}" data-field="firstName" value="${escapeValue(student.firstName)}" placeholder="Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„" /></td>
      <td><input class="input" data-index="${index}" data-field="fullName" value="${escapeValue(student.fullName)}" placeholder="Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„" /></td>
      <td><input class="input" data-index="${index}" data-field="class" value="${escapeValue(student.class)}" placeholder="7/1" /></td>
      <td><button class="btn btn-ghost btn-sm" type="button" data-action="delete-student" data-index="${index}">Ø­Ø°Ù</button></td>
    `;
    container.appendChild(row);
  });
}

function renderCards(container) {
  if (!container) return;
  container.innerHTML = '';

  const grouped = groupCardsByClass(cards);
  grouped.forEach(({ groupName, items }) => {
    const groupEl = document.createElement('div');
    groupEl.className = 'admin-card-group';
    groupEl.innerHTML = `<h4 class="admin-card-group-title">${escapeValue(groupName)}</h4>`;

    items.forEach((card) => {
      const cardIndex = cards.indexOf(card);
      const cardEl = document.createElement('div');
      cardEl.className = 'admin-card';
      cardEl.innerHTML = `
        <div>
          <strong>Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ${escapeValue(card.week ?? '--')}</strong>
          <div>${escapeValue(card.title || 'Ø¨Ø·Ø§Ù‚Ø© Ø¨Ø¯ÙˆÙ† Ø¹Ù†ÙˆØ§Ù†')}</div>
        </div>
        <div class="card-actions">
          <a class="btn btn-outline btn-sm" href="/admin-card-builder.html?id=${encodeURIComponent(card.week ?? '')}">
            ØªØ¹Ø¯ÙŠÙ„ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©
          </a>
          <button class="btn btn-ghost btn-sm" type="button" data-action="delete-card" data-index="${cardIndex}">Ø­Ø°Ù Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©</button>
        </div>
      `;
      groupEl.appendChild(cardEl);
    });

    container.appendChild(groupEl);
  });
}

function escapeValue(value) {
  return String(value ?? '')
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;');
}

function formatAdminErrorMessage(error, fallback) {
  const message = String(error?.message || fallback);

  if (message === 'DUPLICATE_STUDENT_ID') {
    return 'ÙŠÙˆØ¬Ø¯ ØªÙƒØ±Ø§Ø± ÙÙŠ Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ©. ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ØªÙƒØ±Ø§Ø± Ø±Ù‚Ù… Ø§Ù„Ø·Ø§Ù„Ø¨.';
  }

  if (message === 'BAD_REQUEST') {
    return 'ÙŠØ±Ø¬Ù‰ ØªØ¹Ø¨Ø¦Ø© Ø¬Ù…ÙŠØ¹ Ø­Ù‚ÙˆÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸.';
  }

  if (message === 'EMPTY_STUDENT_LIST') {
    return 'Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø­Ø°Ù Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø¯ÙˆÙ† ØªØ£ÙƒÙŠØ¯ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ø´Ø§Ù…Ù„.';
  }

  if (message === 'INVALID_PREREQ_WEEK') {
    return 'Ø±Ù‚Ù… Ø§Ù„Ù…ØªØ·Ù„Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚ ØºÙŠØ± ØµØ§Ù„Ø­. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù…ÙˆØ¬ÙˆØ¯.';
  }

  if (message === 'DB_ERROR') {
    return 'ØªØ¹Ø°Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ù‹Ø§.';
  }

  if (message === 'INVALID_ADMIN_LOGIN') {
    return 'Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„ ØºÙŠØ± ØµØ­ÙŠØ­Ø©.';
  }

  if (message === 'ADMIN_DISABLED') {
    return 'Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© ØºÙŠØ± Ù…ÙØ¹Ù‘Ù„.';
  }

  if (message === 'ADMIN_NOT_FOUND') {
    return 'Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø­Ø³Ø§Ø¨ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.';
  }

  if (message === 'ADMIN_AUTH_REQUIRED') {
    return 'ÙŠÙ„Ø²Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©.';
  }

  if (message === 'ADMIN_AUTH_INVALID') {
    return 'Ø¬Ù„Ø³Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©. ÙŠØ±Ø¬Ù‰ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ù† Ø¬Ø¯ÙŠØ¯.';
  }

  if (message === 'ADMIN_AUTH_MISMATCH') {
    return 'Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ù„Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù….';
  }

  return message;
}

async function saveStudents() {
  await saveStudentsToApi(students);
  students = await loadStudentsFromApi();
  localStorage.setItem(LS_ADMIN_STUDENTS, JSON.stringify(students));
}

async function saveCards() {
  await saveCardsToApi(cards);
  cards = await loadCardsFromApi();
  localStorage.setItem(LS_ADMIN_CARDS, JSON.stringify(cards));
}

function normalizeStudent(row) {
  return {
    id: row.StudentId ?? row.studentId ?? row.id ?? '',
    birthYear: row.BirthYear ?? row.birthYear ?? '',
    firstName: row.FirstName ?? row.firstName ?? '',
    fullName: row.FullName ?? row.fullName ?? '',
    class: row.Class ?? row.class ?? '',
  };
}

function normalizeCard(row) {
  return {
    week: row.Week ?? row.week ?? '',
    title: row.Title ?? row.title ?? '',
    prereq: row.PrereqWeek ?? row.prereq ?? null,
    className: row.className ?? row.class ?? '',
    sections: Array.isArray(row.sections) ? row.sections : [],
  };
}

function readLocalJson(key) {
  try {
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

async function loadStudentsFromApi() {
  for (const endpoint of ADMIN_STUDENTS_API) {
    const res = await fetch(endpoint, {
      method: 'GET',
      cache: 'no-store',
      headers: {
        'Cache-Control': 'no-store',
        Pragma: 'no-cache',
        ...getAdminAuthHeaders(),
      },
    });

    let payload = null;
    try {
      payload = await res.json();
    } catch (error) {
      payload = null;
    }

    if (res.status === 404) {
      continue;
    }

    if (!res.ok) {
      const message = payload?.message || payload?.error || 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨';
      const err = new Error(message);
      err.status = res.status;
      throw err;
    }

    var studentsPayload = Array.isArray(payload) ? payload : payload?.students;
    if (!Array.isArray(studentsPayload)) {
      throw new Error('ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨');
    }

    return studentsPayload.map(normalizeStudent);
  }

  const err = new Error('ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨');
  err.status = 404;
  throw err;
}

async function saveStudentsToApi(studentsArray) {
  const payload = {
    students: studentsArray.map((student) => ({
      studentId: normalizeDigits(String(student.id || '').trim()),
      birthYear: normalizeDigits(String(student.birthYear || '').trim()),
      firstName: student.firstName,
      fullName: student.fullName,
      class: student.class,
      StudentId: normalizeDigits(String(student.id || '').trim()),
      BirthYear: normalizeDigits(String(student.birthYear || '').trim()),
      FirstName: student.firstName,
      FullName: student.fullName,
      Class: student.class,
    })),
    replaceAll: studentsArray.length === 0,
  };

  for (const endpoint of ADMIN_STUDENTS_API) {
    const res = await fetch(endpoint, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...getAdminAuthHeaders(),
      },
      body: JSON.stringify(payload),
    });

    let responsePayload = null;
    try {
      responsePayload = await res.json();
    } catch (error) {
      responsePayload = null;
    }

    if (res.status === 404) {
      continue;
    }

    if (!res.ok || responsePayload?.ok === false) {
      const message = responsePayload?.message || responsePayload?.error || 'ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨';
      const err = new Error(message);
      err.status = res.status;
      throw err;
    }

    return;
  }

  const err = new Error('ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨');
  err.status = 404;
  throw err;
}

async function loadCardsFromApi() {
  for (const endpoint of ADMIN_CARDS_API) {
    const res = await fetch(endpoint, {
      method: 'GET',
      cache: 'no-store',
      headers: {
        'Cache-Control': 'no-store',
        Pragma: 'no-cache',
        ...getAdminAuthHeaders(),
      },
    });

    let payload = null;
    try {
      payload = await res.json();
    } catch (error) {
      payload = null;
    }

    if (res.status === 404) {
      continue;
    }

    if (!res.ok) {
      const message = payload?.message || payload?.error || 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª';
      const err = new Error(message);
      err.status = res.status;
      throw err;
    }

    const cardsPayload = Array.isArray(payload) ? payload : payload?.cards;
    if (!Array.isArray(cardsPayload)) {
      throw new Error('ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª');
    }

    return cardsPayload.map(normalizeCard);
  }

  const err = new Error('ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª');
  err.status = 404;
  throw err;
}

function mergeCardMetadata(remoteCards) {
  const cached = readLocalJson(LS_ADMIN_CARDS);
  const cacheMap = new Map(
    Array.isArray(cached)
      ? cached.map((card) => [String(card.week), normalizeCard(card)])
      : [],
  );

  return remoteCards.map((card) => {
    const cachedCard = cacheMap.get(String(card.week));
    return {
      ...card,
      className: cachedCard?.className || card.className || '',
      sections: Array.isArray(cachedCard?.sections) ? cachedCard.sections : card.sections || [],
    };
  });
}

async function saveCardsToApi(cardsArray) {
  const payload = {
    cards: cardsArray.map((card) => ({
      week: card.week,
      title: card.title,
      prereq: card.prereq,
    })),
  };

  for (const endpoint of ADMIN_CARDS_API) {
    const res = await fetch(endpoint, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...getAdminAuthHeaders(),
      },
      body: JSON.stringify(payload),
    });

    let responsePayload = null;
    try {
      responsePayload = await res.json();
    } catch (error) {
      responsePayload = null;
    }

    if (res.status === 404) {
      continue;
    }

    if (!res.ok || responsePayload?.ok === false) {
      const message = responsePayload?.message || responsePayload?.error || 'ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª';
      const err = new Error(message);
      err.status = res.status;
      throw err;
    }

    return;
  }

  const err = new Error('ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª');
  err.status = 404;
  throw err;
}

function isNetworkError(error) {
  return error instanceof TypeError && !('status' in error);
}

function getCurrentAdminUser() {
  try {
    const raw = localStorage.getItem(LS_ADMIN_SESSION);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return parsed?.user || null;
  } catch {
    return null;
  }
}

async function loginAdmin(username, password) {
  try {
    const res = await fetch(ADMIN_LOGIN_API, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password }),
    });

    if (res.status === 404) {
      return { ok: false, token: null };
    }

    const payload = await res.json().catch(() => null);
    if (!res.ok || payload?.ok === false) {
      return { ok: false, token: null };
    }
    return { ok: true, token: payload?.token || null };
  } catch (error) {
    if (isNetworkError(error)) {
      return { ok: false, token: null };
    }
    throw error;
  }
}

async function changeAdminPassword(username, currentPassword, newPassword) {
  const res = await fetch(ADMIN_PASSWORD_API, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...getAdminAuthHeaders() },
    body: JSON.stringify({ username, currentPassword, newPassword }),
  });

  const payload = await res.json().catch(() => null);
  if (res.status === 404) {
    throw new Error('ØªØ¹Ø°Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„Ø®Ø§Ø¯Ù…');
  }
  if (!res.ok || payload?.ok === false) {
    const message = payload?.message || payload?.error || 'ØªØ¹Ø°Ø± ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±';
    throw new Error(message);
  }
}

function groupCardsByClass(cardsList) {
  const grouped = new Map();
  cardsList.forEach((card) => {
    const key = card.className?.trim() || 'Ø¨Ø·Ø§Ù‚Ø§Øª Ø¨Ø¯ÙˆÙ† ØµÙ';
    if (!grouped.has(key)) grouped.set(key, []);
    grouped.get(key).push(card);
  });

  return Array.from(grouped.entries()).map(([groupName, items]) => ({
    groupName,
    items: items.sort((a, b) => Number(a.week) - Number(b.week)),
  }));
}

function setLoading(overlay, isVisible, message) {
  if (!overlay) return;
  overlay.classList.toggle('hidden', !isVisible);
  overlay.toggleAttribute('hidden', !isVisible);
  if (message) {
    const text = overlay.querySelector('span:last-child');
    if (text) text.textContent = message;
  }
}

function getAdminAuthHeaders() {
  const token = getAdminToken();
  return token ? { Authorization: `Bearer ${token}` } : {};
}

function getAdminToken() {
  try {
    const raw = localStorage.getItem(LS_ADMIN_SESSION);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    return parsed?.token || null;
  } catch {
    return null;
  }
}

math/public/assets/js/app.js
/* =========================================================
   app.js â€” App Bootstrap & Page Router
   - Login uses: (Student ID + Birth Year) against local data
   - Greets by firstName
   - Stores current student profile for later certificates

   UPDATE (2026-01-14):
   - Fix UI flash: hide all screens first, show correct one
   - Remove old auto-welcome based on lastStudentId only
   ========================================================= */

import {
  clearStudentSession,
  getLastStudentId,
  getStudentSession,
  setCachedCards,
  setLastStudentId,
  setStudentCompletions,
  setStudentSession,
  syncCardCompletions,
} from './core/storage.js';
import { initCardsPage } from './cards/cardsPage.js';
import { getWeekParam } from './core/router.js';
import { showToast } from './ui/toast.js';
import { initLessonPage } from './lesson/lessonPage.js';
import { findStudentByIdentity } from './core/students.js';
import { fetchJson } from './core/api.js';
import { API_PATHS } from './core/constants.js';
import { normalizeDigits } from './core/normalizeDigits.js';

const LS_CURRENT_STUDENT = 'math:currentStudent'; // legacy cache

document.addEventListener('DOMContentLoaded', () => {
  const week = getWeekParam();

  if (week) {
    initLessonPage();
  } else {
    initIndexPage();
  }
});

/* ---------- Index Page Logic ---------- */
function initIndexPage() {
  const screenId = document.getElementById('screen-id');
  const screenWelcome = document.getElementById('screen-welcome');
  const screenCards = document.getElementById('screen-cards');

  const inputId = document.getElementById('studentId');
  const btnLogin = document.getElementById('btnLogin');
  const btnToCards = document.getElementById('btnToCards');
  const btnChangeId = document.getElementById('btnChangeId');
  const btnLogout = document.getElementById('btnLogout');

  const welcomeTitle = document.getElementById('welcomeTitle');
  const welcomeChip = document.getElementById('welcomeChip');
  const welcomeName = document.getElementById('welcomeName');

  // Ensure Birth Year input exists (inject if missing)
  const inputBirthYear = ensureBirthYearInput(inputId);

  hideAllScreens();

  const currentSession = normalizeStoredStudent(getStudentSession());
  if (currentSession?.id && currentSession?.birthYear) {
    setLastStudentId(currentSession.id);
    showCards();
    loadStudentData(currentSession, { silent: true });
  } else {
    const lastId = getLastStudentId();
    if (lastId && inputId) inputId.value = String(lastId);
    showId();
  }

  async function attemptLogin() {
    const id = normalizeDigits(inputId?.value || '').trim();
    const birthYear = normalizeDigits(inputBirthYear?.value || '').trim();

    if (!id) {
      showToast('ØªÙ†Ø¨ÙŠÙ‡', 'Ø§Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ© Ø£ÙˆÙ„Ù‹Ø§', 'warning');
      return;
    }
    if (!birthYear) {
      showToast('ØªÙ†Ø¨ÙŠÙ‡', 'Ø§Ø¯Ø®Ù„ Ø³Ù†Ø© Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯ (Ù…Ø«Ø§Ù„: 2012)', 'warning');
      return;
    }

    const fallbackLogin = async () => {
      const found = await findStudentByIdentity(id, birthYear);

      if (!found) {
        showToast('Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©', 'ØªØ£ÙƒØ¯ Ù…Ù† Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ© ÙˆØ³Ù†Ø© Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯', 'warning', 3500);
        return;
      }

      const student = {
        id: String(found.id),
        birthYear: String(found.birthYear),
        firstName: String(found.firstName || '').trim() || String(found.fullName || '').trim().split(' ')[0] || `Ø·Ø§Ù„Ø¨ ${found.id}`,
        fullName: String(found.fullName || '').trim() || `Ø·Ø§Ù„Ø¨ ${found.id}`,
        class: found.class ? String(found.class) : '',
      };

      setLastStudentId(student.id);
      setStudentSession(student);
      writeCurrentStudent(student);
      showWelcome(student);
      showToast('ØªÙ… Ø§Ù„Ø¯Ø®ÙˆÙ„', `Ø£Ù‡Ù„Ù‹Ø§ ${student.firstName} ğŸ‘‹`, 'success', 2500);
      await loadStudentData(student);
    };

    try {
      setLoginLoading(true);
      const data = await fetchJson(API_PATHS.STUDENT_LOGIN, {
        method: 'POST',
        body: { studentId: id, birthYear },
      });

      const payload = data?.student ?? data;
      const profile = normalizeStoredStudent(payload);

      if (profile?.id && profile?.birthYear) {
        writeCurrentStudent(payload);
        setStudentSession(profile);
        if (profile?.id) setLastStudentId(profile.id);
        showWelcome(profile);
        showToast('ØªÙ… Ø§Ù„Ø¯Ø®ÙˆÙ„', `Ø£Ù‡Ù„Ù‹Ø§ ${profile.firstName} ğŸ‘‹`, 'success', 2500);
        await loadStudentData(profile);
        return;
      }
    } catch (e) {
      console.warn('API login failed, falling back to local data.', e);
    } finally {
      setLoginLoading(false);
    }

    try {
      await fallbackLogin();
    } catch (e) {
      console.error(e);
      showToast('Ø®Ø·Ø£', 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨', 'error', 4000);
    }
  }

  btnLogin?.addEventListener('click', () => {
    attemptLogin();
  });

  const enterHandler = (event) => {
    if (event.key !== 'Enter') return;
    event.preventDefault();
    attemptLogin();
  };

  inputId?.addEventListener('keydown', enterHandler);
  inputBirthYear?.addEventListener('keydown', enterHandler);

  btnToCards?.addEventListener('click', () => showCards());
  btnChangeId?.addEventListener('click', () => showId());

  btnLogout?.addEventListener('click', () => {
    clearCurrentStudent();
    clearStudentSession();
    try { localStorage.removeItem('math:lastStudentId'); } catch {}
    showId();
    if (inputId) inputId.value = '';
    if (inputBirthYear) inputBirthYear.value = '';
  });

  function setScreenVisibility(screen, isVisible) {
    if (!screen) return;
    screen.classList.toggle('hidden', !isVisible);
    screen.toggleAttribute('hidden', !isVisible);
    if (isVisible) {
      screen.style.removeProperty('display');
      if (!screen.getAttribute('style')) {
        screen.removeAttribute('style');
      }
    } else {
      screen.style.display = 'none';
    }
  }

  function hideAllScreens() {
    setScreenVisibility(screenId, false);
    setScreenVisibility(screenWelcome, false);
    setScreenVisibility(screenCards, false);
  }

  function setAppReady() {
    document.body.classList.remove('is-loading');
  }

  function setLoginLoading(isLoading) {
    if (!btnLogin) return;
    btnLogin.disabled = isLoading;
    btnLogin.textContent = isLoading ? 'Ø¬Ø§Ø±Ù Ø§Ù„ØªØ­Ù‚Ù‚...' : 'Ø¯Ø®ÙˆÙ„';
  }

  function showId() {
    setAppReady();
    setScreenVisibility(screenId, true);
    setScreenVisibility(screenWelcome, false);
    setScreenVisibility(screenCards, false);
  }

  function showWelcome(student) {
    const firstName = student?.firstName || student?.id || 'Ø·Ø§Ù„Ø¨';
    const fullName = student?.fullName || `Ø·Ø§Ù„Ø¨ ${student?.id || ''}`.trim();

    if (welcomeTitle) welcomeTitle.textContent = `Ù…Ø±Ø­Ø¨Ù‹Ø§ ÙŠØ§ ${firstName} ğŸ‘‹`;
    if (welcomeChip) welcomeChip.textContent = fullName;
    if (welcomeName) welcomeName.textContent = fullName;

    setAppReady();
    setScreenVisibility(screenId, false);
    setScreenVisibility(screenWelcome, true);
    setScreenVisibility(screenCards, false);

  }

  function showCards() {
    setAppReady();
    setScreenVisibility(screenId, false);
    setScreenVisibility(screenWelcome, false);
    setScreenVisibility(screenCards, true);
    initCardsPage();
  }

}

function writeCurrentStudent(student) {
  try {
    localStorage.setItem(LS_CURRENT_STUDENT, JSON.stringify(student));
  } catch {}
}

function clearCurrentStudent() {
  try {
    localStorage.removeItem(LS_CURRENT_STUDENT);
  } catch {}
}

async function loadStudentData(student, { silent = false } = {}) {
  if (!student?.id) return;

  const btnToCards = document.getElementById('btnToCards');
  const originalLabel = btnToCards?.textContent;
  if (btnToCards) {
    btnToCards.disabled = true;
    btnToCards.textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„...';
  }

  try {
    const [progress, cards] = await Promise.all([
      fetchJson(`${API_PATHS.PROGRESS_COMPLETED}?studentId=${encodeURIComponent(student.id)}`, { noStore: true }),
      fetchJson(API_PATHS.CARDS, { noStore: true }),
    ]);

    setStudentCompletions(student.id, Array.isArray(progress) ? progress : []);
    syncCardCompletions(student.id, Array.isArray(progress) ? progress : []);
    setCachedCards(Array.isArray(cards) ? cards : []);
  } catch (error) {
    if (!silent) {
      showToast('Ø®Ø·Ø£', error.message || 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨', 'error');
    }
  } finally {
    if (btnToCards) {
      btnToCards.disabled = false;
      btnToCards.textContent = originalLabel || 'Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª';
    }
  }
}

function normalizeStoredStudent(student) {
  if (!student) return null;
  const normalizedId = student.id ?? student.studentId ?? student.StudentId ?? '';
  const normalizedBirthYear = student.birthYear ?? student.BirthYear ?? '';
  const fullName = student.fullName ?? student.FullName ?? '';
  const firstName = student.firstName ?? student.FirstName ?? '';
  const resolvedFullName = String(fullName || '').trim() || `Ø·Ø§Ù„Ø¨ ${normalizedId}`.trim();
  const resolvedFirstName =
    String(firstName || '').trim() ||
    resolvedFullName.split(' ')[0] ||
    `Ø·Ø§Ù„Ø¨ ${normalizedId}`.trim();

  return {
    id: String(normalizedId),
    birthYear: String(normalizedBirthYear),
    firstName: resolvedFirstName,
    fullName: resolvedFullName,
    class: String(student.class ?? student.Class ?? '')
  };
}

/* ---------- UI: Birth Year input injection ---------- */
function ensureBirthYearInput(inputIdEl) {
  let el = document.getElementById('studentBirthYear');
  if (el) return el;

  if (!inputIdEl) return null;

  const field = inputIdEl.closest('.field') || inputIdEl.parentElement;
  if (!field) return null;

  const wrap = document.createElement('div');
  wrap.className = 'field';
  wrap.style.marginTop = '12px';

  wrap.innerHTML = `
    <label class="label" for="studentBirthYear">Ø³Ù†Ø© Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯</label>
    <input id="studentBirthYear" class="input ltr" inputmode="numeric" autocomplete="off" placeholder="Ù…Ø«Ø§Ù„: 2012" />
    <div class="help">Ø§ÙƒØªØ¨ Ø³Ù†Ø© Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯ ÙÙ‚Ø· (4 Ø£Ø±Ù‚Ø§Ù…).</div>
  `;

  field.insertAdjacentElement('afterend', wrap);
  el = wrap.querySelector('#studentBirthYear');

  el.addEventListener('input', () => {
    el.value = normalizeDigits(String(el.value || '')).replace(/[^0-9]/g, '').slice(0, 4);
  });

  el.addEventListener('keydown', (e) => {
    const allowed = ['Backspace','Delete','ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Tab','Home','End','Enter'];
    if (allowed.includes(e.key)) return;
    if (e.ctrlKey || e.metaKey) return;
    if (!/^[0-9Ù -Ù©Û°-Û¹]$/.test(e.key)) e.preventDefault();
  });

  return el;
}

math/public/assets/js/card-builder.js
import { fetchJson } from './core/api.js';
import { normalizeDigits } from './core/normalizeDigits.js';
import { showToast } from './ui/toast.js';

const LS_ADMIN_SESSION = 'math:admin:session';
const LS_ADMIN_CARDS = 'math:admin:cards';
const CARDS_PATH = '/api/cards-mng';

const ITEM_TYPES = [
  { value: 'question', label: 'Ø³Ø¤Ø§Ù„' },
  { value: 'example', label: 'Ù…Ø«Ø§Ù„' },
  { value: 'non-example', label: 'Ù„Ø§ Ù…Ø«Ø§Ù„' },
  { value: 'explain', label: 'Ø´Ø±Ø­' },
  { value: 'note', label: 'Ù…Ù„Ø§Ø­Ø¸Ø©' },
  { value: 'goal', label: 'Ù‡Ø¯Ù' },
  { value: 'image', label: 'ØµÙˆØ±Ø©' },
  { value: 'video', label: 'ÙÙŠØ¯ÙŠÙˆ ÙŠÙˆØªÙŠÙˆØ¨' },
];

const SECTION_TYPES = [
  { value: 'goal', label: 'Ù‡Ø¯Ù' },
  { value: 'prereq', label: 'Ù…ØªØ·Ù„Ø¨ Ø³Ø§Ø¨Ù‚' },
  { value: 'goals', label: 'Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©' },
  { value: 'assessment', label: 'Ø§Ø®ØªØ¨Ø± Ù†ÙØ³ÙŠ' },
];

const QUESTION_TYPES = [
  { value: 'mcq', label: 'Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ù…ØªØ¹Ø¯Ø¯' },
  { value: 'true-false', label: 'ØµÙˆØ§Ø¨ ÙˆØ®Ø·Ø£' },
  { value: 'number', label: 'Ø§Ø¯Ø®Ù„ Ø§Ù„Ø¬ÙˆØ§Ø¨ (Ø¹Ø¯Ø¯)' },
  { value: 'short-text', label: 'Ø¥Ø¬Ø§Ø¨Ø© Ù‚ØµÙŠØ±Ø©' },
  { value: 'long-text', label: 'ÙÙ‚Ø±Ø© Ø·ÙˆÙŠÙ„Ø©' },
  { value: 'matching', label: 'ØªÙˆØµÙŠÙ„' },
  { value: 'ordering', label: 'ØªØ±ØªÙŠØ¨ (Ø³Ø­Ø¨ ÙˆØ¥ÙÙ„Ø§Øª)' },
];

let cards = [];
let activeCard = null;
let dragState = null;
let lastAutoSaveAttempt = 0;
let lastAutoSaveResult = 0;
const AUTO_SAVE_TOAST_WINDOW = 8000;

document.addEventListener('DOMContentLoaded', async () => {
  const sectionsList = document.getElementById('sectionsList');
  const inputWeek = document.getElementById('cardWeek');
  const inputClass = document.getElementById('cardClass');
  const inputSections = document.getElementById('cardSections');
  const inputTitle = document.getElementById('cardTitle');
  const inputPrereq = document.getElementById('cardPrereq');
  const inputAssessmentTitle = document.getElementById('assessmentTitle');
  const inputAssessmentDescription = document.getElementById('assessmentDescription');
  const goalsList = document.getElementById('goalsList');
  const prereqsList = document.getElementById('prereqsList');
  const btnAddGoal = document.getElementById('btnAddGoal');
  const btnAddPrereq = document.getElementById('btnAddPrereq');
  const toolbarSave = document.getElementById('toolbarSave');
  const floatingSave = document.getElementById('floatingSave');
  const floatingApply = document.getElementById('floatingApply');
  const floatingPreview = document.getElementById('floatingPreview');
  const floatingAdd = document.getElementById('floatingAdd');
  const floatingMenu = document.getElementById('floatingMenu');
  const builderLoading = document.getElementById('builderLoading');

  let saveState = 'saved';
  let saveTimer = null;
  let activeContext = 'card';
  let activeSectionIndex = null;
  let activeItemIndex = null;
  let isInitializing = true;
  let isNewCard = false;
  let hasPendingChanges = false;
  let isApplied = true;

  if (!localStorage.getItem(LS_ADMIN_SESSION)) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ÙŠØ¬Ø¨ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ù„Ø¥Ø¯Ø§Ø±Ø© Ø£ÙˆÙ„Ù‹Ø§', 'warning');
    window.setTimeout(() => {
      window.location.href = '/admin.html';
    }, 800);
    return;
  }

  const cardId = new URLSearchParams(window.location.search).get('id');
  if (!cardId) {
    showToast('Ø®Ø·Ø£', 'ØªØ¹Ø°Ø± Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©', 'error');
    setLoading(builderLoading, false);
    document.body.classList.remove('is-loading');
    return;
  }

  setLoading(builderLoading, true, 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©...');
  await loadCards();
  activeCard = cards.find((card) => card.id === cardId);
  if (!activeCard) {
    const weekId = Number(cardId);
    if (Number.isFinite(weekId)) {
      activeCard = cards.find((card) => Number(card.week) === weekId);
      if (!activeCard) {
        activeCard = {
          id: `week-${weekId}`,
          week: weekId,
          title: '',
          prereq: null,
          className: '',
          sections: [],
          form: {
            sections: [],
            goals: [],
            prerequisites: [],
            assessment: { title: '', description: '' },
          },
        };
        isNewCard = true;
        cards.unshift(activeCard);
        persistCards();
      }
    }
  }

  if (!activeCard) {
    showToast('Ø®Ø·Ø£', 'Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©', 'error');
    setLoading(builderLoading, false);
    document.body.classList.remove('is-loading');
    return;
  }

  normalizeCard(activeCard);

  inputWeek.value = String(activeCard.week ?? '');
  inputClass.value = String(activeCard.className ?? '');
  inputSections.value = Array.isArray(activeCard.sections) ? activeCard.sections.join('ØŒ ') : '';
  inputTitle.value = String(activeCard.title ?? '');
  inputPrereq.value = activeCard.prereq == null ? '' : String(activeCard.prereq);
  inputAssessmentTitle.value = activeCard.form.assessment?.title || '';
  inputAssessmentDescription.value = activeCard.form.assessment?.description || '';

  document.body.classList.remove('is-loading');
  setLoading(builderLoading, false);

  renderGoals();
  renderPrereqs();
  renderSections(sectionsList);
  setSaveState(isNewCard ? 'dirty' : 'saved');
  if (isNewCard) {
    hasPendingChanges = true;
    isApplied = false;
  }
  isInitializing = false;
  updateSaveControls();

  inputWeek?.addEventListener('input', () => {
    if (!activeCard) return;
    const cleaned = normalizeDigits(inputWeek.value).replace(/[^0-9]/g, '');
    inputWeek.value = cleaned;
    activeCard.week = cleaned === '' ? null : Number(cleaned);
    persistCards();
  });

  inputClass?.addEventListener('input', () => {
    if (!activeCard) return;
    activeCard.className = inputClass.value.trim();
    persistCards();
  });

  inputSections?.addEventListener('input', () => {
    if (!activeCard) return;
    activeCard.sections = splitInlineList(inputSections.value);
    persistCards();
  });

  inputTitle?.addEventListener('input', () => {
    if (!activeCard) return;
    activeCard.title = inputTitle.value.trim();
    persistCards();
  });

  inputPrereq?.addEventListener('input', () => {
    if (!activeCard) return;
    const cleaned = normalizeDigits(inputPrereq.value).replace(/[^0-9]/g, '');
    inputPrereq.value = cleaned;
    activeCard.prereq = cleaned === '' ? null : Number(cleaned);
    persistCards();
  });

  inputAssessmentTitle?.addEventListener('input', () => {
    if (!activeCard) return;
    activeCard.form.assessment.title = inputAssessmentTitle.value.trim();
    persistCards();
  });

  inputAssessmentDescription?.addEventListener('input', () => {
    if (!activeCard) return;
    activeCard.form.assessment.description = inputAssessmentDescription.value.trim();
    persistCards();
  });

  goalsList?.addEventListener('input', (event) => handleGoalInput(event));
  goalsList?.addEventListener('click', (event) => handleGoalActions(event));
  prereqsList?.addEventListener('input', (event) => handlePrereqInput(event));
  prereqsList?.addEventListener('click', (event) => handlePrereqActions(event));
  btnAddGoal?.addEventListener('click', () => addGoal());
  btnAddPrereq?.addEventListener('click', () => addPrereq());

  floatingSave?.addEventListener('click', async () => {
    await manualSave();
  });

  toolbarSave?.addEventListener('click', async () => {
    await manualSave();
  });

  floatingApply?.addEventListener('click', () => {
    applyChanges();
  });

  floatingPreview?.addEventListener('click', () => {
    previewCard();
  });

  floatingAdd?.addEventListener('click', () => {
    toggleFloatingMenu();
  });

  document.addEventListener('click', (event) => {
    if (!floatingMenu || floatingMenu.classList.contains('hidden')) return;
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    if (target.closest('#floatingMenu') || target.closest('#floatingAdd')) return;
    hideFloatingMenu();
  });

  document.addEventListener('focusin', (event) => {
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    const contextEl = target.closest('[data-context]');
    if (contextEl) {
      activeContext = contextEl.getAttribute('data-context') || 'card';
    }
    const sectionIndex = target.closest('[data-section-index]')?.getAttribute('data-section-index');
    const itemIndex = target.closest('[data-item-index]')?.getAttribute('data-item-index');
    activeSectionIndex = sectionIndex != null ? Number(sectionIndex) : null;
    activeItemIndex = itemIndex != null ? Number(itemIndex) : null;
  });

  sectionsList?.addEventListener('input', (event) => handleInput(event, sectionsList));
  sectionsList?.addEventListener('change', (event) => handleChange(event, sectionsList));
  sectionsList?.addEventListener('click', (event) => handleClick(event, sectionsList));
  sectionsList?.addEventListener('dragstart', handleDragStart);
  sectionsList?.addEventListener('dragover', handleDragOver);
  sectionsList?.addEventListener('drop', handleDrop);
  sectionsList?.addEventListener('dragend', handleDragEnd);

  function handleInput(event, container) {
    const target = event.target;
    if (!(target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement)) return;
    const scope = target.dataset.scope;
    const sectionIndex = Number(target.dataset.sectionIndex);
    if (!Number.isFinite(sectionIndex)) return;
    const section = activeCard?.form.sections[sectionIndex];
    if (!section) return;

    if (scope === 'section') {
      const field = target.dataset.field;
      if (!field) return;
      section[field] = target.value.trim();
      persistCards();
      return;
    }

    const itemIndex = Number(target.dataset.itemIndex);
    if (!Number.isFinite(itemIndex)) return;
    const item = section.items[itemIndex];
    if (!item) return;

    const field = target.dataset.field;
    if (!field) return;

    if (item.type !== 'question') {
      if (field === 'text') {
        item.text = target.value.trim();
      } else if (field === 'url') {
        item.url = target.value.trim();
      } else if (field === 'details') {
        item.details = splitLines(target.value);
      }
      persistCards();
      return;
    }

    if (field === 'prompt' || field === 'description') {
      item[field] = target.value.trim();
    } else if (field === 'answer') {
      item.answer = target.value.trim();
    } else if (field === 'points') {
      item.points = target.value === '' ? 1 : Number(target.value);
    } else if (field === 'numeric-answer') {
      item.answer = target.value === '' ? null : Number(target.value);
    } else if (field === 'option') {
      const optionIndex = Number(target.dataset.optionIndex);
      if (!Number.isFinite(optionIndex)) return;
      item.options[optionIndex] = target.value.trim();
    } else if (field === 'pair-left' || field === 'pair-right') {
      const pairIndex = Number(target.dataset.pairIndex);
      if (!Number.isFinite(pairIndex)) return;
      const pair = item.pairs[pairIndex];
      if (!pair) return;
      if (field === 'pair-left') pair.left = target.value.trim();
      if (field === 'pair-right') pair.right = target.value.trim();
    } else if (field === 'order-item') {
      const listIndex = Number(target.dataset.listIndex);
      if (!Number.isFinite(listIndex)) return;
      item.items[listIndex] = target.value.trim();
    } else if (field === 'hint') {
      const hintIndex = Number(target.dataset.hintIndex);
      if (!Number.isFinite(hintIndex)) return;
      if (!Array.isArray(item.hints)) item.hints = [];
      item.hints[hintIndex] = target.value.trim();
    } else if (field === 'solution') {
      item.solution = target.value.trim();
    }

    persistCards();
  }

  function handleChange(event, container) {
    const target = event.target;
    if (!(target instanceof HTMLInputElement || target instanceof HTMLSelectElement)) return;
    const sectionIndex = Number(target.dataset.sectionIndex);
    if (!Number.isFinite(sectionIndex)) return;
    const section = activeCard?.form.sections[sectionIndex];
    if (!section) return;

    const field = target.dataset.field;
    if (!field) return;

    if (field === 'section-type') {
      section.sectionType = target.value;
      persistCards();
      return;
    }

    if (field === 'section-goal') {
      section.goalIndex = Number(target.value);
      persistCards();
      return;
    }

    const itemIndex = Number(target.dataset.itemIndex);
    if (!Number.isFinite(itemIndex)) return;
    const item = section.items[itemIndex];
    if (!item) return;

    if (field === 'question-type') {
      const nextType = target.value;
      section.items[itemIndex] = applyQuestionType(item, nextType);
      persistCards();
      renderSections(container);
      return;
    }

    if (field === 'required') {
      item.required = target.checked;
      persistCards();
      return;
    }

    if (field === 'correct-index') {
      const optionIndex = Number(target.dataset.optionIndex);
      if (!Number.isFinite(optionIndex)) return;
      item.correctIndex = optionIndex;
      persistCards();
    }

    if (field === 'true-false-answer') {
      item.answer = target.value;
      persistCards();
    }
  }

  function handleClick(event, container) {
    const target = event.target;
    if (!(target instanceof HTMLButtonElement)) return;
    const action = target.dataset.action;
    if (!action) return;

    const sectionIndex = Number(target.dataset.sectionIndex);
    if (!Number.isFinite(sectionIndex)) return;
    const section = activeCard?.form.sections[sectionIndex];
    if (!section) return;

    if (action === 'delete-section') {
      activeCard.form.sections.splice(sectionIndex, 1);
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'duplicate-section') {
      const cloned = cloneData(section);
      cloned.id = generateId('section');
      activeCard.form.sections.splice(sectionIndex + 1, 0, cloned);
      renderSections(container);
      persistCards();
      return;
    }

    const itemIndex = Number(target.dataset.itemIndex);
    if (!Number.isFinite(itemIndex)) return;
    const item = section.items[itemIndex];
    if (!item) return;

    if (action === 'delete-item') {
      section.items.splice(itemIndex, 1);
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'duplicate-item') {
      const cloned = cloneData(item);
      cloned.id = generateId(item.type === 'question' ? 'question' : 'item');
      section.items.splice(itemIndex + 1, 0, cloned);
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'toggle-item') {
      item.isCollapsed = !item.isCollapsed;
      renderSections(container);
      persistCards();
      return;
    }

    if (item.type !== 'question') return;

    if (action === 'add-option') {
      item.options.push('');
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'remove-option') {
      const optionIndex = Number(target.dataset.optionIndex);
      if (!Number.isFinite(optionIndex)) return;
      item.options.splice(optionIndex, 1);
      if (item.correctIndex >= item.options.length) {
        item.correctIndex = Math.max(0, item.options.length - 1);
      }
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'add-pair') {
      item.pairs.push({ left: '', right: '' });
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'remove-pair') {
      const pairIndex = Number(target.dataset.pairIndex);
      if (!Number.isFinite(pairIndex)) return;
      item.pairs.splice(pairIndex, 1);
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'add-order-item') {
      item.items.push('');
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'remove-order-item') {
      const listIndex = Number(target.dataset.listIndex);
      if (!Number.isFinite(listIndex)) return;
      item.items.splice(listIndex, 1);
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'add-hint') {
      if (!Array.isArray(item.hints)) item.hints = [];
      if (item.hints.length < 2) {
        item.hints.push('');
        renderSections(container);
        persistCards();
      }
      return;
    }

    if (action === 'add-solution') {
      item.solution = item.solution || '';
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'set-true') {
      item.answer = 'true';
      renderSections(container);
      persistCards();
      return;
    }

    if (action === 'set-false') {
      item.answer = 'false';
      renderSections(container);
      persistCards();
      return;
    }
  }
});

function renderGoals() {
  const list = document.getElementById('goalsList');
  if (!list || !activeCard) return;
  list.innerHTML = '';

  (activeCard.form.goals || []).forEach((goal, index) => {
    const el = document.createElement('div');
    el.className = 'builder-question';
    el.innerHTML = `
      <div class="builder-question-header">
        <div class="builder-question-meta">
          <div class="field">
            <label class="label">Ù‡Ø¯Ù ØªØ¹Ù„ÙŠÙ…ÙŠ</label>
            <input class="input" data-scope="goal" data-index="${index}" value="${escapeValue(goal)}" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ù‡Ø¯Ù Ù‡Ù†Ø§" />
          </div>
        </div>
        <div class="builder-card-actions">
          <button class="btn btn-ghost btn-sm" type="button" data-action="duplicate-goal" data-index="${index}">ØªÙƒØ±Ø§Ø±</button>
          <button class="btn btn-ghost btn-sm" type="button" data-action="delete-goal" data-index="${index}">Ø­Ø°Ù</button>
        </div>
      </div>
    `;
    list.appendChild(el);
  });
}

function renderPrereqs() {
  const list = document.getElementById('prereqsList');
  if (!list || !activeCard) return;
  list.innerHTML = '';

  (activeCard.form.prerequisites || []).forEach((prereq, index) => {
    const el = document.createElement('div');
    el.className = 'builder-question';
    el.innerHTML = `
      <div class="builder-question-header">
        <div class="builder-question-meta">
          <div class="field">
            <label class="label">Ù…ØªØ·Ù„Ø¨ Ø³Ø§Ø¨Ù‚</label>
            <input class="input" data-scope="prereq" data-index="${index}" value="${escapeValue(prereq)}" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ù…ØªØ·Ù„Ø¨ Ù‡Ù†Ø§" />
          </div>
        </div>
        <div class="builder-card-actions">
          <button class="btn btn-ghost btn-sm" type="button" data-action="duplicate-prereq" data-index="${index}">ØªÙƒØ±Ø§Ø±</button>
          <button class="btn btn-ghost btn-sm" type="button" data-action="delete-prereq" data-index="${index}">Ø­Ø°Ù</button>
        </div>
      </div>
    `;
    list.appendChild(el);
  });
}

function handleGoalInput(event) {
  const target = event.target;
  if (!(target instanceof HTMLInputElement)) return;
  const index = Number(target.dataset.index);
  if (!Number.isFinite(index) || !activeCard) return;
  activeCard.form.goals[index] = target.value.trim();
  persistCards();
  renderSections(document.getElementById('sectionsList'));
}

function handleGoalActions(event) {
  const target = event.target;
  if (!(target instanceof HTMLButtonElement)) return;
  const action = target.dataset.action;
  const index = Number(target.dataset.index);
  if (!Number.isFinite(index) || !activeCard) return;

  if (action === 'delete-goal') {
    activeCard.form.goals.splice(index, 1);
    renderGoals();
    renderSections(document.getElementById('sectionsList'));
    persistCards();
  }

  if (action === 'duplicate-goal') {
    const value = activeCard.form.goals[index] || '';
    activeCard.form.goals.splice(index + 1, 0, value);
    renderGoals();
    renderSections(document.getElementById('sectionsList'));
    persistCards();
  }
}

function handlePrereqInput(event) {
  const target = event.target;
  if (!(target instanceof HTMLInputElement)) return;
  const index = Number(target.dataset.index);
  if (!Number.isFinite(index) || !activeCard) return;
  activeCard.form.prerequisites[index] = target.value.trim();
  persistCards();
}

function handlePrereqActions(event) {
  const target = event.target;
  if (!(target instanceof HTMLButtonElement)) return;
  const action = target.dataset.action;
  const index = Number(target.dataset.index);
  if (!Number.isFinite(index) || !activeCard) return;

  if (action === 'delete-prereq') {
    activeCard.form.prerequisites.splice(index, 1);
    renderPrereqs();
    persistCards();
  }

  if (action === 'duplicate-prereq') {
    const value = activeCard.form.prerequisites[index] || '';
    activeCard.form.prerequisites.splice(index + 1, 0, value);
    renderPrereqs();
    persistCards();
  }
}

async function loadCards() {
  const stored = readLocalJson(LS_ADMIN_CARDS);
  if (stored && Array.isArray(stored)) {
    cards = stored;
    ensureCardsShape(cards);
  }

  try {
    showToast('Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„', 'Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª', 'info');
    const data = await fetchJson(CARDS_PATH, { noStore: true });
    const list = Array.isArray(data) ? data : data?.cards;
    if (Array.isArray(list)) {
      cards = list;
      ensureCardsShape(cards);
      persistCards();
    }
    showToast('ØªÙ… Ø§Ù„ØªØ­Ù…ÙŠÙ„', 'ØªÙ… ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø¨Ù†Ø¬Ø§Ø­', 'success');
  } catch (error) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ù…Ù† Ø§Ù„Ø®Ø§Ø¯Ù…', 'warning');
  }
}

function renderSections(container) {
  if (!container || !activeCard) return;
  container.innerHTML = '';

  activeCard.form.sections.forEach((section, sectionIndex) => {
    const sectionEl = document.createElement('div');
    sectionEl.className = 'builder-section';
    sectionEl.innerHTML = `
      <div class="builder-section-header">
        <div class="builder-question-meta">
          <div class="field">
            <label class="label">Ù†ÙˆØ¹ Ø§Ù„Ù‚Ø³Ù…</label>
            <select class="input" data-field="section-type" data-section-index="${sectionIndex}">
              ${SECTION_TYPES.map(
                (type) =>
                  `<option value="${type.value}" ${type.value === section.sectionType ? 'selected' : ''}>${type.label}</option>`,
              ).join('')}
            </select>
          </div>
          <div class="field">
            <label class="label">Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ù…Ø±ØªØ¨Ø·</label>
            <select class="input" data-field="section-goal" data-section-index="${sectionIndex}">
              ${(activeCard.form.goals || []).length
                ? activeCard.form.goals
                  .map((goal, goalIndex) => `
                    <option value="${goalIndex}" ${goalIndex === section.goalIndex ? 'selected' : ''}>
                      ${escapeValue(goal || `Ø§Ù„Ù‡Ø¯Ù ${goalIndex + 1}`)}
                    </option>
                  `)
                  .join('')
                : '<option value="0">Ø£Ø¶Ù Ù‡Ø¯ÙÙ‹Ø§ Ø£ÙˆÙ„Ù‹Ø§</option>'}
            </select>
          </div>
          <div class="field">
            <label class="label">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ù‚Ø³Ù…</label>
            <input class="input" data-scope="section" data-field="title" data-section-index="${sectionIndex}" value="${escapeValue(section.title)}" placeholder="Ù…Ø«Ø§Ù„: Ù…Ù‚Ø¯Ù…Ø©" />
          </div>
          <div class="field">
            <label class="label">ÙˆØµÙ Ø§Ù„Ù‚Ø³Ù…</label>
            <input class="input" data-scope="section" data-field="description" data-section-index="${sectionIndex}" value="${escapeValue(section.description)}" placeholder="Ù†Øµ Ø¥Ø±Ø´Ø§Ø¯ÙŠ Ù„Ù„Ù‚Ø³Ù…" />
          </div>
        </div>
        <div class="builder-card-actions">
          <button class="btn btn-ghost btn-sm" type="button" data-action="duplicate-section" data-section-index="${sectionIndex}">ØªÙƒØ±Ø§Ø±</button>
          <button class="btn btn-ghost btn-sm" type="button" data-action="delete-section" data-section-index="${sectionIndex}">Ø­Ø°Ù</button>
        </div>
      </div>
    `;

    const questionsWrap = document.createElement('div');
    questionsWrap.className = 'builder-sections';

    section.items.forEach((item, itemIndex) => {
      const itemEl = document.createElement('div');
      itemEl.className = `builder-question ${item.isCollapsed ? 'builder-collapsed' : ''}`;
      itemEl.innerHTML = `
        <div class="builder-question-header">
          <div class="builder-question-meta">
            ${item.type === 'question'
              ? `
            <div class="field">
              <label class="label">Ù†ÙˆØ¹ Ø§Ù„Ø³Ø¤Ø§Ù„</label>
              <select class="input" data-field="question-type" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">
                ${QUESTION_TYPES.map(
                  (type) =>
                    `<option value="${type.value}" ${type.value === item.questionType ? 'selected' : ''}>${type.label}</option>`,
                ).join('')}
              </select>
            </div>
            <div class="field">
              <label class="label">Ù†Øµ Ø§Ù„Ø³Ø¤Ø§Ù„</label>
              <input class="input" data-field="prompt" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" value="${escapeValue(item.prompt)}" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ø³Ø¤Ø§Ù„ Ù‡Ù†Ø§" />
            </div>
            <div class="field">
              <label class="label">ÙˆØµÙ Ø¥Ø¶Ø§ÙÙŠ</label>
              <input class="input" data-field="description" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" value="${escapeValue(item.description)}" placeholder="Ø´Ø±Ø­ Ø£Ùˆ ØªÙ„Ù…ÙŠØ­" />
            </div>
            <div class="field">
              <label class="label">Ù†Ù‚Ø§Ø· Ø§Ù„Ø³Ø¤Ø§Ù„</label>
              <input class="input ltr" type="number" min="1" data-field="points" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" value="${escapeValue(item.points ?? 1)}" />
            </div>
            <label class="row">
              <input type="checkbox" data-field="required" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" ${item.required ? 'checked' : ''} />
              <span class="small">Ø³Ø¤Ø§Ù„ Ù…Ø·Ù„ÙˆØ¨</span>
            </label>
            `
              : `
            <div class="field">
              <label class="label">Ù†ÙˆØ¹ Ø§Ù„Ø¹Ù†ØµØ±</label>
              <input class="input" value="${escapeValue(getItemLabel(item.type))}" disabled />
            </div>
            ${item.type === 'image' || item.type === 'video'
              ? `
            <div class="field">
              <label class="label">${item.type === 'image' ? 'Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø©' : 'Ø±Ø§Ø¨Ø· ÙŠÙˆØªÙŠÙˆØ¨'}</label>
              <input class="input ltr" data-field="url" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" value="${escapeValue(item.url ?? '')}" placeholder="${item.type === 'image' ? 'https://...' : 'https://youtube.com/...'}" />
            </div>
            `
              : `
            <div class="field">
              <label class="label">Ù†Øµ Ø§Ù„Ø¹Ù†ØµØ±</label>
              <textarea class="input" data-field="text" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ù†Øµ Ù‡Ù†Ø§">${escapeValue(item.text ?? '')}</textarea>
            </div>
            `}
            <div class="field">
              <label class="label">ØªÙØ§ØµÙŠÙ„ Ø¥Ø¶Ø§ÙÙŠØ©</label>
              <textarea class="input" rows="2" data-field="details" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" placeholder="ÙƒÙ„ ØªÙØµÙŠÙ„ ÙÙŠ Ø³Ø·Ø±">${escapeValue((item.details || []).join('\n'))}</textarea>
            </div>
            `}
          </div>
          <div class="builder-card-actions">
            <button class="btn btn-ghost btn-sm" type="button" data-action="toggle-item" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">
              ${item.isCollapsed ? 'ÙØªØ­' : 'Ø·ÙŠ'}
            </button>
            <button class="btn btn-ghost btn-sm" type="button" data-action="duplicate-item" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">ØªÙƒØ±Ø§Ø±</button>
            <button class="btn btn-ghost btn-sm" type="button" data-action="delete-item" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">Ø­Ø°Ù</button>
          </div>
        </div>
        ${item.type === 'question' ? renderQuestionBody(item, sectionIndex, itemIndex) : ''}
      `;

      questionsWrap.appendChild(itemEl);
    });

    sectionEl.appendChild(questionsWrap);
    container.appendChild(sectionEl);
  });
}

function renderQuestionBody(item, sectionIndex, itemIndex) {
  if (item.questionType === 'true-false') {
    return `
      <div class="field">
        <label class="label">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©</label>
        <div class="row" style="gap: 10px;">
          <button class="btn ${item.answer === 'true' ? 'btn-primary' : 'btn-outline'}" type="button" data-action="set-true" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">âœ…</button>
          <button class="btn ${item.answer === 'false' ? 'btn-primary' : 'btn-outline'}" type="button" data-action="set-false" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">âŒ</button>
        </div>
      </div>
      ${renderHintsSection(item, sectionIndex, itemIndex)}
    `;
  }

  if (item.questionType === 'number') {
    return `
      <div class="field">
        <label class="label">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø±Ù‚Ù…ÙŠØ©</label>
        <input class="input ltr" type="number" data-field="numeric-answer" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" value="${escapeValue(item.answer ?? '')}" />
      </div>
      ${renderHintsSection(item, sectionIndex, itemIndex)}
    `;
  }

  if (item.questionType === 'mcq') {
    return `
      <div class="builder-question-options">
        <div class="builder-helper">Ø­Ø¯Ø¯ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù…Ù† Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª.</div>
        ${item.options
          .map(
            (option, optionIndex) => `
              <div class="builder-option">
                <input class="input" data-field="option" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-option-index="${optionIndex}" value="${escapeValue(option)}" placeholder="Ø®ÙŠØ§Ø± ${optionIndex + 1}" />
                <div class="builder-option-controls">
                  <label class="row">
                    <input type="radio" name="mcq-correct-${sectionIndex}-${itemIndex}" data-field="correct-index" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-option-index="${optionIndex}" ${item.correctIndex === optionIndex ? 'checked' : ''} />
                    <span class="small">ØµØ­ÙŠØ­</span>
                  </label>
                  <button class="btn btn-ghost btn-sm" type="button" data-action="remove-option" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-option-index="${optionIndex}">Ø­Ø°Ù</button>
                </div>
              </div>
            `,
          )
          .join('')}
        <button class="btn btn-ghost btn-sm" type="button" data-action="add-option" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">Ø¥Ø¶Ø§ÙØ© Ø®ÙŠØ§Ø±</button>
      </div>
      ${renderHintsSection(item, sectionIndex, itemIndex)}
    `;
  }

  if (item.questionType === 'matching') {
    return `
      <div class="builder-pairs">
        ${item.pairs
          .map(
            (pair, pairIndex) => `
              <div class="builder-pair">
                <input class="input" data-field="pair-left" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-pair-index="${pairIndex}" value="${escapeValue(pair.left)}" placeholder="Ø¹Ù†ØµØ±" />
                <input class="input" data-field="pair-right" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-pair-index="${pairIndex}" value="${escapeValue(pair.right)}" placeholder="Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø©" />
                <button class="btn btn-ghost btn-sm" type="button" data-action="remove-pair" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-pair-index="${pairIndex}">Ø­Ø°Ù</button>
              </div>
            `,
          )
          .join('')}
        <button class="btn btn-ghost btn-sm" type="button" data-action="add-pair" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">Ø¥Ø¶Ø§ÙØ© ØªÙˆØµÙŠÙ„</button>
      </div>
      ${renderHintsSection(item, sectionIndex, itemIndex)}
    `;
  }

  if (item.questionType === 'ordering') {
    return `
      <div class="builder-order">
        <div class="builder-helper">Ø§Ø³Ø­Ø¨ Ø§Ù„Ø¹Ù†Ø§ØµØ± Ù„Ø¥Ø¹Ø§Ø¯Ø© ØªØ±ØªÙŠØ¨Ù‡Ø§.</div>
        ${item.items
          .map(
            (orderItem, listIndex) => `
              <div class="builder-order-item" draggable="true" data-drag-type="ordering" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-list-index="${listIndex}">
                <span class="drag-handle" aria-hidden="true">â‹®â‹®</span>
                <input class="input" data-field="order-item" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-list-index="${listIndex}" value="${escapeValue(orderItem)}" placeholder="Ø¹Ù†ØµØ± ${listIndex + 1}" />
                <button class="btn btn-ghost btn-sm" type="button" data-action="remove-order-item" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-list-index="${listIndex}">Ø­Ø°Ù</button>
              </div>
            `,
          )
          .join('')}
        <button class="btn btn-ghost btn-sm" type="button" data-action="add-order-item" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">Ø¥Ø¶Ø§ÙØ© Ø¹Ù†ØµØ± ØªØ±ØªÙŠØ¨</button>
      </div>
      ${renderHintsSection(item, sectionIndex, itemIndex)}
    `;
  }

  if (item.questionType === 'long-text') {
    return `
      <div class="field">
        <label class="label">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
        <textarea class="input" data-field="answer" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" placeholder="Ù†Øµ Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ø·ÙˆÙŠÙ„Ø©">${escapeValue(item.answer ?? '')}</textarea>
      </div>
      ${renderHintsSection(item, sectionIndex, itemIndex)}
    `;
  }

  return `
    <div class="field">
      <label class="label">Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
      <input class="input" data-field="answer" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" value="${escapeValue(item.answer ?? '')}" placeholder="Ø¥Ø¬Ø§Ø¨Ø© Ù‚ØµÙŠØ±Ø©" />
    </div>
    ${renderHintsSection(item, sectionIndex, itemIndex)}
  `;
}

function renderHintsSection(item, sectionIndex, itemIndex) {
  const hints = Array.isArray(item.hints) ? item.hints : [];
  const hintOne = hints[0] ?? '';
  const hintTwo = hints[1] ?? '';
  const hasHintOne = hintOne !== '';
  const hasHintTwo = hintTwo !== '';
  const hasSolution = item.solution !== undefined;

  return `
    <div class="builder-helper">Ø§Ù„ØªÙ„Ù…ÙŠØ­Ø§Øª ÙˆØ§Ù„Ø­Ù„</div>
    ${hasHintOne || hints.length ? `
      <div class="field">
        <label class="label">ØªÙ„Ù…ÙŠØ­ Ø£ÙˆÙ„</label>
        <textarea class="input" rows="2" data-field="hint" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-hint-index="0" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„ØªÙ„Ù…ÙŠØ­ Ø§Ù„Ø£ÙˆÙ„">${escapeValue(hintOne)}</textarea>
      </div>
    ` : ''}
    ${hasHintTwo || hints.length > 1 ? `
      <div class="field">
        <label class="label">ØªÙ„Ù…ÙŠØ­ Ø«Ø§Ù†ÙŠ</label>
        <textarea class="input" rows="2" data-field="hint" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" data-hint-index="1" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„ØªÙ„Ù…ÙŠØ­ Ø§Ù„Ø«Ø§Ù†ÙŠ">${escapeValue(hintTwo)}</textarea>
      </div>
    ` : ''}
    ${hasSolution ? `
      <div class="field">
        <label class="label">Ø­Ù„ Ù†Ù…ÙˆØ°Ø¬ÙŠ (ØªÙ„Ù…ÙŠØ­ Ø«Ø§Ù„Ø«)</label>
        <textarea class="input" rows="2" data-field="solution" data-section-index="${sectionIndex}" data-item-index="${itemIndex}" placeholder="Ø§ÙƒØªØ¨ Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ">${escapeValue(item.solution ?? '')}</textarea>
      </div>
    ` : ''}
    <div class="row" style="gap: 10px; margin-top: 8px;">
      ${!hasHintOne ? `<button class="btn btn-ghost btn-sm" type="button" data-action="add-hint" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">Ø¥Ø¶Ø§ÙØ© ØªÙ„Ù…ÙŠØ­ Ø£ÙˆÙ„</button>` : ''}
      ${hasHintOne && !hasHintTwo ? `<button class="btn btn-ghost btn-sm" type="button" data-action="add-hint" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">Ø¥Ø¶Ø§ÙØ© ØªÙ„Ù…ÙŠØ­ Ø«Ø§Ù†ÙŠ</button>` : ''}
      ${!hasSolution ? `<button class="btn btn-ghost btn-sm" type="button" data-action="add-solution" data-section-index="${sectionIndex}" data-item-index="${itemIndex}">Ø¥Ø¶Ø§ÙØ© Ø­Ù„ Ù†Ù…ÙˆØ°Ø¬ÙŠ</button>` : ''}
    </div>
  `;
}

function handleDragStart(event) {
  const target = event.target;
  if (!(target instanceof HTMLElement)) return;
  if (target.dataset.dragType !== 'ordering') return;
  const sectionIndex = Number(target.dataset.sectionIndex);
  const itemIndex = Number(target.dataset.itemIndex);
  const listIndex = Number(target.dataset.listIndex);
  if (!Number.isFinite(sectionIndex) || !Number.isFinite(itemIndex) || !Number.isFinite(listIndex)) return;
  dragState = { sectionIndex, itemIndex, listIndex };
  target.classList.add('is-dragging');
}

function handleDragOver(event) {
  if (!dragState) return;
  event.preventDefault();
}

function handleDrop(event) {
  const target = event.target;
  if (!(target instanceof HTMLElement)) return;
  if (!dragState) return;
  const dropTarget = target.closest('[data-drag-type="ordering"]');
  if (!(dropTarget instanceof HTMLElement)) return;

  const sectionIndex = Number(dropTarget.dataset.sectionIndex);
  const itemIndex = Number(dropTarget.dataset.itemIndex);
  const listIndex = Number(dropTarget.dataset.listIndex);

  if (!Number.isFinite(sectionIndex) || !Number.isFinite(itemIndex) || !Number.isFinite(listIndex)) return;
  if (!activeCard) return;

  const item = activeCard.form.sections[sectionIndex]?.items[itemIndex];
  if (!item || !Array.isArray(item.items)) return;

  const [moved] = item.items.splice(dragState.listIndex, 1);
  item.items.splice(listIndex, 0, moved);
  dragState = null;
  persistCards();
  renderSections(document.getElementById('sectionsList'));
}

function handleDragEnd(event) {
  const target = event.target;
  if (target instanceof HTMLElement) {
    target.classList.remove('is-dragging');
  }
  dragState = null;
}

function ensureCardsShape(cardsList) {
  cardsList.forEach((card) => normalizeCard(card));
}

function normalizeCard(card) {
  if (!card.id) {
    card.id = card.week != null ? `week-${card.week}` : generateId('card');
  }
  card.className = card.className || '';
  card.sections = Array.isArray(card.sections) ? card.sections : [];
  if (!card.form || typeof card.form !== 'object') {
    card.form = {
      sections: [],
      goals: [],
      prerequisites: [],
      assessment: { title: '', description: '' },
    };
  }
  if (!Array.isArray(card.form.sections)) card.form.sections = [];
  if (!Array.isArray(card.form.goals)) card.form.goals = [];
  if (!Array.isArray(card.form.prerequisites)) card.form.prerequisites = [];
  if (!card.form.assessment || typeof card.form.assessment !== 'object') {
    card.form.assessment = { title: '', description: '' };
  }

  card.form.sections.forEach((section) => normalizeSection(section));
}

function normalizeSection(section) {
  if (!section.id) section.id = generateId('section');
  if (!section.title) section.title = 'Ù‚Ø³Ù… Ø¬Ø¯ÙŠØ¯';
  if (!section.description) section.description = '';
  section.sectionType = section.sectionType || 'goal';
  section.goalIndex = Number.isFinite(section.goalIndex) ? section.goalIndex : 0;
  if (!Array.isArray(section.items)) {
    const legacyQuestions = Array.isArray(section.questions) ? section.questions : [];
    section.items = legacyQuestions.map((question) => ({
      ...applyQuestionType(question, question.type || question.questionType || 'short-text'),
      type: 'question',
      questionType: question.type || question.questionType || 'short-text',
    }));
    delete section.questions;
  }
  section.items.forEach((item) => applyItemDefaults(item));
}

function createSection() {
  return {
    id: generateId('section'),
    title: 'Ù‚Ø³Ù… Ø¬Ø¯ÙŠØ¯',
    description: '',
    sectionType: 'goal',
    goalIndex: 0,
    items: [],
  };
}

function createItem(type) {
  if (type === 'question') {
    return createQuestionItem('mcq');
  }

  return {
    id: generateId('item'),
    type,
    text: '',
    url: type === 'image' || type === 'video' ? '' : undefined,
    details: [],
  };
}

function createQuestionItem(questionType) {
  return applyQuestionType(
    {
      id: generateId('question'),
      type: 'question',
      questionType,
      prompt: 'Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯',
      description: '',
      required: false,
      points: 1,
    },
    questionType,
  );
}

function applyQuestionType(question, questionType) {
  const base = {
    id: question.id || generateId('question'),
    type: 'question',
    questionType,
    prompt: question.prompt || 'Ø³Ø¤Ø§Ù„ Ø¬Ø¯ÙŠØ¯',
    description: question.description || '',
    required: question.required ?? false,
    hints: Array.isArray(question.hints) ? question.hints : [],
    solution: question.solution,
    points: Number.isFinite(question.points) ? Number(question.points) : 1,
  };

  if (questionType === 'true-false') {
    return {
      ...base,
      answer: question.answer ?? 'true',
    };
  }

  if (questionType === 'number') {
    return {
      ...base,
      answer: Number.isFinite(question.answer) ? question.answer : null,
    };
  }

  if (questionType === 'mcq') {
    const options = Array.isArray(question.options) && question.options.length ? question.options : [''];
    return {
      ...base,
      options,
      correctIndex: Number.isFinite(question.correctIndex) ? question.correctIndex : 0,
    };
  }

  if (questionType === 'matching') {
    return {
      ...base,
      pairs: Array.isArray(question.pairs) && question.pairs.length ? question.pairs : [{ left: '', right: '' }],
    };
  }

  if (questionType === 'ordering') {
    return {
      ...base,
      items: Array.isArray(question.items) && question.items.length ? question.items : [''],
    };
  }

  return {
    ...base,
    answer: question.answer ?? '',
  };
}

function applyItemDefaults(item) {
  if (item.type === 'question') {
    const normalized = applyQuestionType(item, item.questionType || 'short-text');
    Object.assign(item, normalized);
    return;
  }

  item.id = item.id || generateId('item');
  item.type = item.type || 'note';
  item.text = item.text ?? '';
  if (item.type === 'image' || item.type === 'video') {
    item.url = item.url ?? '';
  }
  item.details = Array.isArray(item.details) ? item.details : [];
}

function persistCards() {
  try {
    localStorage.setItem(LS_ADMIN_CARDS, JSON.stringify(cards));
  } catch {
    showToast('Ø®Ø·Ø£', 'ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­', 'error');
  }
  if (!isInitializing) {
    markDirty();
  }
}

function markDirty() {
  if (!activeCard) return;
  hasPendingChanges = true;
  isApplied = false;
  setSaveState('dirty');
  updateSaveControls();
}

function scheduleAutoSave() {
  if (saveTimer) window.clearTimeout(saveTimer);
  saveTimer = window.setTimeout(async () => {
    await autoSave();
  }, 1500);
}

async function autoSave() {
  if (saveState === 'saving') return;
  if (!activeCard?.week || !String(activeCard.title || '').trim()) {
    return;
  }
  try {
    if (Date.now() - lastAutoSaveAttempt > AUTO_SAVE_TOAST_WINDOW) {
      showToast('Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸', 'ÙŠØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§', 'info');
      lastAutoSaveAttempt = Date.now();
    }
    setSaveState('saving');
    await saveWeekToApi(activeCard);
    updateCardsCache(activeCard);
    setSaveState('saved');
    if (Date.now() - lastAutoSaveResult > AUTO_SAVE_TOAST_WINDOW) {
      showToast('ØªÙ… Ø§Ù„Ø­ÙØ¸', 'ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§', 'success');
      lastAutoSaveResult = Date.now();
    }
  } catch (error) {
    setSaveState('dirty');
    showToast('Ø®Ø·Ø£', error.message || 'ØªØ¹Ø°Ø± Ø­ÙØ¸ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§', 'error');
  }
}

async function manualSave() {
  if (!activeCard) return;
  if (!isApplied) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¶ØºØ· Ø¹Ù„Ù‰ ØªØ·Ø¨ÙŠÙ‚ Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸', 'warning');
    return;
  }
  if (!hasPendingChanges) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø­ÙØ¸', 'info');
    return;
  }
  if (!activeCard.week || !String(activeCard.title || '').trim()) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ÙˆØ¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸', 'warning');
    return;
  }
  try {
    showToast('Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸', 'Ø¬Ø§Ø±ÙŠ Ø­ÙØ¸ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©', 'info');
    setSaveState('saving');
    await saveWeekToApi(activeCard);
    updateCardsCache(activeCard);
    setSaveState('saved');
    hasPendingChanges = false;
    isApplied = true;
    updateSaveControls();
    showToast('ØªÙ… Ø§Ù„Ø­ÙØ¸', 'ØªÙ… Ø­ÙØ¸ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­', 'success');
  } catch (error) {
    setSaveState('dirty');
    showToast('Ø®Ø·Ø£', error.message || 'ØªØ¹Ø°Ø± Ø­ÙØ¸ Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©', 'error');
  }
}

function setSaveState(state) {
  saveState = state;
  const floatingSave = document.getElementById('floatingSave');
  if (!floatingSave) return;
  floatingSave.classList.remove('is-dirty', 'is-saving');

  if (state === 'saving') {
    floatingSave.classList.add('is-saving');
    floatingSave.textContent = 'Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸... â³';
    return;
  }

  if (state === 'dirty') {
    floatingSave.classList.add('is-dirty');
  }

  updateSaveControls();
}

function toggleFloatingMenu() {
  const menu = document.getElementById('floatingMenu');
  if (!menu) return;
  if (!menu.classList.contains('hidden')) {
    hideFloatingMenu();
    return;
  }
  renderFloatingMenu();
  menu.classList.remove('hidden');
  menu.removeAttribute('hidden');
}

function hideFloatingMenu() {
  const menu = document.getElementById('floatingMenu');
  if (!menu) return;
  menu.classList.add('hidden');
  menu.setAttribute('hidden', 'hidden');
}

function applyChanges() {
  if (!hasPendingChanges) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ ØªØºÙŠÙŠØ±Ø§Øª Ù„ØªØ·Ø¨ÙŠÙ‚Ù‡Ø§', 'info');
    return;
  }
  isApplied = true;
  updateSaveControls();
  showToast('ØªÙ… Ø§Ù„ØªØ·Ø¨ÙŠÙ‚', 'Ø£ØµØ¨Ø­ Ø¨Ø¥Ù…ÙƒØ§Ù†Ùƒ Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª Ø§Ù„Ø¢Ù†', 'success');
}

function previewCard() {
  if (!activeCard?.week) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù‚Ø¨Ù„ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©', 'warning');
    return;
  }
  window.open(`/lesson.html?week=${encodeURIComponent(activeCard.week)}`, '_blank');
}

function updateSaveControls() {
  const floatingSave = document.getElementById('floatingSave');
  const floatingApply = document.getElementById('floatingApply');
  const toolbarSave = document.getElementById('toolbarSave');

  const canSave = Boolean(isApplied && hasPendingChanges);
  const disableSave = saveState === 'saving' || !canSave;
  const disableApply = !hasPendingChanges || saveState === 'saving';

  if (floatingSave) {
    floatingSave.toggleAttribute('aria-disabled', disableSave);
    floatingSave.classList.toggle('is-disabled', disableSave);
    if (saveState === 'saving') {
      floatingSave.textContent = 'Ø¬Ø§Ø±Ù Ø§Ù„Ø­ÙØ¸... â³';
    } else if (!hasPendingChanges) {
      floatingSave.textContent = 'ØªÙ… Ø§Ù„Ø­ÙØ¸ âœ“';
    } else if (!isApplied) {
      floatingSave.textContent = 'Ø§Ø¶ØºØ· ØªØ·Ø¨ÙŠÙ‚ Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸';
    } else {
      floatingSave.textContent = 'Ø¬Ø§Ù‡Ø² Ù„Ù„Ø­ÙØ¸ âœ“';
    }
  }

  if (floatingApply) {
    floatingApply.toggleAttribute('aria-disabled', disableApply);
    floatingApply.classList.toggle('is-disabled', disableApply);
  }

  if (toolbarSave) {
    toolbarSave.toggleAttribute('aria-disabled', disableSave);
    toolbarSave.classList.toggle('is-disabled', disableSave);
  }
}

function renderFloatingMenu() {
  const menu = document.getElementById('floatingMenu');
  if (!menu) return;
  const context = activeContext || 'card';

  const items = [];
  if (context === 'card') {
    items.push(
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù‚Ø³Ù… (Ù‡Ø¯Ù)', action: () => addSection('goal') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù‚Ø³Ù… (Ù…ØªØ·Ù„Ø¨ Ø³Ø§Ø¨Ù‚)', action: () => addSection('prereq') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù‚Ø³Ù… (Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©)', action: () => addSection('goals') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù‚Ø³Ù… (Ø§Ø®ØªØ¨Ø± Ù†ÙØ³ÙŠ)', action: () => addSection('assessment') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù‡Ø¯Ù ØªØ¹Ù„ÙŠÙ…ÙŠ', action: () => addGoal() },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù…ØªØ·Ù„Ø¨ Ø³Ø§Ø¨Ù‚', action: () => addPrereq() },
    );
  }

  if (context === 'goals') {
    items.push({ label: 'Ø¥Ø¶Ø§ÙØ© Ù‡Ø¯Ù ØªØ¹Ù„ÙŠÙ…ÙŠ', action: () => addGoal() });
  }

  if (context === 'prereqs') {
    items.push({ label: 'Ø¥Ø¶Ø§ÙØ© Ù…ØªØ·Ù„Ø¨ Ø³Ø§Ø¨Ù‚', action: () => addPrereq() });
  }

  if (context === 'concepts') {
    items.push(
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù…ÙÙ‡ÙˆÙ…', action: () => addItemToSection('note') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù…Ø«Ø§Ù„', action: () => addItemToSection('example') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ù„Ø§ Ù…Ø«Ø§Ù„', action: () => addItemToSection('non-example') },
      { label: 'Ø¥Ø¶Ø§ÙØ© ØªÙˆØ¶ÙŠØ­', action: () => addItemToSection('explain') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„ (Ø§Ø®ØªÙŠØ§Ø± Ù…Ù† Ù…ØªØ¹Ø¯Ø¯)', action: () => addQuestionToSection('mcq') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„ (ØµØ­/Ø®Ø·Ø£)', action: () => addQuestionToSection('true-false') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„ (Ø¥Ø¯Ø®Ø§Ù„ Ù†Øµ)', action: () => addQuestionToSection('short-text') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„ (ØªÙˆØµÙŠÙ„)', action: () => addQuestionToSection('matching') },
      { label: 'Ø¥Ø¶Ø§ÙØ© Ø³Ø¤Ø§Ù„ (ØªØ±ØªÙŠØ¨)', action: () => addQuestionToSection('ordering') },
      { label: 'Ø¥Ø¶Ø§ÙØ© ØµÙˆØ±Ø©', action: () => addItemToSection('image') },
      { label: 'Ø¥Ø¶Ø§ÙØ© ÙÙŠØ¯ÙŠÙˆ ÙŠÙˆØªÙŠÙˆØ¨', action: () => addItemToSection('video') },
    );
  }

  menu.innerHTML = items
    .map((item, index) => `<button type="button" data-menu-index="${index}">${item.label}</button>`)
    .join('');

  menu.querySelectorAll('button').forEach((btn) => {
    btn.addEventListener('click', () => {
      const index = Number(btn.dataset.menuIndex);
      const action = items[index]?.action;
      if (action) action();
      hideFloatingMenu();
    });
  });
}

function addSection(sectionType = 'goal') {
  if (!activeCard) return;
  const nextSection = createSection();
  nextSection.sectionType = sectionType;
  activeCard.form.sections.push(nextSection);
  renderSections(document.getElementById('sectionsList'));
  persistCards();
  focusLastSectionTitle();
}

function addGoal() {
  if (!activeCard) return;
  activeCard.form.goals.push('');
  renderGoals();
  persistCards();
  focusLastGoal();
}

function addPrereq() {
  if (!activeCard) return;
  activeCard.form.prerequisites.push('');
  renderPrereqs();
  persistCards();
  focusLastPrereq();
}

function addItemToSection(type) {
  if (!activeCard) return;
  const index = Number.isFinite(activeSectionIndex) ? activeSectionIndex : 0;
  if (!activeCard.form.sections[index]) {
    activeCard.form.sections.push(createSection());
  }
  activeCard.form.sections[index].items.push(createItem(type));
  renderSections(document.getElementById('sectionsList'));
  persistCards();
  focusLastItem(index);
}

function addQuestionToSection(questionType) {
  if (!activeCard) return;
  const index = Number.isFinite(activeSectionIndex) ? activeSectionIndex : 0;
  if (!activeCard.form.sections[index]) {
    activeCard.form.sections.push(createSection());
  }
  activeCard.form.sections[index].items.push(createQuestionItem(questionType));
  renderSections(document.getElementById('sectionsList'));
  persistCards();
  focusLastItem(index);
}

function focusLastSectionTitle() {
  const inputs = document.querySelectorAll('[data-scope="section"][data-field="title"]');
  const input = inputs[inputs.length - 1];
  if (input instanceof HTMLInputElement) input.focus();
}

function focusLastItem(sectionIndex) {
  const items = document.querySelectorAll(`[data-section-index="${sectionIndex}"][data-item-index]`);
  const input = items[items.length - 1];
  if (input instanceof HTMLElement) input.focus();
}

function focusLastGoal() {
  const inputs = document.querySelectorAll('[data-scope="goal"]');
  const input = inputs[inputs.length - 1];
  if (input instanceof HTMLInputElement) input.focus();
}

function focusLastPrereq() {
  const inputs = document.querySelectorAll('[data-scope="prereq"]');
  const input = inputs[inputs.length - 1];
  if (input instanceof HTMLInputElement) input.focus();
}

function cloneData(value) {
  try {
    return JSON.parse(JSON.stringify(value));
  } catch {
    return value;
  }
}

async function saveWeekToApi(card) {
  if (!card?.week) {
    throw new Error('Ø±Ù‚Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù…Ø·Ù„ÙˆØ¨ Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸');
  }

  const payload = buildWeekPayload(card);
  await fetchJson(`/api/weeks/${encodeURIComponent(card.week)}`, {
    method: 'PUT',
    body: payload,
  });
}

function buildWeekPayload(card) {
  const goals = Array.isArray(card.form.goals) ? card.form.goals : [];
  const prerequisites = Array.isArray(card.form.prerequisites)
    ? card.form.prerequisites
    : [];

  const sections = Array.isArray(card.form.sections) ? card.form.sections : [];
  const assessmentSections = sections.filter((section) => section.sectionType === 'assessment');
  const conceptSections = sections.filter((section) => section.sectionType !== 'assessment');

  const concepts = conceptSections.map((section) => ({
    title: section.title || 'Ù‚Ø³Ù…',
    flow: section.items.map((item) => mapItemToFlow(item)),
    sectionType: section.sectionType || 'goal',
    goalIndex: Number.isFinite(section.goalIndex) ? section.goalIndex : 0,
  }));

  const assessmentSource = assessmentSections.length ? assessmentSections : sections;
  const assessmentQuestions = assessmentSource.flatMap((section) =>
    section.items
      .filter((item) => item.type === 'question')
      .map((item) => mapQuestionToAssessment(item)),
  );

  return {
    week: Number(card.week),
    title: String(card.title || '').trim(),
    prereq: card.prereq == null ? null : Number(card.prereq),
    className: String(card.className || ''),
    sections: Array.isArray(card.sections) ? card.sections : [],
    goals,
    prerequisites,
    concepts,
    assessment: {
      title: card.form.assessment?.title || `ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ${card.week}`,
      description: card.form.assessment?.description || '',
      questions: assessmentQuestions,
    },
  };
}

function mapItemToFlow(item) {
  if (item.type !== 'question') {
    const mapped = {
      type: item.type || 'note',
      text: item.text || '',
    };
    if (item.url) {
      mapped.url = item.url;
    }
    if (Array.isArray(item.details) && item.details.length) {
      mapped.details = item.details;
    }
    return mapped;
  }

  return mapQuestionToFlow(item);
}

function mapQuestionToFlow(question) {
  const base = {
    type: 'question',
    text: question.prompt || 'Ø³Ø¤Ø§Ù„',
    title: question.description || '',
  };

  if (question.questionType === 'mcq') {
    return {
      ...base,
      choices: Array.isArray(question.options) ? question.options : [],
      correctIndex: Number.isFinite(question.correctIndex) ? question.correctIndex : 0,
      ...(Array.isArray(question.hints) && question.hints.length ? { hints: question.hints } : {}),
      ...(question.solution ? { solution: question.solution } : {}),
    };
  }

  if (question.questionType === 'true-false') {
    return {
      ...base,
      choices: ['ØµÙˆØ§Ø¨', 'Ø®Ø·Ø£'],
      correctIndex: question.answer === 'false' ? 1 : 0,
      ...(Array.isArray(question.hints) && question.hints.length ? { hints: question.hints } : {}),
      ...(question.solution ? { solution: question.solution } : {}),
    };
  }

  if (question.questionType === 'number') {
    return {
      ...base,
      answer: question.answer == null ? '' : String(question.answer),
      ...(Array.isArray(question.hints) && question.hints.length ? { hints: question.hints } : {}),
      ...(question.solution ? { solution: question.solution } : {}),
    };
  }

  return {
    ...base,
    answer: question.answer ?? '',
    ...(Array.isArray(question.hints) && question.hints.length ? { hints: question.hints } : {}),
    ...(question.solution ? { solution: question.solution } : {}),
  };
}

function mapQuestionToAssessment(question) {
  if (question.questionType === 'mcq') {
    return {
      type: 'mcq',
      text: question.prompt || 'Ø³Ø¤Ø§Ù„',
      choices: Array.isArray(question.options) ? question.options : [],
      correctIndex: Number.isFinite(question.correctIndex) ? question.correctIndex : 0,
      points: Number.isFinite(question.points) ? Number(question.points) : 1,
    };
  }

  if (question.questionType === 'true-false') {
    return {
      type: 'mcq',
      text: question.prompt || 'Ø³Ø¤Ø§Ù„',
      choices: ['ØµÙˆØ§Ø¨', 'Ø®Ø·Ø£'],
      correctIndex: question.answer === 'false' ? 1 : 0,
      points: Number.isFinite(question.points) ? Number(question.points) : 1,
    };
  }

  return {
    type: 'input',
    text: question.prompt || 'Ø³Ø¤Ø§Ù„',
    answer: question.answer == null ? '' : String(question.answer),
    points: Number.isFinite(question.points) ? Number(question.points) : 1,
  };
}

function getItemLabel(type) {
  const found = ITEM_TYPES.find((item) => item.value === type);
  return found?.label || 'Ø¹Ù†ØµØ±';
}

function splitLines(value) {
  return String(value || '')
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean);
}

function splitInlineList(value) {
  return String(value || '')
    .split(/[,ØŒ]/)
    .map((entry) => entry.trim())
    .filter(Boolean);
}

function updateCardsCache(card) {
  const stored = readLocalJson(LS_ADMIN_CARDS);
  const list = Array.isArray(stored) ? stored : [];
  const index = list.findIndex((item) => String(item.id) === String(card.id));
  const normalized = {
    ...card,
    week: card.week,
    title: card.title,
    prereq: card.prereq,
    className: card.className,
    sections: Array.isArray(card.sections) ? card.sections : [],
  };

  if (index === -1) {
    list.unshift(normalized);
  } else {
    list[index] = normalized;
  }

  try {
    localStorage.setItem(LS_ADMIN_CARDS, JSON.stringify(list));
  } catch {}
}

async function saveWeekToApi(card) {
  if (!card?.week) {
    throw new Error('Ø±Ù‚Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ Ù…Ø·Ù„ÙˆØ¨ Ù‚Ø¨Ù„ Ø§Ù„Ø­ÙØ¸');
  }

  const payload = buildWeekPayload(card);
  await fetchJson(`/api/weeks/${encodeURIComponent(card.week)}`, {
    method: 'PUT',
    body: payload,
  });
}

function buildWeekPayload(card) {
  const goals = Array.isArray(card.form.goals) ? card.form.goals : [];
  const prerequisites = Array.isArray(card.form.prerequisites)
    ? card.form.prerequisites
    : [];

  const sections = Array.isArray(card.form.sections) ? card.form.sections : [];
  const assessmentSections = sections.filter((section) => section.sectionType === 'assessment');
  const conceptSections = sections.filter((section) => section.sectionType !== 'assessment');

  const concepts = conceptSections.map((section) => ({
    title: section.title || 'Ù‚Ø³Ù…',
    flow: section.items.map((item) => mapItemToFlow(item)),
    sectionType: section.sectionType || 'goal',
    goalIndex: Number.isFinite(section.goalIndex) ? section.goalIndex : 0,
  }));

  const assessmentSource = assessmentSections.length ? assessmentSections : sections;
  const assessmentQuestions = assessmentSource.flatMap((section) =>
    section.items
      .filter((item) => item.type === 'question')
      .map((item) => mapQuestionToAssessment(item)),
  );

  return {
    week: Number(card.week),
    title: String(card.title || '').trim(),
    prereq: card.prereq == null ? null : Number(card.prereq),
    className: String(card.className || ''),
    sections: Array.isArray(card.sections) ? card.sections : [],
    goals,
    prerequisites,
    concepts,
    assessment: {
      title: card.form.assessment?.title || `ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ${card.week}`,
      description: card.form.assessment?.description || '',
      questions: assessmentQuestions,
    },
  };
}

function mapItemToFlow(item) {
  if (item.type !== 'question') {
    const mapped = {
      type: item.type || 'note',
      text: item.text || '',
    };
    if (item.url) {
      mapped.url = item.url;
    }
    if (Array.isArray(item.details) && item.details.length) {
      mapped.details = item.details;
    }
    return mapped;
  }

  return mapQuestionToFlow(item);
}

function mapQuestionToFlow(question) {
  const base = {
    type: 'question',
    text: question.prompt || 'Ø³Ø¤Ø§Ù„',
    title: question.description || '',
  };

  if (question.questionType === 'mcq') {
    return {
      ...base,
      choices: Array.isArray(question.options) ? question.options : [],
      correctIndex: Number.isFinite(question.correctIndex) ? question.correctIndex : 0,
      ...(Array.isArray(question.hints) && question.hints.length ? { hints: question.hints } : {}),
      ...(question.solution ? { solution: question.solution } : {}),
    };
  }

  if (question.questionType === 'true-false') {
    return {
      ...base,
      choices: ['ØµÙˆØ§Ø¨', 'Ø®Ø·Ø£'],
      correctIndex: question.answer === 'false' ? 1 : 0,
      ...(Array.isArray(question.hints) && question.hints.length ? { hints: question.hints } : {}),
      ...(question.solution ? { solution: question.solution } : {}),
    };
  }

  if (question.questionType === 'number') {
    return {
      ...base,
      answer: question.answer == null ? '' : String(question.answer),
      ...(Array.isArray(question.hints) && question.hints.length ? { hints: question.hints } : {}),
      ...(question.solution ? { solution: question.solution } : {}),
    };
  }

  return {
    ...base,
    answer: question.answer ?? '',
    ...(Array.isArray(question.hints) && question.hints.length ? { hints: question.hints } : {}),
    ...(question.solution ? { solution: question.solution } : {}),
  };
}

function mapQuestionToAssessment(question) {
  if (question.questionType === 'mcq') {
    return {
      type: 'mcq',
      text: question.prompt || 'Ø³Ø¤Ø§Ù„',
      choices: Array.isArray(question.options) ? question.options : [],
      correctIndex: Number.isFinite(question.correctIndex) ? question.correctIndex : 0,
      points: Number.isFinite(question.points) ? Number(question.points) : 1,
    };
  }

  if (question.questionType === 'true-false') {
    return {
      type: 'mcq',
      text: question.prompt || 'Ø³Ø¤Ø§Ù„',
      choices: ['ØµÙˆØ§Ø¨', 'Ø®Ø·Ø£'],
      correctIndex: question.answer === 'false' ? 1 : 0,
      points: Number.isFinite(question.points) ? Number(question.points) : 1,
    };
  }

  return {
    type: 'input',
    text: question.prompt || 'Ø³Ø¤Ø§Ù„',
    answer: question.answer == null ? '' : String(question.answer),
    points: Number.isFinite(question.points) ? Number(question.points) : 1,
  };
}

function splitLines(value) {
  return String(value || '')
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean);
}

function updateCardsCache(card) {
  const stored = readLocalJson(LS_ADMIN_CARDS);
  const list = Array.isArray(stored) ? stored : [];
  const index = list.findIndex((item) => String(item.id) === String(card.id));
  const normalized = {
    ...card,
    week: card.week,
    title: card.title,
    prereq: card.prereq,
    className: card.className,
    sections: Array.isArray(card.sections) ? card.sections : [],
  };

  if (index === -1) {
    list.unshift(normalized);
  } else {
    list[index] = normalized;
  }

  try {
    localStorage.setItem(LS_ADMIN_CARDS, JSON.stringify(list));
  } catch {}
}

function readLocalJson(key) {
  try {
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

function setLoading(overlay, isVisible, message) {
  if (!overlay) return;
  overlay.classList.toggle('hidden', !isVisible);
  overlay.toggleAttribute('hidden', !isVisible);
  if (message) {
    const text = overlay.querySelector('span:last-child');
    if (text) text.textContent = message;
  }
}

function generateId(prefix) {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return `${prefix}-${crypto.randomUUID()}`;
  }
  return `${prefix}-${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

function escapeValue(value) {
  return String(value ?? '')
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;');
}

math/public/assets/js/cards/cardsPage.js
/* =========================================================
   cardsPage.js â€” Cards List Logic (index.html)
   - Loads cards from local data
   - Applies sequential locking via prereq
   - Shows completed cards as gold + star (base.css styles)
   - Shows student name (firstName/fullName) instead of "Ø·Ø§Ù„Ø¨ {id}"
   ========================================================= */

import { fetchJson } from '../core/api.js';
import { API_PATHS } from '../core/constants.js';
import { getWeeksForClass } from '../core/gradeMap.js';
import {
  getCachedCards,
  getLastStudentId,
  getStudentCompletions,
  getStudentSession,
  isCardDone,
  setCachedCards,
  syncCardCompletions,
} from '../core/storage.js';
import { goToLesson } from '../core/router.js';
import { showToast } from '../ui/toast.js';

export async function initCardsPage() {
  const studentId = getLastStudentId();
  if (!studentId) return;

  const listEl = document.getElementById('cardsList');
  const studentNameEl = document.getElementById('cardsStudentName');

  const student = getStudentSession();
  const displayName =
    (student?.firstName && String(student.firstName).trim()) ||
    (student?.fullName && String(student.fullName).trim()) ||
    `Ø·Ø§Ù„Ø¨ ${studentId}`;

  if (studentNameEl) studentNameEl.textContent = displayName;

  try {
    const cached = getCachedCards();
    if (cached?.length) {
      renderCards(listEl, filterCardsForStudent(cached, student), studentId);
    }

    const progress = getStudentCompletions(studentId);
    syncCardCompletions(studentId, progress);

    const cards = await fetchJson(API_PATHS.CARDS, { noStore: true });
    const normalized = Array.isArray(cards) ? cards : [];
    setCachedCards(normalized);
    renderCards(listEl, filterCardsForStudent(normalized, student), studentId);
  } catch (e) {
    showToast('Ø®Ø·Ø£', 'ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª', 'error');
    console.error(e);
  }
}

function filterCardsForStudent(cards, student) {
  const weeks = getWeeksForClass(student?.class);
  if (!weeks?.length) return cards;
  const allowed = new Set(weeks.map((week) => Number(week)));
  return cards.filter((card) => allowed.has(Number(card.week)));
}

function renderCards(container, cards, studentId) {
  if (!container) return;
  container.innerHTML = '';

  cards.forEach((card) => {
    const done = isCardDone(studentId, card.week);
    const prereqDone = !card.prereq || isCardDone(studentId, card.prereq);
    const locked = !prereqDone;

    const cardEl = document.createElement('div');
    cardEl.className = `card ${locked ? 'is-locked' : ''} ${done ? 'is-done' : ''}`;

    cardEl.innerHTML = `
      <div class="card-header">
        <div>
          <h3 class="card-title">${escapeHtml(card.title)}</h3>
          <p class="card-subtitle">Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ${card.week}</p>
        </div>
        ${done ? starHtml() : ''}
      </div>

      <div class="card-body">
        <span class="badge ${done ? 'done' : locked ? 'locked' : 'primary'}">
          ${done ? 'Ù…Ù†Ø¬Ø²Ø©' : locked ? 'Ù…Ù‚ÙÙ„Ø©' : 'Ù…ÙØªÙˆØ­Ø©'}
        </span>
      </div>

      <div class="card-footer">
        <button class="btn ${locked ? 'btn-outline' : 'btn-primary'} w-100"
                ${locked ? 'disabled' : ''}>
          ${done ? 'Ø¥Ø¹Ø§Ø¯Ø© ÙØªØ­' : 'Ø§Ø¨Ø¯Ø£'}
        </button>
      </div>
    `;

    const btn = cardEl.querySelector('button');
    if (!locked) {
      btn.addEventListener('click', () => {
        goToLesson(card.week);
      });
    } else {
      btn.addEventListener('click', () => {
        showToast('Ù…Ù‚ÙÙ„Ø© ğŸ”’', 'Ù„Ø§Ø²Ù… ØªÙ†Ù‡ÙŠ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø£ÙˆÙ„Ù‹Ø§', 'warning');
      });
    }

    container.appendChild(cardEl);
  });
}

function starHtml() {
  return `
    <div class="star" title="Ù…Ù†Ø¬Ø²Ø©">
      <svg viewBox="0 0 24 24">
        <path d="M12 2l2.9 6.6 7.1.6-5.4 4.7 1.6 7-6.2-3.6-6.2 3.6 1.6-7-5.4-4.7 7.1-.6z"></path>
      </svg>
    </div>
  `;
}

function escapeHtml(s) {
  return String(s)
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#039;');
}

math/public/assets/js/core/api.js
/* =========================================================
   api.js â€” JSON Loader (API helpers)
   ========================================================= */

export async function fetchJson(url, { noStore = false, method = 'GET', body, headers } = {}) {
  const opts = {
    method,
    headers: {
      ...(headers || {}),
    },
  };

  if (body !== undefined) {
    opts.body = JSON.stringify(body);
    opts.headers['Content-Type'] = 'application/json';
  }

  if (noStore) {
    opts.cache = 'no-store';
    opts.headers['Cache-Control'] = 'no-store';
    opts.headers['Pragma'] = 'no-cache';
  }

  const res = await fetch(url, opts);
  if (!res.ok) {
    let message = `ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: ${url}`;
    try {
      const errorPayload = await res.json();
      if (errorPayload?.error) {
        message = errorPayload.error;
      }
    } catch {
      // ignore parse errors
    }
    throw new Error(message);
  }

  if (res.status === 204) return null;
  return await res.json();
}

math/public/assets/js/core/constants.js
/* =========================================================
   constants.js â€” Global Constants & Paths
   ========================================================= */

// App
export const APP_NAME = 'math';

// Storage keys
export const STORAGE_KEYS = {
  LAST_STUDENT_ID: 'math:lastStudentId',
  STUDENTS: 'math:students', // root object for all students progress
  STUDENT_SESSION: 'math:studentSession',
  CACHED_CARDS: 'math:cardsCache',
  STUDENT_COMPLETIONS: 'math:studentCompletions',
};

// Data paths
export const DATA_PATHS = {
  CARDS: '/data/cards.json',
  WEEKS_DIR: '/data/weeks',
  STUDENTS: '/data/students.json',
};

// API paths
export const API_PATHS = {
  CARDS: '/api/cards',
  ADMIN_CARDS: '/api/cards-mng',
  STUDENT_LOGIN: '/api/students/login',
  PROGRESS_COMPLETED: '/api/progress/completed',
  PROGRESS_COMPLETE: '/api/progress/complete',
  ADMIN_STUDENTS: '/api/astu',
  ADMIN_LOGIN: '/api/admin/login',
  ADMIN_PASSWORD: '/api/admin/password',
};

// Lesson / Engine
export const ENGINE = {
  MAX_ATTEMPTS: 3,
};

// UI defaults
export const UI = {
  TOAST_DURATION_SHORT: 2500,
  TOAST_DURATION_MEDIUM: 3500,
  TOAST_DURATION_LONG: 5000,
};

// Progress
export const PROGRESS = {
  START: 0,
  COMPLETE: 100,
};

// Helpers
export function weekJsonPath(week) {
  return `/api/weeks/${week}`;
}

math/public/assets/js/core/gradeMap.js
export const GRADE_WEEK_MAP = {
  '7/1': [999, 1000],
  '7/2': [999],
  '8/1': [1000],
};

export function getWeeksForClass(studentClass) {
  if (!studentClass) return null;
  const key = String(studentClass).trim();
  return GRADE_WEEK_MAP[key] || null;
}

math/public/assets/js/core/normalizeDigits.js
export function normalizeDigits(value) {
  const map = {
    'Ù ': '0',
    'Ù¡': '1',
    'Ù¢': '2',
    'Ù£': '3',
    'Ù¤': '4',
    'Ù¥': '5',
    'Ù¦': '6',
    'Ù§': '7',
    'Ù¨': '8',
    'Ù©': '9',
    'Û°': '0',
    'Û±': '1',
    'Û²': '2',
    'Û³': '3',
    'Û´': '4',
    'Ûµ': '5',
    'Û¶': '6',
    'Û·': '7',
    'Û¸': '8',
    'Û¹': '9',
  };

  return String(value).replace(/[Ù -Ù©Û°-Û¹]/g, (digit) => map[digit] ?? digit);
}

math/public/assets/js/core/router.js
/* =========================================================
   router.js â€” Query String Reader & Navigation Helpers
   ========================================================= */

export function getQueryParam(name) {
  const params = new URLSearchParams(window.location.search);
  return params.get(name);
}

export function getWeekParam() {
  const w = getQueryParam('week');
  if (!w) return null;
  const n = Number(w);
  return Number.isFinite(n) ? n : null;
}

export function goTo(url) {
  window.location.href = url;
}

export function goHome() {
  goTo('/');
}

export function goToLesson(week) {
  goTo(`/lesson.html?week=${encodeURIComponent(week)}`);
}

math/public/assets/js/core/storage.js
/* =========================================================
   storage.js â€” LocalStorage Persistence
   - Students progress per device
   ========================================================= */

import { STORAGE_KEYS } from './constants.js';

/* ---------- Internal helpers ---------- */
function readRoot() {
  try {
    const raw = localStorage.getItem(STORAGE_KEYS.STUDENTS);
    return raw ? JSON.parse(raw) : {};
  } catch {
    return {};
  }
}

function writeRoot(root) {
  localStorage.setItem(STORAGE_KEYS.STUDENTS, JSON.stringify(root));
}

function readJson(key, fallback = null) {
  try {
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : fallback;
  } catch {
    return fallback;
  }
}

function writeJson(key, value) {
  localStorage.setItem(key, JSON.stringify(value));
}

/* ---------- Student Session ---------- */
export function getStudentSession() {
  return readJson(STORAGE_KEYS.STUDENT_SESSION, null);
}

export function setStudentSession(session) {
  if (!session) return;
  writeJson(STORAGE_KEYS.STUDENT_SESSION, session);
}

export function clearStudentSession() {
  try {
    localStorage.removeItem(STORAGE_KEYS.STUDENT_SESSION);
  } catch {}
}

/* ---------- Student ID ---------- */
export function getLastStudentId() {
  return localStorage.getItem(STORAGE_KEYS.LAST_STUDENT_ID);
}

export function setLastStudentId(studentId) {
  localStorage.setItem(STORAGE_KEYS.LAST_STUDENT_ID, studentId);
}

/* ---------- Student Progress ---------- */
/*
Structure:
students = {
  "123456": {
    cards: {
      "999": {
        done: false,
        progress: { conceptIndex: 0, stepIndex: 0 }
      }
    }
  }
}
*/

export function getStudent(studentId) {
  const root = readRoot();
  if (!root[studentId]) {
    root[studentId] = { cards: {} };
    writeRoot(root);
  }
  return root[studentId];
}

export function getStudentProgress(studentId, week) {
  const student = getStudent(studentId);
  return student.cards[String(week)] || null;
}

export function setStudentProgress(studentId, week, progress) {
  const root = readRoot();
  if (!root[studentId]) root[studentId] = { cards: {} };

  root[studentId].cards[String(week)] = {
    ...(root[studentId].cards[String(week)] || {}),
    progress,
  };

  writeRoot(root);
}

/* ---------- Completion helpers ---------- */
export function clearCardProgress(studentId, week) {
  const root = readRoot();
  if (!root[studentId]?.cards?.[String(week)]) return;

  const card = root[studentId].cards[String(week)];
  delete card.progress;

  root[studentId].cards[String(week)] = card;
  writeRoot(root);
}

export function markCardDone(studentId, week) {
  const root = readRoot();
  if (!root[studentId]) root[studentId] = { cards: {} };

  const key = String(week);
  const prev = root[studentId].cards[key] || {};

  // Ø¹Ù†Ø¯Ù…Ø§ ØªÙÙ†Ø¬Ø² Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©: Ù†Ø«Ø¨Øª done ÙˆÙ†Ø­Ø°Ù progress Ø­ØªÙ‰ Ù…Ø§ ÙŠØµÙŠØ± Resume Ø¹Ù„Ù‰ Ø¨Ø·Ø§Ù‚Ø© Ù…Ù†Ø¬Ø²Ø©
  const next = { ...prev, done: true };
  delete next.progress;

  root[studentId].cards[key] = next;

  writeRoot(root);
}

export function isCardDone(studentId, week) {
  const student = getStudent(studentId);
  return Boolean(student.cards[String(week)]?.done);
}

export function syncCardCompletions(studentId, completions) {
  if (!studentId || !Array.isArray(completions)) return;
  completions.forEach((completion) => {
    const weekValue = completion?.Week ?? completion?.week;
    if (Number.isInteger(Number(weekValue))) {
      markCardDone(studentId, Number(weekValue));
    }
  });
}

/* ---------- Cards cache ---------- */
export function getCachedCards() {
  return readJson(STORAGE_KEYS.CACHED_CARDS, []);
}

export function setCachedCards(cards) {
  if (!Array.isArray(cards)) return;
  writeJson(STORAGE_KEYS.CACHED_CARDS, cards);
}

/* ---------- Progress cache ---------- */
export function getStudentCompletions(studentId) {
  if (!studentId) return [];
  const root = readJson(STORAGE_KEYS.STUDENT_COMPLETIONS, {});
  return Array.isArray(root[studentId]) ? root[studentId] : [];
}

export function setStudentCompletions(studentId, completions) {
  if (!studentId || !Array.isArray(completions)) return;
  const root = readJson(STORAGE_KEYS.STUDENT_COMPLETIONS, {});
  root[studentId] = completions;
  writeJson(STORAGE_KEYS.STUDENT_COMPLETIONS, root);
}

export function upsertStudentCompletion(studentId, completion) {
  if (!studentId || !completion) return;
  const root = readJson(STORAGE_KEYS.STUDENT_COMPLETIONS, {});
  const current = Array.isArray(root[studentId]) ? root[studentId] : [];
  const weekValue = completion?.Week ?? completion?.week;
  const next = current.filter((item) => (item?.Week ?? item?.week) !== weekValue);
  next.unshift(completion);
  root[studentId] = next;
  writeJson(STORAGE_KEYS.STUDENT_COMPLETIONS, root);
}

math/public/assets/js/core/students.js
import { fetchJson } from './api.js';
import { DATA_PATHS } from './constants.js';
import { normalizeDigits } from './normalizeDigits.js';

const LS_ADMIN_STUDENTS = 'math:admin:students';

let studentsCache = null;

/**
 * Load students list (cached after first load)
 */
export async function loadStudents() {
  if (studentsCache) {
    return studentsCache;
  }

  const stored = readLocalJson(LS_ADMIN_STUDENTS);
  if (stored && Array.isArray(stored)) {
    studentsCache = stored.map(normalizeStudent);
    return studentsCache;
  }

  const data = await fetchJson(DATA_PATHS.STUDENTS, { noStore: true });
  const list = Array.isArray(data) ? data : data?.students;

  if (!Array.isArray(list)) {
    throw new Error('Students list format is invalid');
  }

  studentsCache = list.map(normalizeStudent);
  return studentsCache;
}

/**
 * Find student by ID number and birth year
 * @param {string} id
 * @param {string} birthYear
 * @returns {object|null}
 */
export async function findStudentByIdentity(id, birthYear) {
  const students = await loadStudents();

  const normalizedId = normalizeDigits(String(id).trim());
  const normalizedYear = normalizeDigits(String(birthYear).trim());

  const student = students.find(s =>
    normalizeDigits(String(s.id)) === normalizedId &&
    normalizeDigits(String(s.birthYear)) === normalizedYear
  );

  return student || null;
}

function normalizeStudent(student) {
  return {
    id: student.StudentId ?? student.studentId ?? student.id ?? '',
    birthYear: student.BirthYear ?? student.birthYear ?? '',
    firstName: student.FirstName ?? student.firstName ?? '',
    fullName: student.FullName ?? student.fullName ?? '',
    class: student.Class ?? student.class ?? '',
  };
}

function readLocalJson(key) {
  try {
    const raw = localStorage.getItem(key);
    return raw ? JSON.parse(raw) : null;
  } catch {
    return null;
  }
}

math/public/assets/js/db-template-edit.js
const STORAGE_KEY = 'math:db-template';
const FALLBACK_SCHEMA = [];

const tableSearch = document.getElementById('tableSearch');
const newTableName = document.getElementById('newTableName');
const btnAddTable = document.getElementById('btnAddTable');
const tablesList = document.getElementById('tablesList');
const emptyState = document.getElementById('emptyState');
const tableEditor = document.getElementById('tableEditor');
const tableNameInput = document.getElementById('tableNameInput');
const btnAddColumn = document.getElementById('btnAddColumn');
const columnsList = document.getElementById('columnsList');
const btnSaveTemplate = document.getElementById('btnSaveTemplate');
const btnExportJson = document.getElementById('btnExportJson');
const jsonPreview = document.getElementById('jsonPreview');

let schema = [];
let activeTableId = null;
let hasLocalChanges = false;

const createId = () => `tbl_${Math.random().toString(36).slice(2, 9)}`;

const render = () => {
  renderTables();
  renderEditor();
  renderJson();
};

const renderTables = () => {
  const query = String(tableSearch?.value || '').trim().toLowerCase();
  tablesList.innerHTML = '';

  const filtered = schema.filter((table) => table.name.toLowerCase().includes(query));

  if (!filtered.length) {
    const empty = document.createElement('li');
    empty.className = 'empty-state';
    empty.textContent = 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¬Ø¯Ø§ÙˆÙ„ Ù…Ø·Ø§Ø¨Ù‚Ø©.';
    tablesList.appendChild(empty);
    return;
  }

  filtered.forEach((table) => {
    const item = document.createElement('li');
    item.className = `table-item ${table.id === activeTableId ? 'is-active' : ''}`;

    const title = document.createElement('span');
    title.textContent = table.name;

    const deleteBtn = document.createElement('button');
    deleteBtn.type = 'button';
    deleteBtn.textContent = 'Ø­Ø°Ù';
    deleteBtn.addEventListener('click', (event) => {
      event.stopPropagation();
      removeTable(table.id);
    });

    item.addEventListener('click', () => {
      activeTableId = table.id;
      render();
    });

    item.appendChild(title);
    item.appendChild(deleteBtn);
    tablesList.appendChild(item);
  });
};

const renderEditor = () => {
  const table = schema.find((entry) => entry.id === activeTableId);
  if (!table) {
    emptyState.classList.remove('hidden');
    tableEditor.classList.add('hidden');
    tableEditor.setAttribute('hidden', '');
    return;
  }

  emptyState.classList.add('hidden');
  tableEditor.classList.remove('hidden');
  tableEditor.removeAttribute('hidden');
  tableNameInput.value = table.name;

  columnsList.innerHTML = '';

  table.columns.forEach((column) => {
    const card = document.createElement('div');
    card.className = 'column-card';

    const grid = document.createElement('div');
    grid.className = 'column-grid';

    const nameField = createField('Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙˆØ¯', column.name, (value) => {
      column.name = value;
      markChanges();
    });

    const typeField = createField('Ø§Ù„Ù†ÙˆØ¹', column.type, (value) => {
      column.type = value;
      markChanges();
    });

    const lengthField = createField('Ø§Ù„Ø·ÙˆÙ„ Ø§Ù„Ø£Ù‚ØµÙ‰', column.maxLength || '', (value) => {
      column.maxLength = value;
      markChanges();
    });

    const nullableField = createSelectField('ÙŠØ³Ù…Ø­ Ø¨Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„ÙØ§Ø±ØºØ©ØŸ', column.nullable ? 'YES' : 'NO', (value) => {
      column.nullable = value === 'YES';
      markChanges();
    });

    grid.appendChild(nameField);
    grid.appendChild(typeField);
    grid.appendChild(lengthField);
    grid.appendChild(nullableField);

    const footer = document.createElement('div');
    footer.className = 'column-footer';
    footer.innerHTML = `<span>Ù…Ø¹Ø±Ù Ø§Ù„Ø¹Ù…ÙˆØ¯: ${column.id}</span>`;

    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.textContent = 'Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø¹Ù…ÙˆØ¯';
    removeBtn.addEventListener('click', () => {
      removeColumn(table.id, column.id);
    });

    footer.appendChild(removeBtn);
    card.appendChild(grid);
    card.appendChild(footer);
    columnsList.appendChild(card);
  });
};

const renderJson = () => {
  jsonPreview.textContent = JSON.stringify(schema, null, 2);
};

const createField = (labelText, value, onChange) => {
  const wrapper = document.createElement('div');
  const label = document.createElement('label');
  label.className = 'label';
  label.textContent = labelText;

  const input = document.createElement('input');
  input.className = 'input';
  input.type = 'text';
  input.value = value;
  input.addEventListener('input', (event) => {
    onChange(event.target.value.trim());
    renderTables();
    renderJson();
  });

  wrapper.appendChild(label);
  wrapper.appendChild(input);
  return wrapper;
};

const createSelectField = (labelText, value, onChange) => {
  const wrapper = document.createElement('div');
  const label = document.createElement('label');
  label.className = 'label';
  label.textContent = labelText;

  const select = document.createElement('select');
  select.className = 'input';
  ['NO', 'YES'].forEach((optionValue) => {
    const option = document.createElement('option');
    option.value = optionValue;
    option.textContent = optionValue;
    option.selected = optionValue === value;
    select.appendChild(option);
  });

  select.addEventListener('change', (event) => {
    onChange(event.target.value);
    renderJson();
  });

  wrapper.appendChild(label);
  wrapper.appendChild(select);
  return wrapper;
};

const addTable = () => {
  const name = String(newTableName.value || '').trim();
  if (!name) {
    newTableName.focus();
    return;
  }

  schema.unshift({
    id: createId(),
    name,
    columns: [],
  });

  newTableName.value = '';
  activeTableId = schema[0].id;
  markChanges();
  render();
};

const removeTable = (tableId) => {
  schema = schema.filter((table) => table.id !== tableId);
  if (activeTableId === tableId) {
    activeTableId = schema[0]?.id || null;
  }
  markChanges();
  render();
};

const addColumn = () => {
  const table = schema.find((entry) => entry.id === activeTableId);
  if (!table) return;

  table.columns.push({
    id: createId(),
    name: 'Ø¹Ù…ÙˆØ¯ Ø¬Ø¯ÙŠØ¯',
    type: 'nvarchar',
    maxLength: '100',
    nullable: false,
  });

  markChanges();
  render();
};

const removeColumn = (tableId, columnId) => {
  const table = schema.find((entry) => entry.id === tableId);
  if (!table) return;
  table.columns = table.columns.filter((column) => column.id !== columnId);
  markChanges();
  render();
};

const markChanges = () => {
  hasLocalChanges = true;
};

const saveToLocal = () => {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(schema));
  hasLocalChanges = false;
};

const copyJson = async () => {
  try {
    await navigator.clipboard.writeText(JSON.stringify(schema, null, 2));
    btnExportJson.textContent = 'ØªÙ… Ø§Ù„Ù†Ø³Ø®';
    setTimeout(() => {
      btnExportJson.textContent = 'Ù†Ø³Ø® JSON';
    }, 1500);
  } catch (error) {
    btnExportJson.textContent = 'ØªØ¹Ø°Ø± Ø§Ù„Ù†Ø³Ø®';
    setTimeout(() => {
      btnExportJson.textContent = 'Ù†Ø³Ø® JSON';
    }, 1500);
  }
};

const parseSchemaMarkdown = (markdown) => {
  const lines = markdown.split('\n');
  const tables = [];
  let currentTable = null;
  let parseRows = false;

  lines.forEach((line) => {
    if (line.startsWith('## ')) {
      if (currentTable) {
        tables.push(currentTable);
      }
      currentTable = {
        id: createId(),
        name: line.replace('## ', '').trim(),
        columns: [],
      };
      parseRows = false;
      return;
    }

    if (!currentTable) return;

    if (line.startsWith('| Column')) {
      parseRows = true;
      return;
    }

    if (parseRows && line.startsWith('| ---')) {
      return;
    }

    if (parseRows && line.startsWith('|')) {
      const cells = line.split('|').map((cell) => cell.trim()).filter(Boolean);
      if (cells.length >= 4) {
        currentTable.columns.push({
          id: createId(),
          name: cells[0],
          type: cells[1],
          maxLength: cells[2],
          nullable: cells[3] === 'YES',
        });
      }
    }
  });

  if (currentTable) {
    tables.push(currentTable);
  }

  return tables;
};

const loadSchema = async () => {
  const stored = localStorage.getItem(STORAGE_KEY);
  if (stored) {
    try {
      schema = JSON.parse(stored);
      activeTableId = schema[0]?.id || null;
      render();
      return;
    } catch (error) {
      localStorage.removeItem(STORAGE_KEY);
    }
  }

  try {
    const response = await fetch('/docs/database-schema.md');
    if (!response.ok) throw new Error('fetch failed');
    const markdown = await response.text();
    schema = parseSchemaMarkdown(markdown);
  } catch (error) {
    schema = FALLBACK_SCHEMA;
  }

  activeTableId = schema[0]?.id || null;
  render();
};

if (tableSearch) {
  tableSearch.addEventListener('input', renderTables);
}

btnAddTable?.addEventListener('click', addTable);
newTableName?.addEventListener('keydown', (event) => {
  if (event.key === 'Enter') {
    addTable();
  }
});

btnAddColumn?.addEventListener('click', addColumn);

btnSaveTemplate?.addEventListener('click', () => {
  saveToLocal();
  btnSaveTemplate.textContent = 'ØªÙ… Ø§Ù„Ø­ÙØ¸';
  setTimeout(() => {
    btnSaveTemplate.textContent = 'Ø­ÙØ¸ Ù…Ø­Ù„ÙŠ';
  }, 1500);
});

btnExportJson?.addEventListener('click', copyJson);

tableNameInput?.addEventListener('input', (event) => {
  const table = schema.find((entry) => entry.id === activeTableId);
  if (!table) return;
  table.name = event.target.value.trim();
  markChanges();
  renderTables();
  renderJson();
});

window.addEventListener('beforeunload', (event) => {
  if (hasLocalChanges) {
    event.preventDefault();
    event.returnValue = '';
  }
});

loadSchema();

math/public/assets/js/lesson/completion.js
/* =========================================================
   completion.js â€” Card Completion Handling + Certificate Hook
   - Marks card done
   - Prepares certificate payload
   - Stores last certificate payload in LocalStorage
   - Shows "Ø¹Ø±Ø¶ Ø§Ù„Ø´Ù‡Ø§Ø¯Ø©" button on completion (no HTML edits needed)

   ========================================================= */

import { fetchJson } from '../core/api.js';
import { API_PATHS } from '../core/constants.js';
import { getStudentSession, isCardDone, markCardDone, upsertStudentCompletion } from '../core/storage.js';
import { showToast } from '../ui/toast.js';
import { goHome } from '../core/router.js';

const LS_LAST_CERTIFICATE = 'math:lastCertificate';      // prepared here
const CERT_URL = '/assets/cert/certificate.html';

export function completeLesson({ studentId, week, cardTitle = '', finalScore = 0 }) {
  const wasDone = isCardDone(studentId, week);
  // mark card as done
  markCardDone(studentId, week);

  // Prepare certificate payload
  const student = getStudentSession();
  const payload = buildCertificatePayload({ studentId, week, cardTitle, student });
  writeLastCertificate(payload);

  // UI: show completion section if exists
  const completeEl = document.getElementById('lessonComplete');
  if (completeEl) {
    completeEl.classList.remove('hidden');
    completeEl.removeAttribute('hidden');
    completeEl.scrollIntoView({ behavior: 'smooth', block: 'start' });

    // Inject data for future UI usage
    completeEl.setAttribute('data-student-name', payload.fullName || payload.firstName || '');
    completeEl.setAttribute('data-week', String(week));

    // Add certificate button (idempotent)
    ensureCertActions(completeEl);
  }

  // Toast includes first name
  if (!wasDone) {
    const firstName = payload.firstName || 'Ø¨Ø·Ù„';
    showToast('Ù…Ù…ØªØ§Ø² ğŸ‰', `Ø£Ø­Ø³Ù†Øª ÙŠØ§ ${firstName} â€” ØªÙ… Ø¥Ù†Ø¬Ø§Ø² Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©`, 'success', 3500);
  }

  syncCompletionToApi({ studentId, week, finalScore });

  // NOTE: we no longer auto-return quickly, to allow opening the certificate
  setTimeout(() => {
    // goHome();
  }, 12000);
}

/* ---------- Certificate UI Actions ---------- */
function ensureCertActions(completeEl) {
  if (completeEl.querySelector('#btnViewCert')) return;

  // Find a good place to inject (card-body preferred)
  const body = completeEl.querySelector('.card-body') || completeEl;

  const wrap = document.createElement('div');
  wrap.className = 'row';
  wrap.style.marginTop = '12px';
  wrap.style.gap = '10px';

  const btnCert = document.createElement('a');
  btnCert.id = 'btnViewCert';
  btnCert.className = 'btn btn-primary btn-lg w-100';
  btnCert.href = CERT_URL;
  btnCert.textContent = 'Ø¹Ø±Ø¶ Ø§Ù„Ø´Ù‡Ø§Ø¯Ø©';

  const btnBack = document.createElement('button');
  btnBack.type = 'button';
  btnBack.className = 'btn btn-outline w-100';
  btnBack.textContent = 'Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª';
  btnBack.addEventListener('click', () => goHome());

  wrap.appendChild(btnCert);
  wrap.appendChild(btnBack);
  body.appendChild(wrap);
}

/* ---------- Certificate Hook Helpers ---------- */
async function syncCompletionToApi({ studentId, week, finalScore }) {
  try {
    const response = await fetchJson(API_PATHS.PROGRESS_COMPLETE, {
      method: 'POST',
      body: { studentId, week, finalScore },
    });

    if (response?.ok === false) {
      throw new Error(response?.error || 'ØªØ¹Ø°Ø± ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²');
    }

    upsertStudentCompletion(studentId, response);
  } catch (error) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', error.message || 'ØªØ¹Ø°Ø± ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¥Ù†Ø¬Ø§Ø² ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…', 'warning');
  }
}

function buildCertificatePayload({ studentId, week, cardTitle, student }) {
  const fullName =
    (student?.fullName && String(student.fullName).trim()) ||
    `Ø·Ø§Ù„Ø¨ ${studentId}`;

  const firstName =
    (student?.firstName && String(student.firstName).trim()) ||
    String(fullName).trim().split(' ')[0] ||
    '';

  const issuedAt = new Date().toISOString();

  return {
    version: 1,
    week: Number(week),
    cardTitle: String(cardTitle || ''),
    studentId: String(studentId),
    firstName,
    fullName,
    class: student?.class ? String(student.class) : '',
    issuedAt
  };
}

function writeLastCertificate(payload) {
  try {
    localStorage.setItem(LS_LAST_CERTIFICATE, JSON.stringify(payload));
  } catch {
    // ignore storage errors
  }
}

math/public/assets/js/lesson/engine.js
/* =========================================================
   engine.js â€” Unlimited Flow Engine (single "Ù…ØªØ§Ø¨Ø¹Ø©" button) + Resume + Completion
   - Concepts can use: concept.flow = [ {type:..., ...}, ... ]  âœ… (no limits)
   - Backward compatible: if no flow, we build flow from legacy fields
   - Stages: goals (once) -> prereq (once) -> goals per concept -> assessment (final)
   - One button only: "Ù…ØªØ§Ø¨Ø¹Ø©"
     * On text items: reveals next item
     * On question items: "Ù…ØªØ§Ø¨Ø¹Ø©" = ØªØ­Ù‚Ù‚ Ù„Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ
       - Wrong: hints/attempts/solution
       - Correct: toast ØªØ¹Ø²ÙŠØ² + Ù…Ù‡Ù„Ø© Ù‚ØµÙŠØ±Ø© Ø«Ù… ÙŠÙƒØ´Ù Ø§Ù„Ù„ÙŠ Ø¨Ø¹Ø¯Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§
   - Auto scroll + focus to newly revealed item after advancing
   - Fix: infer question.type if flow item doesn't include it
   - Resume: load saved { stage, conceptIndex, stepIndex } from storage and continue
   - Completion: when finishing the last item -> mark done + show completion + return home
   - Certificate Hook: pass cardTitle to completion.js (data.title)

   UPDATE (2026-01-14):
   - Fix #1: Preserve question state across re-renders (input value / mcq selection)
     by caching built flow + caching normalized question object per flow item.
   ========================================================= */

import { ENGINE } from '../core/constants.js';
import { showToast } from '../ui/toast.js';
import { ENCOURAGEMENTS, DEFAULT_HINTS, FINAL_HINT, pickRandom } from '../ui/text.js';
import { renderQuestion } from '../questions/registry.js';
import { setStudentProgress, getStudentProgress, isCardDone, markCardDone } from '../core/storage.js';
import { setProgressUI } from './progress.js';
import { completeLesson } from './completion.js';

const LEGACY_ORDER = ['goal', 'explain', 'example', 'example2', 'mistake', 'note', 'question'];
const STAGES = {
  GOALS: 'goals',
  PREREQ: 'prereq',
  CONCEPT: 'concept',
  ASSESSMENT: 'assessment',
};

export function initEngine({ week, studentId, data, mountEl }) {
  mountEl.innerHTML = '';

  let stage = STAGES.GOALS;
  let conceptIndex = 0;
  let itemIndex = 0;

  let assessmentState = {
    attempts: 0,
    completed: false,
    score: null,
    total: null,
  };

  const goalsList = getGoalsList(data);
  const prereqList = getPrereqList(data);
  const assessment = normalizeAssessment(data?.assessment);

  // Scroll/focus control
  let pendingFocus = null; // { conceptIndex, itemIndex }
  let firstPaint = true;

  // Question state (for current question only)
  let activeQuestion = null; // { check, attempts, solutionShown, btn, dotsWrap, container, qData, verifiedOk }

  function getConceptFlow(concept) {
    // IMPORTANT: cache flow so items keep runtime state across re-renders
    if (concept && Array.isArray(concept._flowCache) && concept._flowCache.length) {
      return concept._flowCache;
    }

    let flow = null;

    if (Array.isArray(concept?.flow) && concept.flow.length) {
      // Use original flow array (stable reference) + cache it
      flow = concept.flow;
    } else {
      // Backward compatible: build flow from legacy keys (once)
      flow = [];
      for (const key of LEGACY_ORDER) {
        if (key === 'question') {
          if (concept?.question) {
            flow.push({ type: 'question', q: concept.question });
          }
        } else {
          if (concept?.[key]) flow.push({ type: key, text: concept[key] });
        }
      }
    }

    // cache for stability
    if (concept) concept._flowCache = flow || [];
    return concept?._flowCache || [];
  }

  function buildNormalizedQuestionFromItem(item) {
    // If flow item already contains q object:
    if (item?.q && typeof item.q === 'object') {
      // Use the same object reference as base, but ensure required fields exist
      const q = item.q;

      // Ensure type exists (if missing infer)
      if (!q.type) {
        q.type =
          item?.qtype ||
          item?.questionType ||
          (Array.isArray(q?.choices) ? 'mcq' : 'input');
      }

      // Ensure common fields exist
      if (q.text == null) q.text = item?.text || 'Ø³Ø¤Ø§Ù„';
      if (!Array.isArray(q.hints)) q.hints = q.hints ? [q.hints] : [];
      if (q.solution == null) q.solution = '';

      return q;
    }

    // Otherwise infer from item structure (question written directly in flow)
    const inferredType =
      item?.qtype ||
      item?.questionType ||
      (Array.isArray(item?.choices) ? 'mcq' : 'input');

    const q = {
      type: inferredType,
      text: item?.text || 'Ø³Ø¤Ø§Ù„',
      hints: Array.isArray(item?.hints) ? item.hints : [],
      solution: item?.solution || '',
    };

    if (inferredType === 'mcq') {
      q.choices = item?.choices || [];
      q.correctIndex = typeof item?.correctIndex === 'number' ? item.correctIndex : 0;
    } else {
      q.answer = item?.answer ?? '';
      q.placeholder = item?.placeholder;
    }

    return q;
  }

  function getStableQuestionObjectForFlowItem(item) {
    // IMPORTANT: keep one normalized question object per flow item
    // so UI state (like input value / selected choice) can persist across re-renders.
    if (item?._qState && typeof item._qState === 'object') {
      return item._qState;
    }

    const q = buildNormalizedQuestionFromItem(item);

    // Store on the flow item itself (stable if flow is cached)
    if (item) item._qState = q;

    return q;
  }

  function normalizeAssessment(assessmentData) {
    if (!assessmentData || !Array.isArray(assessmentData.questions)) return null;

    const questions = assessmentData.questions.map((question) => {
      if (!question || typeof question !== 'object') return null;

      const inferredType =
        question?.type ||
        (Array.isArray(question?.choices) ? 'mcq' : 'input');

      const normalized = {
        ...question,
        type: inferredType,
        text: question?.text || 'Ø³Ø¤Ø§Ù„',
        points: Number.isFinite(question?.points) ? Number(question.points) : 1,
      };

      if (inferredType === 'mcq') {
        normalized.choices = Array.isArray(question?.choices) ? question.choices : [];
        normalized.correctIndex =
          typeof question?.correctIndex === 'number' ? question.correctIndex : 0;
      } else {
        normalized.answer = question?.answer ?? '';
        normalized.placeholder = question?.placeholder || 'Ø§ÙƒØªØ¨ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ù‡Ù†Ø§';
      }

      return normalized;
    }).filter(Boolean);

    if (!questions.length) return null;

    return {
      title: assessmentData?.title || 'ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø¯Ø±Ø³',
      description: assessmentData?.description || 'Ø§Ø®ØªØ¨Ø§Ø± ØªÙ‚ÙŠÙŠÙ… Ù…Ù† Ù†Ù‚Ø§Ø· Ø¯ÙˆÙ† ØªØµÙˆÙŠØ¨.',
      questions,
    };
  }

  function totalFlowItems() {
    const concepts = data.concepts || [];
    let total = 0;
    for (const c of concepts) total += getConceptFlow(c).length;
    return Math.max(1, total);
  }

  function totalStages() {
    const base = 2 + totalFlowItems();
    return assessment ? base + 1 : base;
  }

  function currentFlowPosition() {
    const concepts = data.concepts || [];
    let pos = 0;
    for (let i = 0; i < conceptIndex; i++) pos += getConceptFlow(concepts[i]).length;
    pos += itemIndex;
    return pos;
  }

  function currentStagePosition() {
    if (stage === STAGES.GOALS) return 0;
    if (stage === STAGES.PREREQ) return 1;
    if (stage === STAGES.CONCEPT) return 2 + currentFlowPosition();
    return totalStages() - 1;
  }

  function updateProgress() {
    const total = totalStages();
    const pos = currentStagePosition();
    const pct = Math.max(0, Math.min(100, Math.round((pos / total) * 100)));
    setProgressUI(pct);
  }

  function saveProgress() {
    setStudentProgress(studentId, week, {
      stage,
      conceptIndex,
      stepIndex: itemIndex,
      assessment: assessmentState,
    });
  }

  function clampToValidPosition() {
    const concepts = data.concepts || [];
    if (!concepts.length) {
      conceptIndex = 0;
      itemIndex = 0;
      return;
    }

    conceptIndex = Math.max(0, Math.min(conceptIndex, concepts.length - 1));

    const flow = getConceptFlow(concepts[conceptIndex]);
    if (!flow.length) {
      itemIndex = 0;
      return;
    }

    itemIndex = Math.max(0, Math.min(itemIndex, flow.length - 1));
  }

  function applyResumeIfAvailable() {
    if (isCardDone(studentId, week)) return;

    const saved = getStudentProgress(studentId, week)?.progress;
    if (!saved) return;

    if (saved.stage && Object.values(STAGES).includes(saved.stage)) {
      stage = saved.stage;
    }

    if (Number.isFinite(saved.conceptIndex)) conceptIndex = Number(saved.conceptIndex);
    if (Number.isFinite(saved.stepIndex)) itemIndex = Number(saved.stepIndex);

    if (saved.assessment && typeof saved.assessment === 'object') {
      assessmentState = {
        ...assessmentState,
        ...saved.assessment,
      };
    }

    clampToValidPosition();

    // focus the current item after first render
    pendingFocus = { conceptIndex, itemIndex };
    firstPaint = true;
  }

  function isLastPosition() {
    const concepts = data.concepts || [];
    if (!concepts.length) return true;

    const lastConceptIdx = concepts.length - 1;
    const lastFlow = getConceptFlow(concepts[lastConceptIdx]);
    const lastItemIdx = Math.max(0, lastFlow.length - 1);

    return conceptIndex === lastConceptIdx && itemIndex === lastItemIdx;
  }

  function finishCard() {
    // Persist completion
    markCardDone(studentId, week);

    // Pass title for certificate hook readiness
    const cardTitle = String(data?.title || '');
    const finalScore = Number.isFinite(assessmentState?.score) ? assessmentState.score : 0;

    // Use existing completion handler (shows UI + returns home)
    completeLesson({ studentId, week, cardTitle, finalScore });
  }

  function render() {
    mountEl.innerHTML = '';
    activeQuestion = null;

    if (stage === STAGES.GOALS) {
      renderGoalsStage();
      return;
    }

    if (stage === STAGES.PREREQ) {
      renderPrereqStage();
      return;
    }

    if (stage === STAGES.ASSESSMENT) {
      renderAssessmentStage();
      return;
    }

    renderConceptStage();
  }

  function renderGoalsStage() {
    const card = document.createElement('div');
    card.className = 'lesson-stage card';

    card.innerHTML = `
      <div class="stage-header">
        <span class="stage-badge">Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰</span>
        <h3 class="stage-title">Ø¹Ø±Ø¶ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙƒØ§Ù…Ù„Ø©</h3>
      </div>
      <div class="stage-body"></div>
    `;

    const body = card.querySelector('.stage-body');
    const list = document.createElement('ul');
    list.className = 'goal-list';

    if (goalsList.length) {
      goalsList.forEach((goal, idx) => {
        const item = document.createElement('li');
        item.className = 'goal-item';
        item.innerHTML = `
          <span class="goal-index">${idx + 1}</span>
          <span class="goal-text">${escapeHtml(goal.text)}</span>
        `;
        list.appendChild(item);
      });
    } else {
      const empty = document.createElement('div');
      empty.className = 'stage-empty';
      empty.textContent = 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø£Ù‡Ø¯Ø§Ù Ù…Ø³Ø¬Ù„Ø© Ø¨Ø¹Ø¯.';
      body.appendChild(empty);
    }

    body.appendChild(list);

    const nav = document.createElement('div');
    nav.className = 'lesson-nav';

    const btn = document.createElement('button');
    btn.className = 'btn btn-primary w-100';
    btn.textContent = 'Ù…ØªØ§Ø¨Ø¹Ø©';
    btn.addEventListener('click', () => {
      stage = STAGES.PREREQ;
      render();
    });

    nav.appendChild(btn);
    card.appendChild(nav);
    mountEl.appendChild(card);

    updateProgress();
    saveProgress();
  }

  function renderPrereqStage() {
    const card = document.createElement('div');
    card.className = 'lesson-stage card';

    card.innerHTML = `
      <div class="stage-header">
        <span class="stage-badge">Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©</span>
        <h3 class="stage-title">Ø¹Ø±Ø¶ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©</h3>
      </div>
      <div class="stage-body"></div>
    `;

    const body = card.querySelector('.stage-body');
    const list = document.createElement('ul');
    list.className = 'goal-list prereq-list';

    if (prereqList.length) {
      prereqList.forEach((req, idx) => {
        const item = document.createElement('li');
        item.className = 'goal-item';
        item.innerHTML = `
          <span class="goal-index">${idx + 1}</span>
          <span class="goal-text">${escapeHtml(req)}</span>
        `;
        list.appendChild(item);
      });
    } else {
      const empty = document.createElement('div');
      empty.className = 'stage-empty';
      empty.textContent = 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…ØªØ·Ù„Ø¨Ø§Øª Ø³Ø§Ø¨Ù‚Ø© Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©.';
      body.appendChild(empty);
    }

    body.appendChild(list);

    const nav = document.createElement('div');
    nav.className = 'lesson-nav';

    const btn = document.createElement('button');
    btn.className = 'btn btn-primary w-100';
    btn.textContent = 'Ù…ØªØ§Ø¨Ø¹Ø©';
    btn.addEventListener('click', () => {
      stage = STAGES.CONCEPT;
      conceptIndex = 0;
      itemIndex = 0;
      render();
    });

    nav.appendChild(btn);
    card.appendChild(nav);
    mountEl.appendChild(card);

    updateProgress();
    saveProgress();
  }

  function renderConceptStage() {
    const concept = data.concepts?.[conceptIndex];
    if (!concept) {
      if (assessment) {
        stage = STAGES.ASSESSMENT;
        render();
        return;
      }
      finishCard();
      return;
    }

    const flow = getConceptFlow(concept);
    if (!flow.length) {
      conceptIndex++;
      itemIndex = 0;
      render();
      return;
    }

    // clamp
    if (itemIndex < 0) itemIndex = 0;

    if (itemIndex >= flow.length) {
      conceptIndex++;
      itemIndex = 0;
      render();
      return;
    }

    const card = document.createElement('div');
    card.className = 'concept';

    const cardInner = document.createElement('div');
    cardInner.className = 'card';

    cardInner.innerHTML = `
      <div class="stage-progress">
        <span class="stage-badge">Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©</span>
        <div class="stage-progress-body"></div>
      </div>
      <div class="concept-header">
        <div class="row">
          <span class="concept-index">${conceptIndex + 1}</span>
          <h3 class="concept-title">${escapeHtml(concept.title || '')}</h3>
        </div>
      </div>
      <div class="concept-body" data-concept-index="${conceptIndex}"></div>
    `;

    const stageBody = cardInner.querySelector('.stage-progress-body');
    stageBody.appendChild(renderGoalsProgress(conceptIndex));

    const body = cardInner.querySelector('.concept-body');

    // render items up to current
    for (let i = 0; i <= itemIndex; i++) {
      const item = flow[i];
      if (!item || !item.type) continue;

      if (item.type === 'question') {
        body.appendChild(renderQuestionItem(item, i));
      } else if (item.type === 'video') {
        body.appendChild(renderVideoItem(item, i));
      } else {
        body.appendChild(renderTextItem(item, i));
      }
    }

    // single button bar (always)
    const bar = document.createElement('div');
    bar.className = 'lesson-nav';

    const btn = document.createElement('button');
    btn.className = 'btn btn-primary w-100';
    btn.textContent = 'Ù…ØªØ§Ø¨Ø¹Ø©';

    bar.appendChild(btn);
    body.appendChild(bar);

    // decide behavior for current item
    const currentItem = flow[itemIndex];
    if (currentItem?.type === 'question' && activeQuestion) {
      activeQuestion.btn = btn;
      btn.addEventListener('click', () => onVerifyOrAdvanceQuestion());
    } else {
      btn.addEventListener('click', () => advanceWithFocus());
    }

    card.appendChild(cardInner);
    mountEl.appendChild(card);

    updateProgress();
    saveProgress();

    if (pendingFocus) {
      requestAnimationFrame(() => {
        scrollAndFocusToItem(pendingFocus.itemIndex);
        pendingFocus = null;
      });
    }
    firstPaint = false;
  }

  function renderAssessmentStage() {
    if (!assessment) {
      finishCard();
      return;
    }

    const card = document.createElement('div');
    card.className = 'lesson-stage card assessment';

    card.innerHTML = `
      <div class="stage-header">
        <span class="stage-badge">Ø§Ù„Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø±Ø§Ø¨Ø¹Ø©</span>
        <h3 class="stage-title">${escapeHtml(assessment.title)}</h3>
        <p class="stage-desc">${escapeHtml(assessment.description)}</p>
      </div>
      <div class="stage-body assessment-body"></div>
    `;

    const body = card.querySelector('.assessment-body');

    assessment.questions.forEach((question, index) => {
      const item = document.createElement('div');
      item.className = 'assessment-question';
      item.appendChild(renderAssessmentQuestion(question, index));
      body.appendChild(item);
    });

    const actions = document.createElement('div');
    actions.className = 'lesson-nav';

    const btnSubmit = document.createElement('button');
    btnSubmit.className = 'btn btn-primary w-100';
    btnSubmit.textContent = 'Ø§Ø­Ø³Ø¨ Ø§Ù„Ù†ØªÙŠØ¬Ø©';

    const btnFinish = document.createElement('button');
    btnFinish.className = 'btn btn-outline w-100';
    btnFinish.textContent = 'Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©';

    const result = document.createElement('div');
    result.className = 'assessment-result hidden';

    if (assessmentState.completed) {
      applyAssessmentResult(result, assessmentState);
      result.classList.remove('hidden');
      btnSubmit.disabled = true;
    }

    btnSubmit.addEventListener('click', () => {
      if (assessmentState.completed && assessmentState.attempts >= 2) return;

      const { score, total } = scoreAssessment(assessment.questions);
      assessmentState = {
        attempts: assessmentState.attempts + 1,
        completed: true,
        score,
        total,
      };

      showToast('Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙ‚ÙŠÙŠÙ…', `Ø­ØµÙ„Øª Ø¹Ù„Ù‰ ${score} Ù…Ù† ${total} Ù†Ù‚Ø·Ø©.`, 'success', 3500);
      render();
    });

    btnFinish.addEventListener('click', () => {
      if (!assessmentState.completed) {
        showToast('ØªÙ†Ø¨ÙŠÙ‡', 'Ø§Ø­Ø³Ø¨ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø£ÙˆÙ„Ù‹Ø§ Ù‚Ø¨Ù„ Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©', 'warning');
        return;
      }
      finishCard();
    });

    actions.appendChild(btnSubmit);
    actions.appendChild(btnFinish);

    card.appendChild(actions);
    card.appendChild(result);
    mountEl.appendChild(card);

    updateProgress();
    saveProgress();
  }

  function applyAssessmentResult(container, state) {
    const retryLeft = state.attempts < 2;

    container.innerHTML = `
      <div class="assessment-score">
        Ø­ØµÙ„Øª Ø¹Ù„Ù‰ <strong>${state.score}</strong> Ù…Ù† <strong>${state.total}</strong> Ù†Ù‚Ø·Ø©.
      </div>
      <div class="assessment-note">
        ${retryLeft ? 'ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø·.' : 'ØªÙ… Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ ÙØ±ØµØ© Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©.'}
      </div>
    `;

    if (retryLeft) {
      const btnRetry = document.createElement('button');
      btnRetry.type = 'button';
      btnRetry.className = 'btn btn-ghost w-100';
      btnRetry.textContent = 'Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© (Ù…Ø±Ø© ÙˆØ§Ø­Ø¯Ø©)';
      btnRetry.addEventListener('click', () => {
        assessmentState = {
          attempts: state.attempts,
          completed: false,
          score: null,
          total: null,
        };

        assessment.questions.forEach((question) => resetAssessmentQuestion(question));
        render();
      });
      container.appendChild(btnRetry);
    }
  }

  function renderTextItem(item, idx) {
    const map = {
      goal:     { title: 'Ø§Ù„Ù‡Ø¯Ù', cls: '' },
      explain:  { title: 'Ø§Ù„Ø´Ø±Ø­', cls: '' },
      example:  { title: 'Ù…Ø«Ø§Ù„ Ù…Ø­Ù„ÙˆÙ„', cls: 'example' },
      example2: { title: 'Ù…Ø«Ø§Ù„ Ø¥Ø¶Ø§ÙÙŠ', cls: 'example' },
      mistake:  { title: 'Ø®Ø·Ø£ Ø´Ø§Ø¦Ø¹', cls: 'warning' },
      note:     { title: 'Ù…Ù„Ø§Ø­Ø¸Ø©', cls: 'note' },
      detail:   { title: 'ØªÙØµÙŠÙ„ Ø¥Ø¶Ø§ÙÙŠ', cls: 'detail' },
    };

    const cfg = map[item.type] || { title: 'Ù…Ø­ØªÙˆÙ‰', cls: '' };

    const el = document.createElement('div');
    el.className = `step ${cfg.cls || ''}`.trim();
    el.setAttribute('data-step-index', String(idx));
    el.setAttribute('data-step-key', item.type);

    const details = Array.isArray(item.details)
      ? item.details.map((line) => `<li>${escapeHtml(line)}</li>`).join('')
      : '';

    el.innerHTML = `
      <p class="step-title">${cfg.title}</p>
      <div class="step-text">${escapeHtml(item.text ?? '')}</div>
      ${details ? `<ul class="step-details">${details}</ul>` : ''}
    `;
    return el;
  }

  function renderVideoItem(item, idx) {
    const el = document.createElement('div');
    el.className = 'step video';
    el.setAttribute('data-step-index', String(idx));
    el.setAttribute('data-step-key', 'video');

    const title = item?.title || 'ÙÙŠØ¯ÙŠÙˆ ØªÙˆØ¶ÙŠØ­ÙŠ';
    const description = item?.description || item?.text || '';
    const url = item?.url || item?.src || '';

    const embed = renderVideoEmbed(url);

    el.innerHTML = `
      <p class="step-title">${escapeHtml(title)}</p>
      ${description ? `<div class="step-text">${escapeHtml(description)}</div>` : ''}
      <div class="video-frame">${embed}</div>
    `;

    return el;
  }

  function renderVideoEmbed(url) {
    if (!url) {
      return '<div class="video-empty">Ù„Ù… ÙŠØªÙ… Ø¥Ø¶Ø§ÙØ© Ø±Ø§Ø¨Ø· ÙÙŠØ¯ÙŠÙˆ Ø¨Ø¹Ø¯.</div>';
    }

    const youtubeId = getYouTubeId(url);
    if (youtubeId) {
      const safeId = encodeURIComponent(youtubeId);
      return `
        <iframe
          class="video-embed"
          src="https://www.youtube.com/embed/${safeId}"
          title="ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø¯Ø±Ø³"
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen
        ></iframe>
      `;
    }

    return `
      <video class="video-embed" controls preload="metadata" src="${escapeHtml(url)}"></video>
    `;
  }

  function renderQuestionItem(item, idx) {
    const wrap = document.createElement('div');
    wrap.className = 'question-wrap';
    wrap.setAttribute('data-step-index', String(idx));
    wrap.setAttribute('data-step-key', 'question');

    // IMPORTANT: stable question object for this flow item (persists across re-renders)
    const qData = getStableQuestionObjectForFlowItem(item);

    const title = document.createElement('p');
    title.className = 'question-title';
    title.textContent = qData.text || 'Ø³Ø¤Ø§Ù„';

    const attemptsWrap = document.createElement('div');
    attemptsWrap.className = 'attempts';
    attemptsWrap.innerHTML = `
      <span class="dot"></span>
      <span class="dot"></span>
      <span class="dot"></span>
    `;

    const qMount = document.createElement('div');

    const actions = document.createElement('div');
    actions.className = 'question-actions';
    actions.appendChild(attemptsWrap);

    wrap.appendChild(title);
    wrap.appendChild(qMount);
    wrap.appendChild(actions);

    try {
      const q = renderQuestion({ mountEl: qMount, question: qData });

      activeQuestion = {
        check: q.check,
        attempts: 0,
        solutionShown: false,
        btn: null,
        dotsWrap: attemptsWrap,
        container: wrap,
        qData,
        verifiedOk: false,
      };
    } catch (err) {
      console.error(err);
      const errBox = document.createElement('div');
      errBox.className = 'solution';
      errBox.innerHTML = `
        <p class="solution-title">Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø³Ø¤Ø§Ù„</p>
        <div class="solution-text">ØªØ£ÙƒØ¯ Ù…Ù† Ù†ÙˆØ¹ Ø§Ù„Ø³Ø¤Ø§Ù„ ÙˆØ­Ù‚ÙˆÙ„Ù‡ (input/mcq).</div>
      `;
      wrap.appendChild(errBox);
      showToast('Ø®Ø·Ø£', 'ÙÙŠ Ù…Ø´ÙƒÙ„Ø© Ø¨Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø³Ø¤Ø§Ù„ (JSON)', 'error', 4500);
      activeQuestion = null;
    }

    return wrap;
  }

  function renderAssessmentQuestion(question, index) {
    const wrap = document.createElement('div');
    wrap.className = 'assessment-item';

    const title = document.createElement('p');
    title.className = 'assessment-title';
    title.textContent = `${index + 1}. ${question.text}`;

    wrap.appendChild(title);

    if (question.type === 'mcq') {
      const groupName = `assessment-${index}`;

      (question.choices || []).forEach((choice, cIdx) => {
        const label = document.createElement('label');
        label.className = 'choice';

        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = groupName;
        radio.value = String(cIdx);
        radio.checked = question._selectedIndex === cIdx;
        radio.addEventListener('change', () => {
          question._selectedIndex = cIdx;
        });

        const span = document.createElement('span');
        span.textContent = choice;

        label.appendChild(radio);
        label.appendChild(span);
        wrap.appendChild(label);
      });

      return wrap;
    }

    const input = document.createElement('input');
    input.className = 'input ltr';
    input.type = 'text';
    input.placeholder = question.placeholder || 'Ø§ÙƒØªØ¨ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ù‡Ù†Ø§';
    input.value = question._value || '';
    input.addEventListener('input', () => {
      question._value = input.value;
    });

    wrap.appendChild(input);
    return wrap;
  }

  function resetAssessmentQuestion(question) {
    delete question._value;
    delete question._selectedIndex;
  }

  function scoreAssessment(questions) {
    let score = 0;
    let total = 0;

    questions.forEach((question) => {
      const points = Number.isFinite(question.points) ? question.points : 1;
      total += points;

      if (question.type === 'mcq') {
        if (question._selectedIndex === question.correctIndex) score += points;
        return;
      }

      const rawUser = question._value ?? '';
      const rawAns = question.answer ?? '';
      const ok = compareAnswer(rawUser, rawAns);
      if (ok) score += points;
    });

    return { score, total };
  }

  function compareAnswer(userValue, answerValue) {
    const user = normalizeSpaces(userValue);
    const ans = normalizeSpaces(answerValue);

    if (isNumericAnswer(ans)) {
      const userNum = parseNumericValue(user);
      const ansNum = parseNumericValue(ans);

      return Number.isFinite(userNum) && Number.isFinite(ansNum) && userNum === ansNum;
    }

    return user !== '' && user === ans;
  }

  function normalizeSpaces(s) {
    if (s == null) return '';
    return String(s).trim().replace(/\s+/g, ' ');
  }

  function toLatinDigits(str) {
    const map = {
      'Ù ': '0', 'Ù¡': '1', 'Ù¢': '2', 'Ù£': '3', 'Ù¤': '4',
      'Ù¥': '5', 'Ù¦': '6', 'Ù§': '7', 'Ù¨': '8', 'Ù©': '9',
      'Û°': '0', 'Û±': '1', 'Û²': '2', 'Û³': '3', 'Û´': '4',
      'Ûµ': '5', 'Û¶': '6', 'Û·': '7', 'Û¸': '8', 'Û¹': '9',
    };
    return String(str).replace(/[Ù -Ù©Û°-Û¹]/g, (d) => map[d] ?? d);
  }

  function parseNumericValue(value) {
    if (value == null) return NaN;
    const normalized = toLatinDigits(String(value))
      .trim()
      .replace(',', '.')
      .replace(/\s+/g, '');

    if (!/^[-+]?(\d+(\.\d+)?|\.\d+)$/.test(normalized)) return NaN;

    const num = Number(normalized);
    return Number.isFinite(num) ? num : NaN;
  }

  function isNumericAnswer(ans) {
    return Number.isFinite(parseNumericValue(ans));
  }

  function getYouTubeId(url) {
    try {
      const parsed = new URL(url);
      if (parsed.hostname.includes('youtu.be')) {
        return parsed.pathname.replace('/', '');
      }
      if (parsed.hostname.includes('youtube.com')) {
        return parsed.searchParams.get('v');
      }
    } catch {
      return null;
    }
    return null;
  }

  function onVerifyOrAdvanceQuestion() {
    if (!activeQuestion || !activeQuestion.btn) return;

    if (activeQuestion.verifiedOk) {
      advanceWithFocus();
      return;
    }

    const ok = activeQuestion.check();

    if (ok) {
      activeQuestion.verifiedOk = true;
      activeQuestion.btn.disabled = true;

      showToast('ØµØ­ âœ”', pickRandom(ENCOURAGEMENTS), 'success');

      setTimeout(() => {
        advanceWithFocus();
      }, 850);

      return;
    }

    activeQuestion.attempts++;
    const a = activeQuestion.attempts;

    if (a <= ENGINE.MAX_ATTEMPTS) {
      markAttempt(activeQuestion.dotsWrap, a);

      if (a < ENGINE.MAX_ATTEMPTS) {
        const hint =
          activeQuestion.qData.hints?.[a - 1] ||
          DEFAULT_HINTS[a - 1] ||
          FINAL_HINT;

        showToast('ØªÙ„Ù…ÙŠØ­', hint, 'warning', 4000);
      } else {
        const hint3 = activeQuestion.qData.hints?.[a - 1] || FINAL_HINT;
        showToast('ØªÙ„Ù…ÙŠØ­ Ù‚ÙˆÙŠ', hint3, 'warning', 4500);

        if (!activeQuestion.solutionShown) {
          showToast('Ø§Ù„Ø­Ù„', 'ØªÙ… Ø¹Ø±Ø¶ Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ ØªØ­Øª', 'danger', 4500);
          showSolution(activeQuestion.container, activeQuestion.qData.solution);
          activeQuestion.solutionShown = true;
        }
      }
    } else {
      showToast('Ø¬Ø±Ù‘Ø¨ ÙƒÙ…Ø§Ù†', 'Ø§Ø±Ø¬Ø¹ Ù„Ù„Ø­Ù„ ÙˆØ§Ø¹Ù…Ù„ Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©', 'info', 2500);
    }
  }

  function markAttempt(wrap, count) {
    const dots = wrap.querySelectorAll('.dot');
    for (let i = 0; i < count && i < dots.length; i++) {
      dots[i].classList.add('used');
    }
  }

  function showSolution(container, solutionText) {
    const existing = container.querySelector('.solution');
    if (existing) return;

    const sol = document.createElement('div');
    sol.className = 'solution';
    sol.innerHTML = `
      <p class="solution-title">Ø§Ù„Ø­Ù„ Ø§Ù„Ù†Ù…ÙˆØ°Ø¬ÙŠ</p>
      <div class="solution-text">${escapeHtml(solutionText || '')}</div>
    `;
    container.appendChild(sol);
  }

  function setPendingFocusToNext() {
    const concepts = data.concepts || [];
    const concept = concepts[conceptIndex];
    const flow = concept ? getConceptFlow(concept) : [];

    let nextConcept = conceptIndex;
    let nextItem = itemIndex + 1;

    if (nextItem >= flow.length) {
      nextConcept = conceptIndex + 1;
      nextItem = 0;
    }

    pendingFocus = { conceptIndex: nextConcept, itemIndex: nextItem };
  }

  function advance() {
    const concepts = data.concepts || [];
    const concept = concepts[conceptIndex];
    const flow = concept ? getConceptFlow(concept) : [];

    // If we are at the last item of the last concept and trying to advance
    if (isLastPosition()) {
      if (assessment) {
        stage = STAGES.ASSESSMENT;
        render();
        return;
      }
      finishCard();
      return;
    }

    itemIndex++;
    if (itemIndex >= flow.length) {
      conceptIndex++;
      itemIndex = 0;
    }
    render();
  }

  function advanceWithFocus() {
    setPendingFocusToNext();
    advance();
  }

  function scrollAndFocusToItem(iIdx) {
    const target = mountEl.querySelector(`[data-step-index="${iIdx}"]`);
    if (!target) return;

    if (!target.hasAttribute('tabindex')) target.setAttribute('tabindex', '-1');

    target.scrollIntoView({ behavior: 'smooth', block: 'start' });

    try {
      target.focus({ preventScroll: true });
    } catch {
      target.focus();
    }
  }

  function renderGoalsProgress(currentIndex) {
    const list = document.createElement('ul');
    list.className = 'goal-progress';

    if (!goalsList.length) {
      const empty = document.createElement('li');
      empty.className = 'goal-progress-item muted';
      empty.textContent = 'Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£Ù‡Ø¯Ø§Ù Ù„Ù‡Ø°Ù‡ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø¨Ø¹Ø¯.';
      list.appendChild(empty);
      return list;
    }

    goalsList.forEach((goal, idx) => {
      const item = document.createElement('li');
      let status = 'upcoming';
      let statusText = 'Ù‚Ø§Ø¯Ù…';

      if (idx < currentIndex) {
        status = 'done';
        statusText = 'Ù…ÙƒØªÙ…Ù„ âœ”ï¸';
      } else if (idx === currentIndex) {
        status = 'current';
        statusText = 'Ø§Ù„Ù‡Ø¯Ù Ø§Ù„Ø­Ø§Ù„ÙŠ';
      }

      item.className = `goal-progress-item ${status}`;
      item.innerHTML = `
        <span class="goal-status">${statusText}</span>
        <span class="goal-text">${escapeHtml(goal.text)}</span>
      `;

      list.appendChild(item);
    });

    return list;
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#039;');
  }

  function getGoalsList(dataObj) {
    if (Array.isArray(dataObj?.goals) && dataObj.goals.length) {
      return dataObj.goals.map((goal) => ({
        text: typeof goal === 'string' ? goal : String(goal?.text || ''),
      })).filter((goal) => goal.text.trim() !== '');
    }

    const goals = [];
    (dataObj?.concepts || []).forEach((concept) => {
      const flow = Array.isArray(concept?.flow) ? concept.flow : [];
      const goalItem = flow.find((item) => item?.type === 'goal');
      const text = goalItem?.text || concept?.title || 'Ù‡Ø¯Ù';
      goals.push({ text: String(text) });
    });

    return goals;
  }

  function getPrereqList(dataObj) {
    if (Array.isArray(dataObj?.prerequisites)) {
      return dataObj.prerequisites.filter((item) => String(item).trim() !== '')
        .map((item) => String(item));
    }

    if (Array.isArray(dataObj?.prereq)) {
      return dataObj.prereq.filter((item) => String(item).trim() !== '')
        .map((item) => String(item));
    }

    return [];
  }

  // Apply resume (if any) before first render
  applyResumeIfAvailable();

  // start
  render();
}

math/public/assets/js/lesson/lessonPage.js
/* =========================================================
   lessonPage.js â€” Lesson Page Bootstrap
   - Reads student + week
   - Loads week JSON
   - Initializes engine
   - Shows student name (firstName/fullName) instead of id
   ========================================================= */

import { getWeekParam, goHome } from '../core/router.js';
import { fetchJson } from '../core/api.js';
import { weekJsonPath } from '../core/constants.js';
import { getLastStudentId, getStudentSession } from '../core/storage.js';
import { showToast } from '../ui/toast.js';
import { initEngine } from './engine.js';


export async function initLessonPage() {
  const week = getWeekParam();
  const studentId = getLastStudentId();

  if (!week) {
    goHome();
    return;
  }

  if (!studentId) {
    showToast('ØªÙ†Ø¨ÙŠÙ‡', 'Ù„Ø§Ø²Ù… ØªØ¯Ø®Ù„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ø§Ù„Ø¨ Ø£ÙˆÙ„Ù‹Ø§', 'warning');
    goHome();
    return;
  }

  const student = getStudentSession();
  const displayName =
    (student?.firstName && String(student.firstName).trim()) ||
    (student?.fullName && String(student.fullName).trim()) ||
    `Ø·Ø§Ù„Ø¨ ${studentId}`;

  // UI refs
  const titleEl = document.getElementById('lessonTitle');
  const studentEl = document.getElementById('lessonStudent');
  const weekEl = document.getElementById('lessonWeek');
  const contentEl = document.getElementById('lessonContent');
  const completeEl = document.getElementById('lessonComplete');

  studentEl.textContent = displayName;
  weekEl.textContent = `week ${week}`;

  if (completeEl) {
    completeEl.classList.add('hidden');
    completeEl.setAttribute('hidden', 'hidden');
  }

  try {
    const data = await fetchJson(weekJsonPath(week), { noStore: true });

    titleEl.textContent = data.title || `Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ ${week}`;

    // init engine
    initEngine({
      week,
      studentId,
      data,
      mountEl: contentEl,
    });
  } catch (e) {
    console.error(e);
    titleEl.textContent = 'Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©';
    showToast('Ø®Ø·Ø£', 'ØªØ¹Ø°Ø± ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¯Ø±Ø³', 'error');
  }
}

math/public/assets/js/lesson/progress.js
/* =========================================================
   progress.js â€” Progress Calculation & UI
   ========================================================= */

export function calcProgressPercent({ data, conceptIndex, stepIndex, stepsPerConcept }) {
  const concepts = data?.concepts || [];
  const totalConcepts = concepts.length || 1;

  const totalSteps = totalConcepts * stepsPerConcept;
  const currentStep = (conceptIndex * stepsPerConcept) + stepIndex;

  const pct = Math.max(0, Math.min(100, Math.round((currentStep / totalSteps) * 100)));
  return pct;
}

export function setProgressUI(percent) {
  const bar = document.getElementById('progressBar');
  const txt = document.getElementById('progressPercent');
  if (bar) bar.style.width = `${percent}%`;
  if (txt) txt.textContent = `${percent}%`;
}

math/public/assets/js/lesson/registry.js
/* =========================================================
   registry.js â€” Question Type Registry
   - renderQuestion({ mountEl, question }) => { check() }
   ========================================================= */

import { renderInputQuestion } from './input.js';
import { renderMcqQuestion } from './mcq.js';
import { renderMatchQuestion } from './match.js';

const REGISTRY = {
  input: renderInputQuestion,
  mcq: renderMcqQuestion,
  match: renderMatchQuestion, // structure only for now
};

export function renderQuestion({ mountEl, question }) {
  if (!question || !question.type) {
    throw new Error('Ø³Ø¤Ø§Ù„ ØºÙŠØ± ØµØ§Ù„Ø­: type Ù…ÙÙ‚ÙˆØ¯');
  }

  const renderer = REGISTRY[question.type];
  if (!renderer) {
    throw new Error(`Ù†ÙˆØ¹ Ø³Ø¤Ø§Ù„ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…: ${question.type}`);
  }

  return renderer({ mountEl, question });
}

export function registerQuestionType(type, renderer) {
  REGISTRY[type] = renderer;
}

math/public/assets/js/questions/input.js
/* =========================================================
   input.js â€” Input Question
   - If expected answer is numeric:
     - mobile keyboard shows numbers (inputmode="numeric")
     - field only accepts digits (even on PC)
     - compare by numeric value (2 == 02 == Ù¢ == Û²)
   - Otherwise: normal text compare after trim + collapse spaces
   - Mobile UX: keep input visible above keyboard while typing (VisualViewport)

   UPDATE (2026-01-14):
   - Pressing Enter/Go triggers the main "Ù…ØªØ§Ø¨Ø¹Ø©" button automatically
   - Persist input value across engine re-renders using question._value

   UPDATE (2026-01-14) #2:
   - Improve keyboard overlap fix:
     * scroll based on the whole question box (.question-wrap), not only the input
     * re-run visibility adjustment after check (so attempts/solution stay visible)
   ========================================================= */

export function renderInputQuestion({ mountEl, question }) {
  mountEl.innerHTML = '';

  const wrap = document.createElement('div');
  wrap.className = 'q q-input';

  const desc = document.createElement('div');
  desc.className = 'q-desc';
  desc.textContent = question.text || '';

  const input = document.createElement('input');
  input.className = 'input ltr';
  input.type = 'text';
  input.autocomplete = 'off';
  input.placeholder = question.placeholder || 'Ø§ÙƒØªØ¨ Ø¥Ø¬Ø§Ø¨ØªÙƒ Ù‡Ù†Ø§';

  const feedback = document.createElement('div');
  feedback.className = 'q-feedback';
  feedback.textContent = '';

  wrap.appendChild(desc);
  wrap.appendChild(input);
  wrap.appendChild(feedback);

  mountEl.appendChild(wrap);

  function normalizeSpaces(s) {
    if (s == null) return '';
    return String(s).trim().replace(/\s+/g, ' ');
  }

  function toLatinDigits(str) {
    const map = {
      'Ù ': '0', 'Ù¡': '1', 'Ù¢': '2', 'Ù£': '3', 'Ù¤': '4',
      'Ù¥': '5', 'Ù¦': '6', 'Ù§': '7', 'Ù¨': '8', 'Ù©': '9',
      'Û°': '0', 'Û±': '1', 'Û²': '2', 'Û³': '3', 'Û´': '4',
      'Ûµ': '5', 'Û¶': '6', 'Û·': '7', 'Û¸': '8', 'Û¹': '9',
    };
    return String(str).replace(/[Ù -Ù©Û°-Û¹]/g, (d) => map[d] ?? d);
  }

  function numericOnly(str) {
    return String(str).replace(/[^0-9]/g, '');
  }

  function isNumericAnswer(ans) {
    const a = numericOnly(toLatinDigits(normalizeSpaces(ans)));
    return a.length > 0 && /^[0-9]+$/.test(a);
  }

  const expectsNumber = isNumericAnswer(question.answer);

  // Restore previous value (persisted by engine via stable question object)
  if (typeof question._value === 'string' && question._value !== '') {
    input.value = question._value;
  }

  if (expectsNumber) {
    // Mobile: numeric keyboard
    input.inputMode = 'numeric';
    input.pattern = '[0-9]*';

    // Desktop/All: restrict to digits only + persist value
    input.addEventListener('input', () => {
      const before = input.value;
      const latin = toLatinDigits(before);
      const filtered = numericOnly(latin);
      if (before !== filtered) input.value = filtered;

      // Persist
      question._value = input.value;
    });

    // Block non-digit keys (extra safety)
    input.addEventListener('keydown', (e) => {
      const allowed = [
        'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
        'Tab', 'Home', 'End', 'Enter'
      ];
      if (allowed.includes(e.key)) return;
      if (e.ctrlKey || e.metaKey) return;
      if (!/^[0-9]$/.test(e.key)) e.preventDefault();
    });
  } else {
    // Text mode: persist as user types
    input.addEventListener('input', () => {
      question._value = input.value;
    });
  }

  /* ---------- Enter/Go triggers "Ù…ØªØ§Ø¨Ø¹Ø©" ---------- */
  input.addEventListener('keydown', (e) => {
    if (e.key !== 'Enter') return;
    if (e.shiftKey) return;

    e.preventDefault();

    // Find the single main button "Ù…ØªØ§Ø¨Ø¹Ø©" inside current concept
    const conceptBody = mountEl.closest('.concept-body') || mountEl.closest('.card') || document;
    const btn = conceptBody.querySelector('.lesson-nav .btn');

    if (btn && typeof btn.click === 'function') {
      btn.click();
    }
  });

  /* ---------- Mobile keyboard overlap fix ---------- */
  const isTouchLikely =
    ('ontouchstart' in window) ||
    (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);

  let vvHandler = null;

  function ensureVisible() {
    // Delay to allow keyboard to open and viewport to resize
    setTimeout(() => {
      const vv = window.visualViewport;

      // Determine current visible bottom in layout viewport coordinates
      let visibleBottomY;
      if (vv) {
        visibleBottomY = vv.pageTop + vv.height;
      } else {
        visibleBottomY = window.scrollY + window.innerHeight;
      }

      // âœ… IMPORTANT: use the whole question box bottom, not just the input
      const qWrap = input.closest('.question-wrap') || input;
      const rect = qWrap.getBoundingClientRect();
      const targetBottomY = window.scrollY + rect.bottom;

      // Comfortable margin (bigger when keyboard is open)
      let extra = 18;
      if (vv) {
        const kb = Math.max(0, window.innerHeight - vv.height); // approximate keyboard height
        // raise more when keyboard is big
        extra += Math.min(160, Math.max(60, Math.round(kb * 0.35)));
      } else {
        extra += 60;
      }

      if (targetBottomY + extra > visibleBottomY) {
        const delta = (targetBottomY + extra) - visibleBottomY;
        window.scrollBy({ top: delta, left: 0, behavior: 'smooth' });
      }
    }, 260);
  }

  function onFocus() {
    if (!isTouchLikely) return;

    ensureVisible();

    // Also react to viewport changes while keyboard is animating
    const vv = window.visualViewport;
    if (vv && !vvHandler) {
      vvHandler = () => ensureVisible();
      vv.addEventListener('resize', vvHandler);
      vv.addEventListener('scroll', vvHandler);
    }
  }

  function onBlur() {
    const vv = window.visualViewport;
    if (vv && vvHandler) {
      vv.removeEventListener('resize', vvHandler);
      vv.removeEventListener('scroll', vvHandler);
      vvHandler = null;
    }
  }

  input.addEventListener('focus', onFocus);
  input.addEventListener('blur', onBlur);

  /* ---------- Check ---------- */
  function check() {
    const rawUser = input.value ?? '';
    const rawAns = question.answer ?? '';

    // Persist before checking (safety)
    question._value = rawUser;

    if (expectsNumber) {
      const userDigits = numericOnly(toLatinDigits(rawUser));
      const ansDigits = numericOnly(toLatinDigits(rawAns));

      const userNum = userDigits === '' ? NaN : Number(userDigits);
      const ansNum = ansDigits === '' ? NaN : Number(ansDigits);

      const ok = Number.isFinite(userNum) && Number.isFinite(ansNum) && userNum === ansNum;

      feedback.textContent = ok ? 'Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø© âœ…' : 'Ù…Ø´ ØµØ­ÙŠØ­ØŒ Ø¬Ø±Ù‘Ø¨ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©';
      feedback.classList.toggle('ok', ok);
      feedback.classList.toggle('err', !ok);

      // âœ… After checking (and possible solution injection), ensure visibility again
      if (!ok) {
        setTimeout(() => ensureVisible(), 80);
      }
      return ok;
    }

    // text mode
    const user = normalizeSpaces(rawUser);
    const ans = normalizeSpaces(rawAns);

    const ok = user !== '' && user === ans;

    feedback.textContent = ok ? 'Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø© âœ…' : 'Ù…Ø´ ØµØ­ÙŠØ­ØŒ Ø¬Ø±Ù‘Ø¨ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©';
    feedback.classList.toggle('ok', ok);
    feedback.classList.toggle('err', !ok);

    // âœ… After checking (and possible solution injection), ensure visibility again
    if (!ok) {
      setTimeout(() => ensureVisible(), 80);
    }
    return ok;
  }

  return { check };
}

math/public/assets/js/questions/match.js
/* =========================================================
   match.js â€” Matching Question (Structure Only - Phase 2)
   - For now: renders layout and always returns false
   ========================================================= */

export function renderMatchQuestion({ mountEl, question }) {
  mountEl.innerHTML = '';

  const wrap = document.createElement('div');
  wrap.className = 'q q-match';

  const left = document.createElement('div');
  left.className = 'col';

  const right = document.createElement('div');
  right.className = 'col';

  (question.left || []).forEach((t) => {
    const item = document.createElement('div');
    item.className = 'item';
    item.textContent = t;
    left.appendChild(item);
  });

  (question.right || []).forEach((t) => {
    const item = document.createElement('div');
    item.className = 'item';
    item.textContent = t;
    right.appendChild(item);
  });

  wrap.appendChild(left);
  wrap.appendChild(right);

  mountEl.appendChild(wrap);

  function check() {
    // Phase 2: implement drag/select matching logic
    return false;
  }

  return { check };
}

math/public/assets/js/questions/mcq.js
/* =========================================================
   mcq.js â€” Multiple Choice Question (Single Correct)
   - Fix: enforce single selection by using one shared radio group name

   UPDATE (2026-01-14):
   - Persist MCQ selection across engine re-renders using question._selectedIndex
   ========================================================= */

export function renderMcqQuestion({ mountEl, question }) {
  mountEl.innerHTML = '';

  const wrap = document.createElement('div');
  wrap.className = 'q q-mcq';

  const desc = document.createElement('div');
  desc.className = 'q-desc';
  desc.textContent = question.text || '';

  wrap.appendChild(desc);

  // Restore previous selection (if any)
  let selectedIndex = (typeof question._selectedIndex === 'number')
    ? question._selectedIndex
    : null;

  // IMPORTANT: one shared group name for all choices (prevents multi-select)
  const groupName = `mcq-${Math.random().toString(36).slice(2)}`;

  (question.choices || []).forEach((choice, idx) => {
    const label = document.createElement('label');
    label.className = 'choice';

    const radio = document.createElement('input');
    radio.type = 'radio';
    radio.name = groupName;
    radio.value = String(idx);

    // Apply restored selection
    if (selectedIndex === idx) {
      radio.checked = true;
    }

    const span = document.createElement('span');
    span.textContent = choice;

    // Keep selectedIndex in sync + persist on question object
    radio.addEventListener('change', () => {
      selectedIndex = idx;
      question._selectedIndex = idx;
    });

    label.appendChild(radio);
    label.appendChild(span);

    wrap.appendChild(label);
  });

  const feedback = document.createElement('div');
  feedback.className = 'q-feedback';
  wrap.appendChild(feedback);

  mountEl.appendChild(wrap);

  function check() {
    // Persist selection (safety)
    if (typeof selectedIndex === 'number') {
      question._selectedIndex = selectedIndex;
    }

    const ok = selectedIndex === question.correctIndex;

    feedback.textContent = ok
      ? 'Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø© âœ…'
      : 'Ø¥Ø¬Ø§Ø¨Ø© Ø®Ø§Ø·Ø¦Ø© âŒ Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ©';

    feedback.classList.toggle('ok', ok);
    feedback.classList.toggle('err', !ok);

    // visual mark
    const choicesEls = wrap.querySelectorAll('.choice');
    choicesEls.forEach((el, i) => {
      el.classList.remove('correct', 'wrong');
      if (selectedIndex != null) {
        if (i === question.correctIndex) el.classList.add('correct');
        else if (i === selectedIndex) el.classList.add('wrong');
      }
    });

    return ok;
  }

  return { check };
}

math/public/assets/js/questions/registry.js
/* =========================================================
   registry.js â€” Question Type Registry
   - renderQuestion({ mountEl, question }) => { check() }
   ========================================================= */

import { renderInputQuestion } from './input.js';
import { renderMcqQuestion } from './mcq.js';
import { renderMatchQuestion } from './match.js';

const REGISTRY = {
  input: renderInputQuestion,
  mcq: renderMcqQuestion,
  match: renderMatchQuestion, // structure only for now
};

export function renderQuestion({ mountEl, question }) {
  if (!question || !question.type) {
    throw new Error('Ø³Ø¤Ø§Ù„ ØºÙŠØ± ØµØ§Ù„Ø­: type Ù…ÙÙ‚ÙˆØ¯');
  }

  const renderer = REGISTRY[question.type];
  if (!renderer) {
    throw new Error(`Ù†ÙˆØ¹ Ø³Ø¤Ø§Ù„ ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…: ${question.type}`);
  }

  return renderer({ mountEl, question });
}

export function registerQuestionType(type, renderer) {
  REGISTRY[type] = renderer;
}

math/public/assets/js/ui/text.js
/* =========================================================
   text.js â€” Default Hint & Encouragement Texts (Arabic)
   Used when JSON does not provide custom text
   ========================================================= */

/* ---------- Encouragement (after success) ---------- */
export const ENCOURAGEMENTS = [
  'Ø±Ø§Ø¦Ø¹ ğŸ‘ ÙƒÙ…Ù„ Ù‡ÙŠÙƒ!',
  'Ø¥Ø¬Ø§Ø¨Ø© ØµØ­ÙŠØ­Ø© ğŸ‘',
  'Ù…Ù…ØªØ§Ø²! ÙˆØ§Ø¶Ø­ Ø¥Ù†Ùƒ ÙØ§Ù‡Ù….',
  'Ø£Ø­Ø³Ù†Øª ğŸŒŸ',
  'ØªÙ…Ø§Ù…ØŒ Ù†Ù†ØªÙ‚Ù„ Ù„Ù„ÙŠ Ø¨Ø¹Ø¯Ù‡Ø§.'
];

/* ---------- Hints (progressive) ---------- */
export const DEFAULT_HINTS = [
  'Ø¬Ø±Ù‘Ø¨ ØªÙÙƒÙ‘Ø± Ø¨Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø¨Ø§Ù„Ø³Ø¤Ø§Ù„.',
  'Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù…Ø«Ø§Ù„ Ø§Ù„Ù…Ø­Ù„ÙˆÙ„ ÙÙˆÙ‚ØŒ ÙÙŠÙ‡ Ù…ÙØªØ§Ø­ Ø§Ù„Ø­Ù„.',
  'Ø±ÙƒÙ‘Ø² Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø¨Ø§Ù„Ø¶Ø¨Ø·ØŒ Ø¨Ø¯ÙˆÙ† Ø²ÙŠØ§Ø¯Ø©.'
];

/* ---------- Strong Hint (last attempt) ---------- */
export const FINAL_HINT = 'Ø®Ø° Ù†ÙØ³ ğŸ˜Œ ÙˆØ±Ø§Ø¬Ø¹ Ø§Ù„Ù…Ø¹Ø·ÙŠØ§Øª Ø¨Ù‡Ø¯ÙˆØ¡ØŒ Ø§Ù„Ø­Ù„ Ø£Ø¨Ø³Ø· Ù…Ù…Ø§ ØªØªÙˆÙ‚Ø¹.';

/* ---------- Helpers ---------- */
export function pickRandom(list = []) {
  if (!list.length) return '';
  return list[Math.floor(Math.random() * list.length)];
}

math/public/assets/js/ui/toast.js
/* =========================================================
   toast.js â€” Material Toast with Countdown Bar
   API: showToast(title, msg, type='info', duration=3000)

   UPDATE (2026-01-14):
   - Host is pinned to TOP of the VISUAL viewport (not the layout viewport)
     using visualViewport.offsetTop/offsetLeft + height/width.
   - This avoids cases where toast appears "too high" and requires scrolling
     to reveal it on mobile browsers.
   ========================================================= */

let hostEl = null;
let activeToast = null;
let rafId = null;
let bound = false;

function ensureHost() {
  if (hostEl) return hostEl;

  hostEl = document.createElement('div');
  hostEl.className = 'toast-host';
  document.body.appendChild(hostEl);

  updateHostToVisualViewport();

  if (!bound) {
    bound = true;

    // Resize/orientation changes
    window.addEventListener('resize', updateHostToVisualViewport, { passive: true });
    window.addEventListener('scroll', updateHostToVisualViewport, { passive: true });

    // Mobile browser UI + keyboard changes
    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', updateHostToVisualViewport, { passive: true });
      window.visualViewport.addEventListener('scroll', updateHostToVisualViewport, { passive: true });
    }
  }

  return hostEl;
}

function updateHostToVisualViewport() {
  if (!hostEl) return;

  const vv = window.visualViewport;

  // Default (no VisualViewport support)
  let top = 0;
  let left = 0;
  let width = window.innerWidth;
  let height = window.innerHeight;

  if (vv) {
    top = Math.round(vv.offsetTop || 0);
    left = Math.round(vv.offsetLeft || 0);
    width = Math.round(vv.width || window.innerWidth);
    height = Math.round(vv.height || window.innerHeight);
  }

  // Place host at the top of the VISUAL viewport.
  // We keep position:fixed + inset:0 in CSS, and move the whole host.
  hostEl.style.transform = `translate(${left}px, ${top}px)`;

  // Limit interactions area to the visible viewport (optional but clean)
  hostEl.style.width = `${width}px`;
  hostEl.style.height = `${height}px`;
}

function iconSvg(type) {
  const common = (path) => `
    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      <path d="${path}"></path>
    </svg>
  `;

  if (type === 'success') {
    return common('M9 16.2l-3.5-3.5L4 14.2l5 5L20 8.2l-1.5-1.5z');
  }
  if (type === 'warning') {
    return common('M1 21h22L12 2 1 21zm12-3h-2v2h2v-2zm0-8h-2v6h2V10z');
  }
  if (type === 'danger' || type === 'error') {
    return common('M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z');
  }
  // info
  return common('M11 7h2v2h-2V7zm0 4h2v8h-2v-8zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2z');
}

function cleanup() {
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
  if (activeToast) {
    activeToast.remove();
    activeToast = null;
  }
}

function animateBar(barEl, duration) {
  const start = performance.now();

  const tick = (now) => {
    const elapsed = now - start;
    const t = Math.min(1, elapsed / duration);
    barEl.style.transform = `scaleX(${t})`;
    if (t < 1) {
      rafId = requestAnimationFrame(tick);
    }
  };

  rafId = requestAnimationFrame(tick);
}

export function showToast(title, msg, type = 'info', duration = 3000) {
  ensureHost();

  // Refresh position each time (mobile UI can change between toasts)
  updateHostToVisualViewport();

  // replace any existing toast (single toast policy)
  cleanup();

  const toast = document.createElement('div');
  toast.className = 'toast';
  toast.dataset.type = type;

  toast.innerHTML = `
    <div class="toast-inner">
      <div class="toast-ic">${iconSvg(type)}</div>
      <div class="toast-content">
        <p class="toast-title">${escapeHtml(String(title || ''))}</p>
        <p class="toast-msg">${escapeHtml(String(msg || ''))}</p>
      </div>
    </div>
    <div class="toast-bar"><i></i></div>
  `;

  hostEl.appendChild(toast);
  activeToast = toast;

  requestAnimationFrame(() => {
    toast.classList.add('is-show');
  });

  const bar = toast.querySelector('.toast-bar > i');
  if (bar) animateBar(bar, duration);

  window.setTimeout(() => {
    if (!activeToast) return;
    activeToast.classList.remove('is-show');
    window.setTimeout(() => cleanup(), 260);
  }, duration);
}

function escapeHtml(s) {
  return s
    .replaceAll('&', '&amp;')
    .replaceAll('<', '&lt;')
    .replaceAll('>', '&gt;')
    .replaceAll('"', '&quot;')
    .replaceAll("'", '&#039;');
}

math/api/_migrations/001_card_completions.sql
IF OBJECT_ID('dbo.CardCompletions', 'U') IS NULL
BEGIN
  CREATE TABLE dbo.CardCompletions (
    CompletionId INT IDENTITY(1,1) PRIMARY KEY,
    StudentId NVARCHAR(20) NOT NULL,
    Week INT NOT NULL,
    FinalScore INT NOT NULL,
    CompletedAt DATETIME NOT NULL DEFAULT GETDATE(),
    CONSTRAINT FK_CardCompletions_Students FOREIGN KEY (StudentId)
      REFERENCES dbo.Students(StudentId),
    CONSTRAINT FK_CardCompletions_Weeks FOREIGN KEY (Week)
      REFERENCES dbo.Weeks(Week),
    CONSTRAINT UQ_CardCompletions_StudentWeek UNIQUE (StudentId, Week)
  );

  CREATE INDEX IX_CardCompletions_Week ON dbo.CardCompletions (Week);
  CREATE INDEX IX_CardCompletions_StudentId ON dbo.CardCompletions (StudentId);
END

math/api/_shared/db.js
const sql = require('mssql');

let pool;

async function getPool() {
  if (pool) {
    return pool;
  }

  const connectionString = process.env.SQL_CONNECTION_STRING;
  if (!connectionString) {
    throw new Error('SQL_CONNECTION_STRING is not set.');
  }

  pool = await sql.connect(connectionString);
  pool.on('error', () => {
    pool = null;
  });
  return pool;
}

module.exports = {
  sql,
  getPool
};

math/api/astu/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "put"],
      "route": "astu"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/astu/index.js
const { getPool, sql } = require('../_shared/db');

function parseBody(req) {
  if (req.body && typeof req.body === 'object') {
    return req.body;
  }

  if (req.rawBody) {
    try {
      return JSON.parse(req.rawBody);
    } catch (error) {
      return null;
    }
  }

  return null;
}

function normalizeDigits(value) {
  const map = {
    'Ù ': '0',
    'Ù¡': '1',
    'Ù¢': '2',
    'Ù£': '3',
    'Ù¤': '4',
    'Ù¥': '5',
    'Ù¦': '6',
    'Ù§': '7',
    'Ù¨': '8',
    'Ù©': '9',
    'Û°': '0',
    'Û±': '1',
    'Û²': '2',
    'Û³': '3',
    'Û´': '4',
    'Ûµ': '5',
    'Û¶': '6',
    'Û·': '7',
    'Û¸': '8',
    'Û¹': '9'
  };

  return String(value)
    .split('')
    .map((char) => map[char] ?? char)
    .join('');
}

module.exports = async function (context, req) {
  try {
    const dbPool = await getPool();

    if (req.method === 'GET') {
      const result = await dbPool
        .request()
        .query(
          `SELECT StudentId, BirthYear, FirstName, FullName, Class
           FROM dbo.Students
           ORDER BY StudentId`
        );

      context.res = {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: true, students: result.recordset }
      };
      return;
    }

    if (req.method !== 'PUT') {
      context.res = {
        status: 405,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, message: 'Method not allowed.' }
      };
      return;
    }

    const payload = parseBody(req);
    if (!payload || !Array.isArray(payload.students)) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, message: 'BAD_REQUEST' }
      };
      return;
    }

    const normalized = payload.students.map((student) => {
      const studentId = normalizeDigits(String(student.StudentId ?? student.studentId ?? student.id ?? '').trim());
      const birthYear = normalizeDigits(String(student.BirthYear ?? student.birthYear ?? '').trim());
      return {
        StudentId: studentId,
        BirthYear: birthYear,
        FirstName: String(student.FirstName ?? student.firstName ?? '').trim(),
        FullName: String(student.FullName ?? student.fullName ?? '').trim(),
        Class: String(student.Class ?? student.class ?? '').trim()
      };
    });

    const hasInvalid = normalized.some(
      (student) =>
        !student.StudentId ||
        !student.BirthYear ||
        !student.FirstName ||
        !student.FullName ||
        !student.Class
    );

    if (hasInvalid) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, message: 'BAD_REQUEST' }
      };
      return;
    }

    const studentIds = normalized.map((student) => student.StudentId);
    const uniqueIds = new Set(studentIds);
    if (uniqueIds.size !== studentIds.length) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, message: 'DUPLICATE_STUDENT_ID' }
      };
      return;
    }

    const transaction = new sql.Transaction(dbPool);
    await transaction.begin();

    try {
      const existing = await new sql.Request(transaction)
        .query('SELECT StudentId FROM dbo.Students');
      const existingIds = new Set(existing.recordset.map((row) => row.StudentId));
      const incomingIds = new Set(normalized.map((student) => student.StudentId));

      for (const student of normalized) {
        const updateRequest = new sql.Request(transaction);
        const updateResult = await updateRequest
          .input('studentId', sql.NVarChar(20), student.StudentId)
          .input('birthYear', sql.NVarChar(10), student.BirthYear)
          .input('firstName', sql.NVarChar(100), student.FirstName)
          .input('fullName', sql.NVarChar(200), student.FullName)
          .input('class', sql.NVarChar(20), student.Class)
          .query(
            `UPDATE dbo.Students
             SET BirthYear = @birthYear, FirstName = @firstName, FullName = @fullName, Class = @class
             WHERE StudentId = @studentId`
          );

        if (!updateResult.rowsAffected?.[0]) {
          await updateRequest.query(
            `INSERT INTO dbo.Students (StudentId, BirthYear, FirstName, FullName, Class)
             VALUES (@studentId, @birthYear, @firstName, @fullName, @class)`
          );
        }
      }

      const toDelete = Array.from(existingIds).filter((id) => !incomingIds.has(id));
      for (const studentId of toDelete) {
        await new sql.Request(transaction)
          .input('deleteId', sql.NVarChar(20), studentId)
          .query('DELETE FROM dbo.Students WHERE StudentId = @deleteId');
      }

      await transaction.commit();
    } catch (error) {
      context.log('astu upsert failed', { message: error.message });
      await transaction.rollback();
      throw error;
    }

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: true }
    };
  } catch (error) {
    context.log('astu request failed', { message: error.message });
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, message: 'DB_ERROR', detail: error.message }
    };
  }
};

math/api/cards-mng/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "put"],
      "route": "cards-mng"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/cards-mng/index.js
const { getPool, sql } = require('../_shared/db');

function parseBody(req) {
  if (req.body && typeof req.body === 'object') {
    return req.body;
  }

  if (req.rawBody) {
    try {
      return JSON.parse(req.rawBody);
    } catch (error) {
      return null;
    }
  }

  return null;
}

module.exports = async function (context, req) {
  try {
    const dbPool = await getPool();

    if (req.method === 'GET') {
      const result = await dbPool
        .request()
        .query('SELECT Week, Title, PrereqWeek FROM dbo.Cards ORDER BY Week');

      context.res = {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: result.recordset
      };
      return;
    }

    if (req.method !== 'PUT') {
      context.res = {
        status: 405,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'Method not allowed.' }
      };
      return;
    }

    const payload = parseBody(req);
    if (!payload || !Array.isArray(payload.cards)) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'cards array is required.' }
      };
      return;
    }

    const normalized = payload.cards
      .map((card) => ({
        week: Number(card.week),
        title: String(card.title || '').trim(),
        prereqWeek: card.prereq == null || card.prereq === '' ? null : Number(card.prereq)
      }))
      .filter((card) => Number.isInteger(card.week) && card.title);

    const transaction = new sql.Transaction(dbPool);
    await transaction.begin();

    try {
      const existing = await new sql.Request(transaction)
        .query('SELECT Week FROM dbo.Cards');
      const existingWeeks = new Set(existing.recordset.map((row) => row.Week));
      const incomingWeeks = new Set(normalized.map((card) => card.week));
      const allowedPrereqs = new Set([...existingWeeks, ...incomingWeeks]);
      const invalidPrereq = normalized.find(
        (card) => card.prereqWeek != null && !allowedPrereqs.has(card.prereqWeek)
      );

      if (invalidPrereq) {
        context.res = {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
          body: { ok: false, error: 'INVALID_PREREQ_WEEK' }
        };
        await transaction.rollback();
        return;
      }

      for (const card of normalized) {
        const updateRequest = new sql.Request(transaction);
        const updateResult = await updateRequest
          .input('week', sql.Int, card.week)
          .input('title', sql.NVarChar(300), card.title)
          .input('prereqWeek', sql.Int, card.prereqWeek)
          .query(
            `UPDATE dbo.Cards
             SET Title = @title, PrereqWeek = @prereqWeek
             WHERE Week = @week`
          );

        if (!updateResult.rowsAffected?.[0]) {
          await updateRequest.query(
            `INSERT INTO dbo.Cards (Week, Title, PrereqWeek)
             VALUES (@week, @title, @prereqWeek)`
          );
        }
      }

      const toDelete = Array.from(existingWeeks).filter((week) => !incomingWeeks.has(week));
      for (const week of toDelete) {
        await new sql.Request(transaction)
          .input('deleteWeek', sql.Int, week)
          .query('DELETE FROM dbo.Cards WHERE Week = @deleteWeek');
      }

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: true }
    };
  } catch (error) {
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, error: error.message }
    };
  }
};

math/api/cards/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get"],
      "route": "cards"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/cards/index.js
const { getPool } = require('../_shared/db');

module.exports = async function (context) {
  try {
    const dbPool = await getPool();
    const result = await dbPool
      .request()
      .query('SELECT Week, Title, PrereqWeek FROM dbo.Cards ORDER BY Week');
    const normalized = result.recordset.map((card) => ({
      week: card.Week,
      title: card.Title,
      prereq: card.PrereqWeek
    }));
    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: normalized
    };
  } catch (error) {
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, error: error.message }
    };
  }
};

math/api/health/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get"],
      "route": "health"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/health/index.js
const { getPool } = require('../_shared/db');

module.exports = async function (context) {
  try {
    const dbPool = await getPool();
    await dbPool.request().query('SELECT 1 AS ok');
    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: true, db: true }
    };
  } catch (error) {
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, db: false, error: error.message }
    };
  }
};

math/api/host.json
{
  "version": "2.0"
}

math/api/package.json
{
  "name": "math-api",
  "version": "1.0.0",
  "private": true,
  "description": "Azure Functions API for Math app",
  "main": "index.js",
  "dependencies": {
    "mssql": "^10.0.2"
  }
}

math/api/progress-complete/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["post"],
      "route": "progress/complete"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/progress-complete/index.js
const { getPool, sql } = require('../_shared/db');

function normalizeDigits(value) {
  const map = {
    'Ù ': '0',
    'Ù¡': '1',
    'Ù¢': '2',
    'Ù£': '3',
    'Ù¤': '4',
    'Ù¥': '5',
    'Ù¦': '6',
    'Ù§': '7',
    'Ù¨': '8',
    'Ù©': '9',
    'Û°': '0',
    'Û±': '1',
    'Û²': '2',
    'Û³': '3',
    'Û´': '4',
    'Ûµ': '5',
    'Û¶': '6',
    'Û·': '7',
    'Û¸': '8',
    'Û¹': '9'
  };

  return String(value)
    .split('')
    .map((char) => map[char] ?? char)
    .join('');
}

function parseBody(req) {
  if (req.body && typeof req.body === 'object') {
    return req.body;
  }

  if (req.rawBody) {
    try {
      return JSON.parse(req.rawBody);
    } catch (error) {
      return null;
    }
  }

  return null;
}

module.exports = async function (context, req) {
  try {
    const payload = parseBody(req);
    if (!payload) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'Invalid JSON body.' }
      };
      return;
    }

    const studentId =
      typeof payload.studentId === 'string'
        ? normalizeDigits(payload.studentId).trim()
        : '';
    const week = Number(payload.week);
    const finalScore = Number(payload.finalScore);

    if (!studentId) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'studentId is required.' }
      };
      return;
    }

    if (!Number.isInteger(week)) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'week must be an integer.' }
      };
      return;
    }

    if (!Number.isInteger(finalScore) || finalScore < 0 || finalScore > 100) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'finalScore must be an integer between 0 and 100.' }
      };
      return;
    }

    const dbPool = await getPool();

    const studentResult = await dbPool
      .request()
      .input('studentId', sql.NVarChar(20), studentId)
      .query('SELECT StudentId FROM dbo.Students WHERE StudentId = @studentId');

    if (!studentResult.recordset.length) {
      context.res = {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'Student not found.' }
      };
      return;
    }

    const weekResult = await dbPool
      .request()
      .input('week', sql.Int, week)
      .query('SELECT Week FROM dbo.Weeks WHERE Week = @week');

    if (!weekResult.recordset.length) {
      context.res = {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'Week not found.' }
      };
      return;
    }

    const completionResult = await dbPool
      .request()
      .input('studentId', sql.NVarChar(20), studentId)
      .input('week', sql.Int, week)
      .input('finalScore', sql.Int, finalScore)
      .query(
        `IF EXISTS (SELECT 1 FROM dbo.CardCompletions WHERE StudentId = @studentId AND Week = @week)
         BEGIN
           UPDATE dbo.CardCompletions
           SET FinalScore = @finalScore,
               CompletedAt = GETDATE()
           WHERE StudentId = @studentId AND Week = @week;
         END
         ELSE
         BEGIN
           INSERT INTO dbo.CardCompletions (StudentId, Week, FinalScore)
           VALUES (@studentId, @week, @finalScore);
         END

         SELECT StudentId, Week, FinalScore, CompletedAt
         FROM dbo.CardCompletions
         WHERE StudentId = @studentId AND Week = @week;`
      );

    const record = completionResult.recordset[0];

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: {
        ok: true,
        studentId: record.StudentId,
        week: record.Week,
        finalScore: record.FinalScore,
        completedAt: record.CompletedAt
      }
    };
  } catch (error) {
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, error: error.message }
    };
  }
};

math/api/progress-completed/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get"],
      "route": "progress/completed"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/progress-completed/index.js
const { getPool, sql } = require('../_shared/db');

function normalizeDigits(value) {
  const map = {
    'Ù ': '0',
    'Ù¡': '1',
    'Ù¢': '2',
    'Ù£': '3',
    'Ù¤': '4',
    'Ù¥': '5',
    'Ù¦': '6',
    'Ù§': '7',
    'Ù¨': '8',
    'Ù©': '9',
    'Û°': '0',
    'Û±': '1',
    'Û²': '2',
    'Û³': '3',
    'Û´': '4',
    'Ûµ': '5',
    'Û¶': '6',
    'Û·': '7',
    'Û¸': '8',
    'Û¹': '9'
  };

  return String(value)
    .split('')
    .map((char) => map[char] ?? char)
    .join('');
}

module.exports = async function (context, req) {
  try {
    const studentId =
      typeof req.query.studentId === 'string' ? normalizeDigits(req.query.studentId).trim() : '';

    if (!studentId) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'studentId is required.' }
      };
      return;
    }

    const dbPool = await getPool();
    const result = await dbPool
      .request()
      .input('studentId', sql.NVarChar(20), studentId)
      .query(
        'SELECT Week, FinalScore, CompletedAt FROM dbo.CardCompletions WHERE StudentId = @studentId ORDER BY CompletedAt DESC'
      );

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: result.recordset
    };
  } catch (error) {
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, error: error.message }
    };
  }
};

math/api/student-login/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["post"],
      "route": "students/login"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/student-login/index.js
const { getPool, sql } = require('../_shared/db');

function parseBody(req) {
  if (req.body && typeof req.body === 'object') {
    return req.body;
  }

  if (req.rawBody) {
    try {
      return JSON.parse(req.rawBody);
    } catch (error) {
      return null;
    }
  }

  return null;
}

function toLatinDigits(value) {
  const map = {
    'Ù ': '0', 'Ù¡': '1', 'Ù¢': '2', 'Ù£': '3', 'Ù¤': '4',
    'Ù¥': '5', 'Ù¦': '6', 'Ù§': '7', 'Ù¨': '8', 'Ù©': '9',
    'Û°': '0', 'Û±': '1', 'Û²': '2', 'Û³': '3', 'Û´': '4',
    'Ûµ': '5', 'Û¶': '6', 'Û·': '7', 'Û¸': '8', 'Û¹': '9'
  };

  return String(value).replace(/[Ù -Ù©Û°-Û¹]/g, (digit) => map[digit] ?? digit);
}

module.exports = async function (context, req) {
  try {
    const payload = parseBody(req);
    if (!payload) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'Invalid JSON body.' }
      };
      return;
    }

    const studentId =
      typeof payload.studentId === 'string' ? toLatinDigits(payload.studentId).trim() : '';
    const birthYear =
      typeof payload.birthYear === 'string' ? toLatinDigits(payload.birthYear).trim() : '';

    if (!studentId || !birthYear) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'studentId and birthYear are required.' }
      };
      return;
    }

    const dbPool = await getPool();
    const result = await dbPool
      .request()
      .input('studentId', sql.NVarChar(20), studentId)
      .input('birthYear', sql.NVarChar(10), birthYear)
      .query(
        `SELECT TOP (1) StudentId, BirthYear, FirstName, FullName, Class
         FROM dbo.Students
         WHERE StudentId = @studentId AND BirthYear = @birthYear`
      );

    if (!result.recordset.length) {
      context.res = {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, message: 'INVALID_CREDENTIALS' }
      };
      return;
    }

    const student = result.recordset[0];

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: {
        ok: true,
        student: {
          StudentId: student.StudentId,
          BirthYear: student.BirthYear,
          FirstName: student.FirstName,
          FullName: student.FullName,
          Class: student.Class
        }
      }
    };
  } catch (error) {
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, message: 'DB_ERROR' }
    };
  }
};

math/api/week/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get", "put"],
      "route": "weeks/{week:int}"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/week/index.js
const { getPool, sql } = require('../_shared/db');

function parseBody(req) {
  if (req.body && typeof req.body === 'object') {
    return req.body;
  }

  if (req.rawBody) {
    try {
      return JSON.parse(req.rawBody);
    } catch (error) {
      return null;
    }
  }

  return null;
}

module.exports = async function (context, req) {
  try {
    const weekParam = Number(req.params.week);
    if (!Number.isInteger(weekParam)) {
      context.res = {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'Invalid week parameter.' }
      };
      return;
    }

    const dbPool = await getPool();

    if (req.method === 'PUT') {
      const payload = parseBody(req);
      if (!payload) {
        context.res = {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
          body: { ok: false, error: 'Invalid JSON body.' }
        };
        return;
      }

      const title = String(payload.title || '').trim();
      const prereq =
        payload.prereq == null || payload.prereq === '' ? null : Number(payload.prereq);

      if (!title) {
        context.res = {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
          body: { ok: false, error: 'title is required.' }
        };
        return;
      }

      if (prereq != null && !Number.isInteger(prereq)) {
        context.res = {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
          body: { ok: false, error: 'prereq must be an integer.' }
        };
        return;
      }

      const goals = Array.isArray(payload.goals) ? payload.goals : [];
      const prerequisites = Array.isArray(payload.prerequisites) ? payload.prerequisites : [];
      const concepts = Array.isArray(payload.concepts) ? payload.concepts : [];
      const assessment = payload.assessment && typeof payload.assessment === 'object'
        ? payload.assessment
        : null;

      const transaction = new sql.Transaction(dbPool);
      await transaction.begin();

      try {
        const upsertWeekRequest = new sql.Request(transaction);
        const updateWeekResult = await upsertWeekRequest
          .input('week', sql.Int, weekParam)
          .input('title', sql.NVarChar(300), title)
          .query(
            `UPDATE dbo.Weeks
             SET Title = @title
             WHERE Week = @week`
          );

        if (!updateWeekResult.rowsAffected?.[0]) {
          await upsertWeekRequest.query(
            `INSERT INTO dbo.Weeks (Week, Title)
             VALUES (@week, @title)`
          );
        }

        const upsertCardRequest = new sql.Request(transaction);
        const updateCardResult = await upsertCardRequest
          .input('week', sql.Int, weekParam)
          .input('title', sql.NVarChar(300), title)
          .input('prereq', sql.Int, prereq)
          .query(
            `UPDATE dbo.Cards
             SET Title = @title, PrereqWeek = @prereq
             WHERE Week = @week`
          );

        if (!updateCardResult.rowsAffected?.[0]) {
          await upsertCardRequest.query(
            `INSERT INTO dbo.Cards (Week, Title, PrereqWeek)
             VALUES (@week, @title, @prereq)`
          );
        }

        await new sql.Request(transaction)
          .input('week', sql.Int, weekParam)
          .query(
            `DELETE FROM dbo.FlowItemDetails
             WHERE FlowItemId IN (
               SELECT FlowItemId FROM dbo.FlowItems
               WHERE ConceptId IN (SELECT ConceptId FROM dbo.Concepts WHERE Week = @week)
             );
             DELETE FROM dbo.FlowItemHints
             WHERE FlowItemId IN (
               SELECT FlowItemId FROM dbo.FlowItems
               WHERE ConceptId IN (SELECT ConceptId FROM dbo.Concepts WHERE Week = @week)
             );
             DELETE FROM dbo.FlowItemChoices
             WHERE FlowItemId IN (
               SELECT FlowItemId FROM dbo.FlowItems
               WHERE ConceptId IN (SELECT ConceptId FROM dbo.Concepts WHERE Week = @week)
             );
             DELETE FROM dbo.FlowItems
             WHERE ConceptId IN (SELECT ConceptId FROM dbo.Concepts WHERE Week = @week);
             DELETE FROM dbo.Concepts WHERE Week = @week;
             DELETE FROM dbo.AssessmentQuestionChoices
             WHERE AssessmentQuestionId IN (
               SELECT AssessmentQuestionId FROM dbo.AssessmentQuestions
               WHERE AssessmentId IN (SELECT AssessmentId FROM dbo.Assessments WHERE Week = @week)
             );
             DELETE FROM dbo.AssessmentQuestions
             WHERE AssessmentId IN (SELECT AssessmentId FROM dbo.Assessments WHERE Week = @week);
             DELETE FROM dbo.Assessments WHERE Week = @week;
             DELETE FROM dbo.WeekGoals WHERE Week = @week;
             DELETE FROM dbo.WeekPrerequisites WHERE Week = @week;`
          );

        for (let index = 0; index < goals.length; index += 1) {
          const goalText = String(goals[index] || '').trim();
          if (!goalText) continue;
          await new sql.Request(transaction)
            .input('week', sql.Int, weekParam)
            .input('sortOrder', sql.Int, index)
            .input('goalText', sql.NVarChar(500), goalText)
            .query(
              `INSERT INTO dbo.WeekGoals (Week, SortOrder, GoalText)
               VALUES (@week, @sortOrder, @goalText)`
            );
        }

        for (let index = 0; index < prerequisites.length; index += 1) {
          const prereqText = String(prerequisites[index] || '').trim();
          if (!prereqText) continue;
          await new sql.Request(transaction)
            .input('week', sql.Int, weekParam)
            .input('sortOrder', sql.Int, index)
            .input('prereqText', sql.NVarChar(500), prereqText)
            .query(
              `INSERT INTO dbo.WeekPrerequisites (Week, SortOrder, PrerequisiteText)
               VALUES (@week, @sortOrder, @prereqText)`
            );
        }

        for (let conceptIndex = 0; conceptIndex < concepts.length; conceptIndex += 1) {
          const concept = concepts[conceptIndex] || {};
          const conceptTitle = String(concept.title || '').trim() || `Ù…ÙÙ‡ÙˆÙ… ${conceptIndex + 1}`;
          const flow = Array.isArray(concept.flow) ? concept.flow : [];

          const conceptResult = await new sql.Request(transaction)
            .input('week', sql.Int, weekParam)
            .input('sortOrder', sql.Int, conceptIndex)
            .input('title', sql.NVarChar(300), conceptTitle)
            .query(
              `INSERT INTO dbo.Concepts (Week, SortOrder, Title)
               OUTPUT INSERTED.ConceptId
               VALUES (@week, @sortOrder, @title)`
            );

          const conceptId = conceptResult.recordset[0]?.ConceptId;
          if (!conceptId) continue;

          for (let itemIndex = 0; itemIndex < flow.length; itemIndex += 1) {
            const item = flow[itemIndex] || {};
            const itemType = String(item.type || 'note').trim().toLowerCase();

            const flowResult = await new sql.Request(transaction)
              .input('conceptId', sql.Int, conceptId)
              .input('sortOrder', sql.Int, itemIndex)
              .input('itemType', sql.NVarChar(50), itemType)
              .input('itemText', sql.NVarChar(sql.MAX), item.text ?? null)
              .input('itemTitle', sql.NVarChar(300), item.title ?? null)
              .input('itemDescription', sql.NVarChar(sql.MAX), item.description ?? null)
              .input('itemUrl', sql.NVarChar(500), item.url ?? null)
              .input('answer', sql.NVarChar(sql.MAX), item.answer ?? null)
              .input('correctIndex', sql.Int, item.correctIndex ?? null)
              .input('solution', sql.NVarChar(sql.MAX), item.solution ?? null)
              .query(
                `INSERT INTO dbo.FlowItems (
                   ConceptId, SortOrder, ItemType, ItemText, ItemTitle,
                   ItemDescription, ItemUrl, Answer, CorrectIndex, Solution
                 )
                 OUTPUT INSERTED.FlowItemId
                 VALUES (
                   @conceptId, @sortOrder, @itemType, @itemText, @itemTitle,
                   @itemDescription, @itemUrl, @answer, @correctIndex, @solution
                 )`
              );

            const flowItemId = flowResult.recordset[0]?.FlowItemId;
            if (!flowItemId) continue;

            const details = Array.isArray(item.details) ? item.details : [];
            for (let detailIndex = 0; detailIndex < details.length; detailIndex += 1) {
              const detailText = String(details[detailIndex] || '').trim();
              if (!detailText) continue;
              await new sql.Request(transaction)
                .input('flowItemId', sql.Int, flowItemId)
                .input('sortOrder', sql.Int, detailIndex)
                .input('detailText', sql.NVarChar(sql.MAX), detailText)
                .query(
                  `INSERT INTO dbo.FlowItemDetails (FlowItemId, SortOrder, DetailText)
                   VALUES (@flowItemId, @sortOrder, @detailText)`
                );
            }

            const hints = Array.isArray(item.hints) ? item.hints : [];
            for (let hintIndex = 0; hintIndex < hints.length; hintIndex += 1) {
              const hintText = String(hints[hintIndex] || '').trim();
              if (!hintText) continue;
              await new sql.Request(transaction)
                .input('flowItemId', sql.Int, flowItemId)
                .input('sortOrder', sql.Int, hintIndex)
                .input('hintText', sql.NVarChar(sql.MAX), hintText)
                .query(
                  `INSERT INTO dbo.FlowItemHints (FlowItemId, SortOrder, HintText)
                   VALUES (@flowItemId, @sortOrder, @hintText)`
                );
            }

            const choices = Array.isArray(item.choices) ? item.choices : [];
            for (let choiceIndex = 0; choiceIndex < choices.length; choiceIndex += 1) {
              const choiceText = String(choices[choiceIndex] || '').trim();
              if (!choiceText) continue;
              await new sql.Request(transaction)
                .input('flowItemId', sql.Int, flowItemId)
                .input('sortOrder', sql.Int, choiceIndex)
                .input('choiceText', sql.NVarChar(500), choiceText)
                .query(
                  `INSERT INTO dbo.FlowItemChoices (FlowItemId, SortOrder, ChoiceText)
                   VALUES (@flowItemId, @sortOrder, @choiceText)`
                );
            }
          }
        }

        if (assessment && Array.isArray(assessment.questions) && assessment.questions.length) {
          const assessmentResult = await new sql.Request(transaction)
            .input('week', sql.Int, weekParam)
            .input('title', sql.NVarChar(300), String(assessment.title || '').trim())
            .input('description', sql.NVarChar(sql.MAX), String(assessment.description || '').trim())
            .query(
              `INSERT INTO dbo.Assessments (Week, Title, Description)
               OUTPUT INSERTED.AssessmentId
               VALUES (@week, @title, @description)`
            );

          const assessmentId = assessmentResult.recordset[0]?.AssessmentId;
          if (assessmentId) {
            for (let questionIndex = 0; questionIndex < assessment.questions.length; questionIndex += 1) {
              const question = assessment.questions[questionIndex] || {};
              const questionType = String(question.type || 'input').trim().toLowerCase();
              const questionText = String(question.text || '').trim();
              const questionPoints = Number.isFinite(question.points) ? Number(question.points) : 1;
              const answer = questionType === 'mcq' ? null : String(question.answer ?? '').trim();
              const correctIndex =
                questionType === 'mcq' && Number.isFinite(question.correctIndex)
                  ? Number(question.correctIndex)
                  : null;

              const questionResult = await new sql.Request(transaction)
                .input('assessmentId', sql.Int, assessmentId)
                .input('sortOrder', sql.Int, questionIndex)
                .input('questionType', sql.NVarChar(50), questionType)
                .input('questionText', sql.NVarChar(sql.MAX), questionText)
                .input('answer', sql.NVarChar(sql.MAX), answer)
                .input('points', sql.Int, questionPoints)
                .input('correctIndex', sql.Int, correctIndex)
                .query(
                  `INSERT INTO dbo.AssessmentQuestions (
                     AssessmentId, SortOrder, QuestionType, QuestionText, Answer, Points, CorrectIndex
                   )
                   OUTPUT INSERTED.AssessmentQuestionId
                   VALUES (
                     @assessmentId, @sortOrder, @questionType, @questionText, @answer, @points, @correctIndex
                   )`
                );

              const assessmentQuestionId = questionResult.recordset[0]?.AssessmentQuestionId;
              if (assessmentQuestionId && Array.isArray(question.choices)) {
                for (let choiceIndex = 0; choiceIndex < question.choices.length; choiceIndex += 1) {
                  const choiceText = String(question.choices[choiceIndex] || '').trim();
                  if (!choiceText) continue;
                  await new sql.Request(transaction)
                    .input('assessmentQuestionId', sql.Int, assessmentQuestionId)
                    .input('sortOrder', sql.Int, choiceIndex)
                    .input('choiceText', sql.NVarChar(500), choiceText)
                    .query(
                      `INSERT INTO dbo.AssessmentQuestionChoices (AssessmentQuestionId, SortOrder, ChoiceText)
                       VALUES (@assessmentQuestionId, @sortOrder, @choiceText)`
                    );
                }
              }
            }
          }
        }

        await transaction.commit();
      } catch (error) {
        await transaction.rollback();
        throw error;
      }

      context.res = {
        status: 200,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: true }
      };
      return;
    }

    if (req.method !== 'GET') {
      context.res = {
        status: 405,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'Method not allowed.' }
      };
      return;
    }

    const weekResult = await dbPool
      .request()
      .input('week', sql.Int, weekParam)
      .query('SELECT Week, Title FROM dbo.Weeks WHERE Week = @week');

    if (!weekResult.recordset.length) {
      context.res = {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
        body: { ok: false, error: 'Week not found.' }
      };
      return;
    }

    const goalsResult = await dbPool
      .request()
      .input('week', sql.Int, weekParam)
      .query(
        'SELECT GoalId, Week, SortOrder, GoalText FROM dbo.WeekGoals WHERE Week = @week ORDER BY SortOrder'
      );

    const prerequisitesResult = await dbPool
      .request()
      .input('week', sql.Int, weekParam)
      .query(
        'SELECT PrerequisiteId, Week, SortOrder, PrerequisiteText FROM dbo.WeekPrerequisites WHERE Week = @week ORDER BY SortOrder'
      );

    const conceptsResult = await dbPool
      .request()
      .input('week', sql.Int, weekParam)
      .query('SELECT ConceptId, Week, SortOrder, Title FROM dbo.Concepts WHERE Week = @week ORDER BY SortOrder');

    const conceptIds = conceptsResult.recordset.map((concept) => concept.ConceptId);
    let flowItemsResult = { recordset: [] };
    let flowDetailsResult = { recordset: [] };
    let flowHintsResult = { recordset: [] };
    let flowChoicesResult = { recordset: [] };

    if (conceptIds.length) {
      const inClause = conceptIds.map((_, index) => `@concept${index}`).join(',');
      const flowRequest = dbPool.request();
      conceptIds.forEach((id, index) => {
        flowRequest.input(`concept${index}`, sql.Int, id);
      });

      flowItemsResult = await flowRequest.query(
        `SELECT FlowItemId, ConceptId, SortOrder, ItemType, ItemText, ItemTitle, ItemDescription, ItemUrl, Answer, CorrectIndex, Solution
         FROM dbo.FlowItems
         WHERE ConceptId IN (${inClause})
         ORDER BY ConceptId, SortOrder`
      );

      const flowItemIds = flowItemsResult.recordset.map((item) => item.FlowItemId);
      if (flowItemIds.length) {
        const itemClause = flowItemIds.map((_, index) => `@item${index}`).join(',');
        const detailRequest = dbPool.request();
        flowItemIds.forEach((id, index) => {
          detailRequest.input(`item${index}`, sql.Int, id);
        });

        flowDetailsResult = await detailRequest.query(
          `SELECT FlowItemDetailId, FlowItemId, SortOrder, DetailText
           FROM dbo.FlowItemDetails
           WHERE FlowItemId IN (${itemClause})
           ORDER BY FlowItemId, SortOrder`
        );

        const hintRequest = dbPool.request();
        flowItemIds.forEach((id, index) => {
          hintRequest.input(`item${index}`, sql.Int, id);
        });

        flowHintsResult = await hintRequest.query(
          `SELECT FlowItemHintId, FlowItemId, SortOrder, HintText
           FROM dbo.FlowItemHints
           WHERE FlowItemId IN (${itemClause})
           ORDER BY FlowItemId, SortOrder`
        );

        const choiceRequest = dbPool.request();
        flowItemIds.forEach((id, index) => {
          choiceRequest.input(`item${index}`, sql.Int, id);
        });

        flowChoicesResult = await choiceRequest.query(
          `SELECT FlowItemChoiceId, FlowItemId, SortOrder, ChoiceText
           FROM dbo.FlowItemChoices
           WHERE FlowItemId IN (${itemClause})
           ORDER BY FlowItemId, SortOrder`
        );
      }
    }

    const assessmentsResult = await dbPool
      .request()
      .input('week', sql.Int, weekParam)
      .query(
        'SELECT AssessmentId, Week, Title, Description FROM dbo.Assessments WHERE Week = @week ORDER BY AssessmentId'
      );

    const assessmentIds = assessmentsResult.recordset.map(
      (assessment) => assessment.AssessmentId
    );
    let assessmentQuestionsResult = { recordset: [] };
    let assessmentChoicesResult = { recordset: [] };

    if (assessmentIds.length) {
      const assessmentClause = assessmentIds.map((_, index) => `@assessment${index}`).join(',');
      const assessmentRequest = dbPool.request();
      assessmentIds.forEach((id, index) => {
        assessmentRequest.input(`assessment${index}`, sql.Int, id);
      });

      assessmentQuestionsResult = await assessmentRequest.query(
        `SELECT AssessmentQuestionId, AssessmentId, SortOrder, QuestionType, QuestionText, Answer, Points, CorrectIndex
         FROM dbo.AssessmentQuestions
         WHERE AssessmentId IN (${assessmentClause})
         ORDER BY AssessmentId, SortOrder`
      );

      const questionIds = assessmentQuestionsResult.recordset.map(
        (question) => question.AssessmentQuestionId
      );

      if (questionIds.length) {
        const questionClause = questionIds.map((_, index) => `@question${index}`).join(',');
        const questionRequest = dbPool.request();
        questionIds.forEach((id, index) => {
          questionRequest.input(`question${index}`, sql.Int, id);
        });

        assessmentChoicesResult = await questionRequest.query(
          `SELECT AssessmentChoiceId, AssessmentQuestionId, SortOrder, ChoiceText
           FROM dbo.AssessmentQuestionChoices
           WHERE AssessmentQuestionId IN (${questionClause})
           ORDER BY AssessmentQuestionId, SortOrder`
        );
      }
    }

    const detailsByItem = new Map();
    flowDetailsResult.recordset.forEach((detail) => {
      if (!detailsByItem.has(detail.FlowItemId)) {
        detailsByItem.set(detail.FlowItemId, []);
      }
      detailsByItem.get(detail.FlowItemId).push(detail);
    });

    const hintsByItem = new Map();
    flowHintsResult.recordset.forEach((hint) => {
      if (!hintsByItem.has(hint.FlowItemId)) {
        hintsByItem.set(hint.FlowItemId, []);
      }
      hintsByItem.get(hint.FlowItemId).push(hint);
    });

    const choicesByItem = new Map();
    flowChoicesResult.recordset.forEach((choice) => {
      if (!choicesByItem.has(choice.FlowItemId)) {
        choicesByItem.set(choice.FlowItemId, []);
      }
      choicesByItem.get(choice.FlowItemId).push(choice);
    });

    const flowItemsByConcept = new Map();
    flowItemsResult.recordset.forEach((item) => {
      if (!flowItemsByConcept.has(item.ConceptId)) {
        flowItemsByConcept.set(item.ConceptId, []);
      }
      flowItemsByConcept.get(item.ConceptId).push({
        item,
        details: detailsByItem.get(item.FlowItemId) || [],
        hints: hintsByItem.get(item.FlowItemId) || [],
        choices: choicesByItem.get(item.FlowItemId) || []
      });
    });

    const concepts = conceptsResult.recordset.map((concept) => ({
      concept,
      flow: flowItemsByConcept.get(concept.ConceptId) || []
    }));

    const choicesByQuestion = new Map();
    assessmentChoicesResult.recordset.forEach((choice) => {
      if (!choicesByQuestion.has(choice.AssessmentQuestionId)) {
        choicesByQuestion.set(choice.AssessmentQuestionId, []);
      }
      choicesByQuestion.get(choice.AssessmentQuestionId).push(choice);
    });

    const questionsByAssessment = new Map();
    assessmentQuestionsResult.recordset.forEach((question) => {
      if (!questionsByAssessment.has(question.AssessmentId)) {
        questionsByAssessment.set(question.AssessmentId, []);
      }
      questionsByAssessment.get(question.AssessmentId).push({
        question,
        choices: choicesByQuestion.get(question.AssessmentQuestionId) || []
      });
    });

    const assessments = assessmentsResult.recordset.map((assessment) => ({
      assessment,
      questions: questionsByAssessment.get(assessment.AssessmentId) || []
    }));

    const weekData = weekResult.recordset[0];
    const goals = goalsResult.recordset.map((goal) => goal.GoalText);
    const prerequisites = prerequisitesResult.recordset.map(
      (prereq) => prereq.PrerequisiteText
    );

    const normalizedConcepts = concepts.map(({ concept, flow }) => ({
      title: concept.Title,
      flow: flow.map(({ item, details, hints, choices }) => {
        const type = String(item.ItemType || '').trim().toLowerCase();
        const mapped = {
          type,
          text: item.ItemText,
          title: item.ItemTitle,
          description: item.ItemDescription,
          url: item.ItemUrl,
          answer: item.Answer,
          correctIndex: item.CorrectIndex,
          solution: item.Solution,
          details: details.map((detail) => detail.DetailText),
          hints: hints.map((hint) => hint.HintText),
          choices: choices.map((choice) => choice.ChoiceText)
        };

        if (!mapped.details.length) delete mapped.details;
        if (!mapped.hints.length) delete mapped.hints;
        if (!mapped.choices.length) delete mapped.choices;

        return mapped;
      })
    }));

    const normalizedAssessments = assessments.map(({ assessment, questions }) => ({
      title: assessment.Title,
      description: assessment.Description,
      questions: questions.map(({ question, choices }) => {
        const rawType = String(question.QuestionType || '').trim().toLowerCase();
        const choiceTexts = choices.map((choice) => choice.ChoiceText);
        let type = rawType;
        if (!['mcq', 'input'].includes(type)) {
          type = choiceTexts.length ? 'mcq' : 'input';
        }

        const normalized = {
          type,
          text: question.QuestionText,
          points: Number.isFinite(question.Points) ? question.Points : 1
        };

        if (type === 'mcq') {
          normalized.choices = choiceTexts;
          normalized.correctIndex =
            typeof question.CorrectIndex === 'number' ? question.CorrectIndex : 0;
        } else {
          normalized.answer = question.Answer ?? '';
        }

        return normalized;
      })
    }));

    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: {
        week: weekData.Week,
        title: weekData.Title,
        goals,
        prerequisites,
        concepts: normalizedConcepts,
        assessment: normalizedAssessments[0] || null
      }
    };
  } catch (error) {
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, error: error.message }
    };
  }
};

math/api/weeks/function.json
{
  "bindings": [
    {
      "authLevel": "anonymous",
      "type": "httpTrigger",
      "direction": "in",
      "name": "req",
      "methods": ["get"],
      "route": "weeks"
    },
    {
      "type": "http",
      "direction": "out",
      "name": "res"
    }
  ]
}

math/api/weeks/index.js
const { getPool } = require('../_shared/db');

module.exports = async function (context) {
  try {
    const dbPool = await getPool();
    const result = await dbPool.request().query('SELECT Week, Title FROM dbo.Weeks ORDER BY Week');
    context.res = {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
      body: result.recordset
    };
  } catch (error) {
    context.res = {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
      body: { ok: false, error: error.message }
    };
  }
};

math/server/.env
DB_SERVER=math-sql-server-01.database.windows.net
DB_NAME=free-sql-db-8542414
DB_USER=hema
DB_PASSWORD=Aa@8542414
DB_PORT=1433
DB_ENCRYPT=true
PORT=3000
ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000

math/server/.env.example
DB_SERVER=math-sql-server-01.database.windows.net
DB_NAME=free-sql-db-8542414
DB_USER=hema
DB_PASSWORD=your_password_here
DB_PORT=1433
DB_ENCRYPT=true
PORT=3000
NODE_ENV=development
ALLOWED_ORIGINS=http://localhost:3000,http://127.0.0.1:3000

math/server/package.json
{
  "name": "math-backend",
  "version": "1.0.0",
  "description": "Backend API for Math app",
  "main": "src/server.js",
  "type": "commonjs",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "mssql": "^10.0.2"
  },
  "devDependencies": {
    "nodemon": "^3.1.0"
  }
}

math/server/src/app.js
const express = require('express');
const cors = require('cors');
const path = require('path');
const crypto = require('crypto');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { getPool, sql } = require('./db');

const app = express();

const environment = process.env.NODE_ENV || '';
const isDevelopment = environment === 'development';

const allowedOrigins = (process.env.ALLOWED_ORIGINS || '')
  .split(',')
  .map((origin) => origin.trim())
  .filter(Boolean);

app.use(
  cors({
    origin(origin, callback) {
      if (!origin) {
        return callback(null, true);
      }
      if (!allowedOrigins.length && !isDevelopment) {
        return callback(
          new Error(
            'CORS misconfiguration: ALLOWED_ORIGINS must be set in non-development environments.'
          )
        );
      }
      if (isDevelopment && !allowedOrigins.length) {
        return callback(null, true);
      }
      if (allowedOrigins.includes(origin)) {
        return callback(null, true);
      }
      return callback(new Error('Not allowed by CORS'));
    }
  })
);

app.use(express.json());
app.use(express.static(path.resolve(__dirname, '..', '..', 'public')));

const adminJwtSecret = process.env.ADMIN_JWT_SECRET || process.env.JWT_SECRET || 'dev-admin-secret';
const adminJwtOptions = { expiresIn: '8h' };

const BCRYPT_ROUNDS = Number.parseInt(process.env.BCRYPT_ROUNDS || '12', 10);

function createLegacyPasswordHash(password, salt) {
  return crypto
    .createHash('sha256')
    .update(`${salt}:${password}`)
    .digest('hex');
}

function createLegacySalt() {
  return crypto.randomBytes(16).toString('hex');
}

function safeEqualHex(left, right) {
  const leftBuf = Buffer.from(String(left || ''), 'hex');
  const rightBuf = Buffer.from(String(right || ''), 'hex');
  if (leftBuf.length !== rightBuf.length) {
    return false;
  }
  return crypto.timingSafeEqual(leftBuf, rightBuf);
}

async function verifyAdminPassword(password, admin) {
  const hashType = String(admin.PasswordHashType || '').toLowerCase();
  if (hashType === 'bcrypt' && admin.PasswordHash) {
    return bcrypt.compare(password, admin.PasswordHash);
  }

  if (!admin.PasswordSalt || !admin.PasswordHash) {
    return false;
  }

  const legacyHash = createLegacyPasswordHash(password, admin.PasswordSalt);
  return safeEqualHex(legacyHash, admin.PasswordHash);
}

async function upgradeAdminPassword(pool, adminId, password) {
  const bcryptHash = await bcrypt.hash(password, BCRYPT_ROUNDS);
  await pool
    .request()
    .input('adminId', sql.Int, adminId)
    .input('passwordHash', sql.NVarChar(255), bcryptHash)
    .input('passwordSalt', sql.NVarChar(64), null)
    .input('passwordHashType', sql.NVarChar(20), 'bcrypt')
    .query(
      `UPDATE AdminUsers
       SET PasswordHash = @passwordHash,
           PasswordSalt = @passwordSalt,
           PasswordHashType = @passwordHashType,
           UpdatedAt = SYSUTCDATETIME()
       WHERE AdminId = @adminId`
    );
}

function getBearerToken(req) {
  const authHeader = req.headers.authorization || '';
  if (!authHeader.startsWith('Bearer ')) return null;
  return authHeader.slice('Bearer '.length).trim();
}

function requireAdminToken(req, res, next) {
  const token = getBearerToken(req);
  if (!token) {
    return res.status(401).json({ ok: false, error: 'ADMIN_AUTH_REQUIRED' });
  }

  try {
    const payload = jwt.verify(token, adminJwtSecret);
    req.admin = payload;
    return next();
  } catch (error) {
    return res.status(401).json({ ok: false, error: 'ADMIN_AUTH_INVALID' });
  }
}

app.get('/api/health', async (req, res, next) => {
  try {
    const pool = await getPool();
    await pool.request().query('SELECT 1 AS ok');
    res.json({ ok: true, db: true });
  } catch (error) {
    next(error);
  }
});

app.get('/api/weeks', async (req, res, next) => {
  try {
    const pool = await getPool();
    const result = await pool
      .request()
      .query('SELECT Week, Title FROM Weeks ORDER BY Week');
    res.json(result.recordset);
  } catch (error) {
    next(error);
  }
});

app.get('/api/cards', async (req, res, next) => {
  try {
    const pool = await getPool();
    const result = await pool
      .request()
      .query(
        'SELECT Week AS week, Title AS title, PrereqWeek AS prereq FROM Cards ORDER BY Week'
      );
    res.json(result.recordset);
  } catch (error) {
    next(error);
  }
});

app.post('/api/admin/login', async (req, res, next) => {
  try {
    const username = String(req.body?.username || '').trim();
    const password = String(req.body?.password || '').trim();

    if (!username || !password) {
      return res.status(400).json({ ok: false, error: 'Missing admin credentials.' });
    }

    const pool = await getPool();
    const result = await pool
      .request()
      .input('username', sql.NVarChar(80), username)
      .query(
        `SELECT AdminId, Username, PasswordHash, PasswordSalt, PasswordHashType, IsActive
         FROM AdminUsers
         WHERE Username = @username`
      );

    if (!result.recordset.length) {
      return res.status(401).json({ ok: false, error: 'INVALID_ADMIN_LOGIN' });
    }

    const admin = result.recordset[0];
    if (admin.IsActive === false || admin.IsActive === 0) {
      return res.status(403).json({ ok: false, error: 'ADMIN_DISABLED' });
    }

    const passwordOk = await verifyAdminPassword(password, admin);
    if (!passwordOk) {
      return res.status(401).json({ ok: false, error: 'INVALID_ADMIN_LOGIN' });
    }
    const hashType = String(admin.PasswordHashType || '').toLowerCase();
    if (hashType !== 'bcrypt') {
      await upgradeAdminPassword(pool, admin.AdminId, password);
    }

    const token = jwt.sign(
      { adminId: admin.AdminId, username: admin.Username },
      adminJwtSecret,
      adminJwtOptions
    );
    res.json({ ok: true, user: { username: admin.Username }, token });
  } catch (error) {
    next(error);
  }
});

app.use('/api/astu', requireAdminToken);
app.use('/api/cards-mng', requireAdminToken);
app.use('/api/admin/password', requireAdminToken);

app.put('/api/admin/password', async (req, res, next) => {
  try {
    const username = String(req.body?.username || '').trim();
    const currentPassword = String(req.body?.currentPassword || '').trim();
    const newPassword = String(req.body?.newPassword || '').trim();

    const tokenUsername = req.admin?.username ? String(req.admin.username) : '';
    const effectiveUsername = username || tokenUsername;

    if (!effectiveUsername || !currentPassword || !newPassword) {
      return res.status(400).json({ ok: false, error: 'Missing password payload.' });
    }

    if (tokenUsername && username && tokenUsername !== username) {
      return res.status(403).json({ ok: false, error: 'ADMIN_AUTH_MISMATCH' });
    }

    const pool = await getPool();
    const result = await pool
      .request()
      .input('username', sql.NVarChar(80), effectiveUsername)
      .query(
        `SELECT AdminId, Username, PasswordHash, PasswordSalt, PasswordHashType, IsActive
         FROM AdminUsers
         WHERE Username = @username`
      );

    if (!result.recordset.length) {
      return res.status(404).json({ ok: false, error: 'ADMIN_NOT_FOUND' });
    }

    const admin = result.recordset[0];
    if (admin.IsActive === false || admin.IsActive === 0) {
      return res.status(403).json({ ok: false, error: 'ADMIN_DISABLED' });
    }

    const passwordOk = await verifyAdminPassword(currentPassword, admin);
    if (!passwordOk) {
      return res.status(401).json({ ok: false, error: 'INVALID_ADMIN_LOGIN' });
    }

    const nextHash = await bcrypt.hash(newPassword, BCRYPT_ROUNDS);

    await pool
      .request()
      .input('adminId', sql.Int, admin.AdminId)
      .input('passwordHash', sql.NVarChar(255), nextHash)
      .input('passwordSalt', sql.NVarChar(64), null)
      .input('passwordHashType', sql.NVarChar(20), 'bcrypt')
      .query(
        `UPDATE AdminUsers
         SET PasswordHash = @passwordHash,
             PasswordSalt = @passwordSalt,
             PasswordHashType = @passwordHashType,
             UpdatedAt = SYSUTCDATETIME()
         WHERE AdminId = @adminId`
      );

    res.json({ ok: true });
  } catch (error) {
    next(error);
  }
});

app.post('/api/students/login', async (req, res, next) => {
  try {
    const studentId = String(req.body?.studentId || '').trim();
    const birthYear = String(req.body?.birthYear || '').trim();

    if (!studentId || !birthYear) {
      return res.status(400).json({ ok: false, error: 'Missing student credentials.' });
    }

    const pool = await getPool();
    const result = await pool
      .request()
      .input('studentId', sql.NVarChar(20), studentId)
      .input('birthYear', sql.NVarChar(10), birthYear)
      .query(
        `SELECT StudentId, BirthYear, FirstName, FullName, Class
         FROM Students
         WHERE StudentId = @studentId AND BirthYear = @birthYear`
      );

    if (!result.recordset.length) {
      return res.status(404).json({ ok: false, error: 'Student not found.' });
    }

    const student = result.recordset[0];
    const payload = {
      StudentId: student.StudentId,
      BirthYear: student.BirthYear,
      FirstName: student.FirstName,
      FullName: student.FullName,
      Class: student.Class
    };
    res.json({
      ok: true,
      student: payload,
      ...payload
    });
  } catch (error) {
    next(error);
  }
});

app.get('/api/students/:studentId/completions', async (req, res, next) => {
  try {
    const studentId = String(req.params.studentId || '').trim();
    if (!studentId) {
      return res.status(400).json({ ok: false, error: 'Missing studentId.' });
    }

    const pool = await getPool();
    const result = await pool
      .request()
      .input('studentId', sql.NVarChar(20), studentId)
      .query(
        `SELECT CompletionId, StudentId, Week, FinalScore, CompletedAt
         FROM CardCompletions
         WHERE StudentId = @studentId
         ORDER BY Week`
      );

    res.json(result.recordset);
  } catch (error) {
    next(error);
  }
});

app.post('/api/students/:studentId/completions', async (req, res, next) => {
  try {
    const studentId = String(req.params.studentId || '').trim();
    const week = Number(req.body?.week);
    const finalScore = Number.isFinite(Number(req.body?.finalScore))
      ? Number(req.body.finalScore)
      : 0;

    if (!studentId || !Number.isInteger(week)) {
      return res.status(400).json({ ok: false, error: 'Invalid completion payload.' });
    }

    const pool = await getPool();
    const existing = await pool
      .request()
      .input('studentId', sql.NVarChar(20), studentId)
      .input('week', sql.Int, week)
      .query(
        `SELECT CompletionId
         FROM CardCompletions
         WHERE StudentId = @studentId AND Week = @week`
      );

    if (existing.recordset.length) {
      await pool
        .request()
        .input('studentId', sql.NVarChar(20), studentId)
        .input('week', sql.Int, week)
        .input('finalScore', sql.Int, finalScore)
        .query(
          `UPDATE CardCompletions
           SET FinalScore = @finalScore, CompletedAt = GETDATE()
           WHERE StudentId = @studentId AND Week = @week`
        );
    } else {
      await pool
        .request()
        .input('studentId', sql.NVarChar(20), studentId)
        .input('week', sql.Int, week)
        .input('finalScore', sql.Int, finalScore)
        .query(
          `INSERT INTO CardCompletions (StudentId, Week, FinalScore, CompletedAt)
           VALUES (@studentId, @week, @finalScore, GETDATE())`
        );
    }

    res.json({ ok: true });
  } catch (error) {
    next(error);
  }
});

app.get('/api/astu', async (req, res, next) => {
  try {
    const pool = await getPool();
    const result = await pool
      .request()
      .query(
        `SELECT StudentId, BirthYear, FirstName, FullName, Class
         FROM Students
         ORDER BY StudentId`
      );
    res.json(result.recordset);
  } catch (error) {
    next(error);
  }
});

app.put('/api/astu', async (req, res, next) => {
  try {
    const students = Array.isArray(req.body?.students) ? req.body.students : [];
    const replaceAll = req.body?.replaceAll === true;
    const normalized = students
      .map((student) => ({
        studentId: String(student.studentId || student.id || '').trim(),
        birthYear: String(student.birthYear || '').trim(),
        firstName: String(student.firstName || '').trim(),
        fullName: String(student.fullName || '').trim(),
        class: String(student.class || '').trim()
      }))
      .filter((student) => student.studentId && student.birthYear);

    if (normalized.length === 0 && !replaceAll) {
      return res.status(400).json({ ok: false, error: 'EMPTY_STUDENT_LIST' });
    }

    const pool = await getPool();
    const transaction = new sql.Transaction(pool);
    await transaction.begin();

    try {
      const existing = await new sql.Request(transaction)
        .query('SELECT StudentId FROM Students');
      const existingIds = new Set(existing.recordset.map((row) => row.StudentId));
      const incomingIds = new Set(normalized.map((student) => student.studentId));

      for (const student of normalized) {
        const updateRequest = new sql.Request(transaction);
        const updateResult = await updateRequest
          .input('studentId', sql.NVarChar(20), student.studentId)
          .input('birthYear', sql.NVarChar(10), student.birthYear)
          .input('firstName', sql.NVarChar(100), student.firstName)
          .input('fullName', sql.NVarChar(200), student.fullName)
          .input('class', sql.NVarChar(20), student.class)
          .query(
            `UPDATE Students
             SET BirthYear = @birthYear, FirstName = @firstName, FullName = @fullName, Class = @class
             WHERE StudentId = @studentId`
          );

        if (!updateResult.rowsAffected?.[0]) {
          await updateRequest.query(
            `INSERT INTO Students (StudentId, BirthYear, FirstName, FullName, Class)
             VALUES (@studentId, @birthYear, @firstName, @fullName, @class)`
          );
        }
      }

      const toDelete = Array.from(existingIds).filter((id) => !incomingIds.has(id));
      for (const studentId of toDelete) {
        await new sql.Request(transaction)
          .input('deleteId', sql.NVarChar(20), studentId)
          .query('DELETE FROM Students WHERE StudentId = @deleteId');
      }

      await transaction.commit();
      res.json({ ok: true });
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  } catch (error) {
    next(error);
  }
});

app.get('/api/cards-mng', async (req, res, next) => {
  try {
    const pool = await getPool();
    const result = await pool
      .request()
      .query('SELECT Week, Title, PrereqWeek FROM Cards ORDER BY Week');
    res.json(result.recordset);
  } catch (error) {
    next(error);
  }
});

app.put('/api/cards-mng', async (req, res, next) => {
  try {
    const cards = Array.isArray(req.body?.cards) ? req.body.cards : [];
    const normalized = cards
      .map((card) => ({
        week: Number(card.week),
        title: String(card.title || '').trim(),
        prereqWeek: card.prereq == null || card.prereq === ''
          ? null
          : Number(card.prereq)
      }))
      .filter((card) => Number.isInteger(card.week) && card.title);

    const pool = await getPool();
    const transaction = new sql.Transaction(pool);
    await transaction.begin();

    try {
      const request = new sql.Request(transaction);
      const existing = await request.query('SELECT Week FROM Cards');
      const existingWeeks = new Set(existing.recordset.map((row) => row.Week));
      const incomingWeeks = new Set(normalized.map((card) => card.week));
      const allowedPrereqs = new Set([...existingWeeks, ...incomingWeeks]);
      const invalidPrereq = normalized.find(
        (card) => card.prereqWeek != null && !allowedPrereqs.has(card.prereqWeek)
      );

      if (invalidPrereq) {
        await transaction.rollback();
        return res.status(400).json({ ok: false, error: 'INVALID_PREREQ_WEEK' });
      }

      for (const card of normalized) {
        const updateRequest = new sql.Request(transaction);
        const updateResult = await updateRequest
          .input('week', sql.Int, card.week)
          .input('title', sql.NVarChar(300), card.title)
          .input('prereqWeek', sql.Int, card.prereqWeek)
          .query(
            `UPDATE Cards
             SET Title = @title, PrereqWeek = @prereqWeek
             WHERE Week = @week`
          );

        if (!updateResult.rowsAffected?.[0]) {
          await updateRequest.query(
            `INSERT INTO Cards (Week, Title, PrereqWeek)
             VALUES (@week, @title, @prereqWeek)`
          );
        }
      }

      const toDelete = Array.from(existingWeeks).filter((week) => !incomingWeeks.has(week));
      for (const week of toDelete) {
        const deleteRequest = new sql.Request(transaction);
        await deleteRequest
          .input('deleteWeek', sql.Int, week)
          .query('DELETE FROM Cards WHERE Week = @deleteWeek');
      }

      await transaction.commit();
      res.json({ ok: true });
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  } catch (error) {
    next(error);
  }
});

app.get('/api/weeks/:week', async (req, res, next) => {
  try {
    const week = Number(req.params.week);
    if (!Number.isInteger(week)) {
      return res.status(400).json({ ok: false, error: 'Invalid week parameter.' });
    }

    const pool = await getPool();
    const weekResult = await pool
      .request()
      .input('week', sql.Int, week)
      .query('SELECT Week, Title FROM Weeks WHERE Week = @week');

    if (!weekResult.recordset.length) {
      return res.status(404).json({ ok: false, error: 'Week not found.' });
    }

    const goalsResult = await pool
      .request()
      .input('week', sql.Int, week)
      .query(
        'SELECT GoalId, Week, SortOrder, GoalText FROM WeekGoals WHERE Week = @week ORDER BY SortOrder'
      );

    const prereqResult = await pool
      .request()
      .input('week', sql.Int, week)
      .query(
        'SELECT PrerequisiteId, Week, SortOrder, PrerequisiteText FROM WeekPrerequisites WHERE Week = @week ORDER BY SortOrder'
      );

    const conceptResult = await pool
      .request()
      .input('week', sql.Int, week)
      .query(
        'SELECT ConceptId, Week, SortOrder, Title FROM Concepts WHERE Week = @week ORDER BY SortOrder'
      );

    const conceptIds = conceptResult.recordset.map((concept) => concept.ConceptId);
    let flowItemsResult = { recordset: [] };
    let flowDetailsResult = { recordset: [] };
    let flowHintsResult = { recordset: [] };
    let flowChoicesResult = { recordset: [] };

    if (conceptIds.length) {
      const inClause = conceptIds.map((_, index) => `@concept${index}`).join(',');
      const flowRequest = pool.request();
      conceptIds.forEach((id, index) => {
        flowRequest.input(`concept${index}`, sql.Int, id);
      });

      flowItemsResult = await flowRequest.query(
        `SELECT FlowItemId, ConceptId, SortOrder, ItemType, ItemText, ItemTitle, ItemDescription, ItemUrl, Answer, CorrectIndex, Solution
         FROM FlowItems
         WHERE ConceptId IN (${inClause})
         ORDER BY ConceptId, SortOrder`
      );

      const flowItemIds = flowItemsResult.recordset.map((item) => item.FlowItemId);
      if (flowItemIds.length) {
        const itemClause = flowItemIds.map((_, index) => `@item${index}`).join(',');
        const itemRequest = pool.request();
        flowItemIds.forEach((id, index) => {
          itemRequest.input(`item${index}`, sql.Int, id);
        });

        flowDetailsResult = await itemRequest.query(
          `SELECT FlowItemDetailId, FlowItemId, SortOrder, DetailText
           FROM FlowItemDetails
           WHERE FlowItemId IN (${itemClause})
           ORDER BY FlowItemId, SortOrder`
        );

        const hintRequest = pool.request();
        flowItemIds.forEach((id, index) => {
          hintRequest.input(`item${index}`, sql.Int, id);
        });
        flowHintsResult = await hintRequest.query(
          `SELECT FlowItemHintId, FlowItemId, SortOrder, HintText
           FROM FlowItemHints
           WHERE FlowItemId IN (${itemClause})
           ORDER BY FlowItemId, SortOrder`
        );

        const choiceRequest = pool.request();
        flowItemIds.forEach((id, index) => {
          choiceRequest.input(`item${index}`, sql.Int, id);
        });
        flowChoicesResult = await choiceRequest.query(
          `SELECT FlowItemChoiceId, FlowItemId, SortOrder, ChoiceText
           FROM FlowItemChoices
           WHERE FlowItemId IN (${itemClause})
           ORDER BY FlowItemId, SortOrder`
        );
      }
    }

    const assessmentsResult = await pool
      .request()
      .input('week', sql.Int, week)
      .query(
        'SELECT AssessmentId, Week, Title, Description FROM Assessments WHERE Week = @week ORDER BY AssessmentId'
      );

    const assessmentIds = assessmentsResult.recordset.map(
      (assessment) => assessment.AssessmentId
    );
    let assessmentQuestionsResult = { recordset: [] };
    let assessmentChoicesResult = { recordset: [] };

    if (assessmentIds.length) {
      const assessmentClause = assessmentIds.map((_, index) => `@assessment${index}`).join(',');
      const assessmentRequest = pool.request();
      assessmentIds.forEach((id, index) => {
        assessmentRequest.input(`assessment${index}`, sql.Int, id);
      });

      assessmentQuestionsResult = await assessmentRequest.query(
        `SELECT AssessmentQuestionId, AssessmentId, SortOrder, QuestionType, QuestionText, Answer, Points, CorrectIndex
         FROM AssessmentQuestions
         WHERE AssessmentId IN (${assessmentClause})
         ORDER BY AssessmentId, SortOrder`
      );

      const questionIds = assessmentQuestionsResult.recordset.map(
        (question) => question.AssessmentQuestionId
      );

      if (questionIds.length) {
        const questionClause = questionIds.map((_, index) => `@question${index}`).join(',');
        const questionRequest = pool.request();
        questionIds.forEach((id, index) => {
          questionRequest.input(`question${index}`, sql.Int, id);
        });

        assessmentChoicesResult = await questionRequest.query(
          `SELECT AssessmentChoiceId, AssessmentQuestionId, SortOrder, ChoiceText
           FROM AssessmentQuestionChoices
           WHERE AssessmentQuestionId IN (${questionClause})
           ORDER BY AssessmentQuestionId, SortOrder`
        );
      }
    }

    const detailsByItem = new Map();
    flowDetailsResult.recordset.forEach((detail) => {
      if (!detailsByItem.has(detail.FlowItemId)) {
        detailsByItem.set(detail.FlowItemId, []);
      }
      detailsByItem.get(detail.FlowItemId).push(detail);
    });

    const hintsByItem = new Map();
    flowHintsResult.recordset.forEach((hint) => {
      if (!hintsByItem.has(hint.FlowItemId)) {
        hintsByItem.set(hint.FlowItemId, []);
      }
      hintsByItem.get(hint.FlowItemId).push(hint);
    });

    const choicesByItem = new Map();
    flowChoicesResult.recordset.forEach((choice) => {
      if (!choicesByItem.has(choice.FlowItemId)) {
        choicesByItem.set(choice.FlowItemId, []);
      }
      choicesByItem.get(choice.FlowItemId).push(choice);
    });

    const flowItemsByConcept = new Map();
    flowItemsResult.recordset.forEach((item) => {
      if (!flowItemsByConcept.has(item.ConceptId)) {
        flowItemsByConcept.set(item.ConceptId, []);
      }
      flowItemsByConcept.get(item.ConceptId).push({
        item,
        details: detailsByItem.get(item.FlowItemId) || [],
        hints: hintsByItem.get(item.FlowItemId) || [],
        choices: choicesByItem.get(item.FlowItemId) || []
      });
    });

    const concepts = conceptResult.recordset.map((concept) => ({
      concept,
      flow: flowItemsByConcept.get(concept.ConceptId) || []
    }));

    const choicesByQuestion = new Map();
    assessmentChoicesResult.recordset.forEach((choice) => {
      if (!choicesByQuestion.has(choice.AssessmentQuestionId)) {
        choicesByQuestion.set(choice.AssessmentQuestionId, []);
      }
      choicesByQuestion.get(choice.AssessmentQuestionId).push(choice);
    });

    const questionsByAssessment = new Map();
    assessmentQuestionsResult.recordset.forEach((question) => {
      if (!questionsByAssessment.has(question.AssessmentId)) {
        questionsByAssessment.set(question.AssessmentId, []);
      }
      questionsByAssessment.get(question.AssessmentId).push({
        question,
        choices: choicesByQuestion.get(question.AssessmentQuestionId) || []
      });
    });

    const assessments = assessmentsResult.recordset.map((assessment) => ({
      assessment,
      questions: questionsByAssessment.get(assessment.AssessmentId) || []
    }));

    const weekData = weekResult.recordset[0];
    const goals = goalsResult.recordset.map((goal) => goal.GoalText);
    const prerequisites = prereqResult.recordset.map((req) => req.PrerequisiteText);

    const normalizedConcepts = concepts.map(({ concept, flow }) => ({
      title: concept.Title,
      flow: flow.map(({ item, details, hints, choices }) => {
        const type = String(item.ItemType || '').trim().toLowerCase();
        const mapped = {
          type,
          text: item.ItemText,
          title: item.ItemTitle,
          description: item.ItemDescription,
          url: item.ItemUrl,
          answer: item.Answer,
          correctIndex: item.CorrectIndex,
          solution: item.Solution,
          details: details.map((detail) => detail.DetailText),
          hints: hints.map((hint) => hint.HintText),
          choices: choices.map((choice) => choice.ChoiceText)
        };

        if (!mapped.details.length) delete mapped.details;
        if (!mapped.hints.length) delete mapped.hints;
        if (!mapped.choices.length) delete mapped.choices;

        return mapped;
      })
    }));

    const normalizedAssessments = assessments.map(({ assessment, questions }) => ({
      title: assessment.Title,
      description: assessment.Description,
      questions: questions.map(({ question, choices }) => {
        const rawType = String(question.QuestionType || '').trim().toLowerCase();
        const choiceTexts = choices.map((choice) => choice.ChoiceText);
        let type = rawType;
        if (!['mcq', 'input'].includes(type)) {
          type = choiceTexts.length ? 'mcq' : 'input';
        }

        const normalized = {
          type,
          text: question.QuestionText,
          points: Number.isFinite(question.Points) ? question.Points : 1
        };

        if (type === 'mcq') {
          normalized.choices = choiceTexts;
          normalized.correctIndex =
            typeof question.CorrectIndex === 'number' ? question.CorrectIndex : 0;
        } else {
          normalized.answer = question.Answer ?? '';
        }

        return normalized;
      })
    }));

    res.json({
      week: weekData.Week,
      title: weekData.Title,
      goals,
      prerequisites,
      concepts: normalizedConcepts,
      assessment: normalizedAssessments[0] || null
    });
  } catch (error) {
    next(error);
  }
});

app.use((req, res) => {
  res.status(404).json({ ok: false, error: 'Not found.' });
});

app.use((err, req, res, next) => {
  const status = err.status || 500;
  res.status(status).json({
    ok: false,
    error: err.message || 'Internal server error.'
  });
});

module.exports = app;

math/server/src/db.js
const sql = require('mssql');

let pool;

function buildConfig() {
  return {
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    server: process.env.DB_SERVER,
    port: Number(process.env.DB_PORT || 1433),
    database: process.env.DB_NAME,
    options: {
      encrypt: String(process.env.DB_ENCRYPT).toLowerCase() === 'true',
      trustServerCertificate: false
    },
    pool: {
      max: 10,
      min: 0,
      idleTimeoutMillis: 30000
    }
  };
}

async function getPool() {
  if (pool) {
    return pool;
  }

  const config = buildConfig();
  pool = await sql.connect(config);
  pool.on('error', () => {
    pool = null;
  });
  return pool;
}

module.exports = {
  sql,
  getPool
};

math/server/src/server.js
require('dotenv').config();

const app = require('./app');

const port = Number(process.env.PORT || 3000);

app.listen(port, () => {
  console.log(`Server listening on http://localhost:${port}`);
});

math/public/docs/admin-users.sql
-- Ø¥Ù†Ø´Ø§Ø¡ Ø¬Ø¯ÙˆÙ„ Ù…Ø³ØªØ®Ø¯Ù…ÙŠ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© (Azure SQL)
CREATE TABLE AdminUsers (
  AdminId INT IDENTITY(1,1) PRIMARY KEY,
  Username NVARCHAR(80) NOT NULL UNIQUE,
  PasswordHash NVARCHAR(128) NOT NULL,
  PasswordSalt NVARCHAR(64) NOT NULL,
  IsActive BIT NOT NULL DEFAULT 1,
  CreatedAt DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME(),
  UpdatedAt DATETIME2 NOT NULL DEFAULT SYSUTCDATETIME()
);

-- Ù…Ø«Ø§Ù„ Ù„Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø³ØªØ®Ø¯Ù… Ø¥Ø¯Ø§Ø±Ø© (ØºÙŠÙ‘Ø± ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ù‚Ø¨Ù„ Ø§Ù„ØªÙ†ÙÙŠØ°)
DECLARE @username NVARCHAR(80) = N'admin';
DECLARE @password NVARCHAR(200) = N'ChangeMe123!';
DECLARE @salt NVARCHAR(64) = CONVERT(NVARCHAR(64), NEWID());
DECLARE @hash NVARCHAR(128) =
  CONVERT(NVARCHAR(128), HASHBYTES('SHA2_256', CONCAT(@salt, N':', @password)), 2);

INSERT INTO AdminUsers (Username, PasswordHash, PasswordSalt)
VALUES (@username, @hash, @salt);

math/public/docs/database-schema.md
# Database Schema Reference

> Source: user-provided table/column summary for the Math app database.

## AssessmentQuestionChoices

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| AssessmentChoiceId | int |  | NO |
| AssessmentQuestionId | int |  | NO |
| SortOrder | int |  | NO |
| ChoiceText | nvarchar | 300 | NO |

## AssessmentQuestions

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| AssessmentQuestionId | int |  | NO |
| AssessmentId | int |  | NO |
| SortOrder | int |  | NO |
| QuestionType | nvarchar | 50 | NO |
| QuestionText | nvarchar | 500 | NO |
| Answer | nvarchar | 200 | YES |
| Points | int |  | NO |
| CorrectIndex | int |  | YES |

## Assessments

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| AssessmentId | int |  | NO |
| Week | int |  | NO |
| Title | nvarchar | 300 | NO |
| Description | nvarchar | 500 | NO |

## CardCompletions

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| CompletionId | int |  | NO |
| StudentId | nvarchar | 20 | NO |
| Week | int |  | NO |
| FinalScore | int |  | NO |
| CompletedAt | datetime |  | NO |

## Cards

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| Week | int |  | NO |
| Title | nvarchar | 300 | NO |
| PrereqWeek | int |  | YES |

## Concepts

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| ConceptId | int |  | NO |
| Week | int |  | NO |
| SortOrder | int |  | NO |
| Title | nvarchar | 300 | NO |

## database_firewall_rules

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| id | int |  | NO |
| name | nvarchar | 128 | NO |
| start_ip_address | varchar | 45 | NO |
| end_ip_address | varchar | 45 | NO |
| create_date | datetime |  | NO |
| modify_date | datetime |  | NO |

## FlowItemChoices

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| FlowItemChoiceId | int |  | NO |
| FlowItemId | int |  | NO |
| SortOrder | int |  | NO |
| ChoiceText | nvarchar | 300 | NO |

## FlowItemDetails

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| FlowItemDetailId | int |  | NO |
| FlowItemId | int |  | NO |
| SortOrder | int |  | NO |
| DetailText | nvarchar | 500 | NO |

## FlowItemHints

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| FlowItemHintId | int |  | NO |
| FlowItemId | int |  | NO |
| SortOrder | int |  | NO |
| HintText | nvarchar | 500 | NO |

## FlowItems

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| FlowItemId | int |  | NO |
| ConceptId | int |  | NO |
| SortOrder | int |  | NO |
| ItemType | nvarchar | 50 | NO |
| ItemText | nvarchar | 1000 | YES |
| ItemTitle | nvarchar | 300 | YES |
| ItemDescription | nvarchar | 500 | YES |
| ItemUrl | nvarchar | 500 | YES |
| Answer | nvarchar | 200 | YES |
| CorrectIndex | int |  | YES |
| Solution | nvarchar | 1000 | YES |

## Students

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| StudentId | nvarchar | 20 | NO |
| BirthYear | nvarchar | 10 | NO |
| FirstName | nvarchar | 100 | NO |
| FullName | nvarchar | 200 | NO |
| Class | nvarchar | 20 | NO |

## WeekGoals

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| GoalId | int |  | NO |
| Week | int |  | NO |
| SortOrder | int |  | NO |
| GoalText | nvarchar | 500 | NO |

## WeekPrerequisites

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| PrerequisiteId | int |  | NO |
| Week | int |  | NO |
| SortOrder | int |  | NO |
| PrerequisiteText | nvarchar | 500 | NO |

## Weeks

| Column | Type | Max Length | Nullable |
| --- | --- | --- | --- |
| Week | int |  | NO |
| Title | nvarchar | 300 | NO |

math/public/data/cards.json
[
  {
    "week": 999,
    "title": "Ø¨Ø·Ø§Ù‚Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ© â€” Ù…Ø­Ø±Ùƒ Ø¨Ù„Ø§ Ø­Ø¯ÙˆØ¯",
    "prereq": null
  },
  {
    "week": 1000,
    "title": "Ø¨Ø·Ø§Ù‚Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ© â€” Ø§Ù„Ù…Ø±Ø¨Ø¹ (Ø®ØµØ§Ø¦ØµÙ‡ ÙˆÙ…Ø­ÙŠØ·Ù‡ ÙˆÙ…Ø³Ø§Ø­ØªÙ‡)",
    "prereq": 999
  }
]

math/public/data/students.json
{
  "version": 1,
  "note": "Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø·Ù„Ø§Ø¨ Ù„Ù„ØªØ­Ù‚Ù‚ (Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ© + Ø³Ù†Ø© Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯). Ù„Ø§ ØªØ¶Ø¹ Ø¨ÙŠØ§Ù†Ø§Øª Ø­Ø³Ø§Ø³Ø© Ø¥Ø¶Ø§ÙÙŠØ©. ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© 200 Ø·Ø§Ù„Ø¨ Ù‡Ù†Ø§.",
  "students": [
    {
      "id": "23432",
      "birthYear": "2012",
      "firstName": "Ø£Ø­Ù…Ø¯",
      "fullName": "Ø£Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯",
      "class": "7/1"
    },
    {
      "id": "998877",
      "birthYear": "2011",
      "firstName": "Ø®Ø§Ù„Ø¯",
      "fullName": "Ø®Ø§Ù„Ø¯ Ø¹Ù„ÙŠ",
      "class": "7/2"
    },
    {
      "id": "444422265",
      "birthYear": "2023",
      "firstName": "Ù…ÙŠØ±Ø§",
      "fullName": "Ù…ÙŠØ±Ø§ Ø§Ø­Ù…Ø¯",
      "class": "7/2"
    },
    {
      "id": "55511001",
      "birthYear": "2013",
      "firstName": "Ù„ÙŠØ§Ù†",
      "fullName": "Ù„ÙŠØ§Ù† Ø­Ø³Ù†",
      "class": "6/1"
    },
    {
      "id": "55511002",
      "birthYear": "2012",
      "firstName": "Ø³Ø§Ù…ÙŠ",
      "fullName": "Ø³Ø§Ù…ÙŠ Ù†Ø§ØµØ±",
      "class": "6/2"
    },
    {
      "id": "55511003",
      "birthYear": "2011",
      "firstName": "Ù‡ÙŠØ§",
      "fullName": "Ù‡ÙŠØ§ Ù…Ø­Ù…ÙˆØ¯",
      "class": "6/3"
    }
  ]
}

math/public/data/weeks/week1000.json
{
  "week": 1000,
  "title": "Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ù…Ø±Ø¨Ø¹ â€” Ø®ØµØ§Ø¦ØµÙ‡ ÙˆÙ…Ø­ÙŠØ·Ù‡ ÙˆÙ…Ø³Ø§Ø­ØªÙ‡",
  "goals": [
    "Ø§Ù„ØªØ¹Ø±Ù‘Ù Ø¹Ù„Ù‰ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙˆØ·Ø±ÙŠÙ‚Ø© Ø­Ø³Ø§Ø¨ Ù…Ø­ÙŠØ·Ù‡.",
    "Ø¥ØªÙ‚Ø§Ù† Ø­Ø³Ø§Ø¨ Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹."
  ],
  "prerequisites": [
    "Ù…Ø¹Ø±ÙØ© Ù…ÙÙ‡ÙˆÙ… Ø§Ù„Ù…Ø­ÙŠØ· ÙˆØ§Ù„Ù…Ø³Ø§Ø­Ø© Ø¨Ø´ÙƒÙ„ Ø¹Ø§Ù….",
    "Ø¥ØªÙ‚Ø§Ù† Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø¬Ù…Ø¹ ÙˆØ§Ù„Ø¶Ø±Ø¨ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©."
  ],
  "assessment": {
    "title": "ØªÙ‚ÙŠÙŠÙ… Ø®ØªØ§Ù…ÙŠ Ù„Ù„Ù…Ø±Ø¨Ø¹",
    "description": "Ø£Ø¬Ø¨ Ø¹Ù† Ø§Ù„Ø£Ø³Ø¦Ù„Ø© Ø§Ù„ØªØ§Ù„ÙŠØ© Ù„ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ù†Ù‚Ø§Ø·Ùƒ. Ø¨Ø¯ÙˆÙ† ØªØµÙˆÙŠØ¨ ÙÙˆØ±ÙŠ.",
    "questions": [
      {
        "type": "input",
        "text": "Ø·ÙˆÙ„ Ø¶Ù„Ø¹ Ù…Ø±Ø¨Ø¹ = 4 Ø³Ù…. Ù…Ø§ Ù…Ø­ÙŠØ·Ù‡ØŸ",
        "answer": "16",
        "points": 2
      },
      {
        "type": "mcq",
        "text": "Ø£ÙŠ Ø¹Ø¨Ø§Ø±Ø© ØµØ­ÙŠØ­Ø© Ø¹Ù† Ø§Ù„Ù…Ø±Ø¨Ø¹ØŸ",
        "choices": [
          "ÙƒÙ„ Ø²ÙˆØ§ÙŠØ§Ù‡ Ø­Ø§Ø¯Ø©",
          "ÙƒÙ„ Ø£Ø¶Ù„Ø§Ø¹Ù‡ Ù…ØªØ³Ø§ÙˆÙŠØ©",
          "Ù„Ù‡ Ø¶Ù„Ø¹Ø§Ù† Ù…ØªØ³Ø§ÙˆÙŠØ§Ù† ÙÙ‚Ø·",
          "Ù„ÙŠØ³ Ù„Ù‡ Ø²ÙˆØ§ÙŠØ§ Ù‚Ø§Ø¦Ù…Ø©"
        ],
        "correctIndex": 1,
        "points": 2
      },
      {
        "type": "input",
        "text": "Ø·ÙˆÙ„ Ø¶Ù„Ø¹ Ù…Ø±Ø¨Ø¹ = 6 Ø³Ù…. Ù…Ø§ Ù…Ø³Ø§Ø­ØªÙ‡ØŸ",
        "answer": "36",
        "points": 3
      }
    ]
  },
  "concepts": [
    {
      "title": "Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙˆÙ…Ø­ÙŠØ·Ù‡",
      "flow": [
        {
          "type": "goal",
          "text": "Ø£Ù† ÙŠØªØ¹Ø±Ù‘Ù Ø§Ù„Ø·Ø§Ù„Ø¨ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø´ÙƒÙ„ Ø§Ù„Ù…Ø±Ø¨Ø¹ ÙˆÙƒÙŠÙ Ù†Ø­Ø³Ø¨ Ù…Ø­ÙŠØ·Ù‡.",
          "details": [
            "Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø´ÙƒÙ„ Ø±Ø¨Ø§Ø¹ÙŠ Ù…Ù†ØªØ¸Ù….",
            "Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¶Ù„Ø§Ø¹ Ù…ØªØ³Ø§ÙˆÙŠØ©.",
            "ÙƒÙ„ Ø²Ø§ÙˆÙŠØ© ØªØ³Ø§ÙˆÙŠ 90Â°"
          ]
        },
        {
          "type": "explain",
          "text": "Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø´ÙƒÙ„ Ø±Ø¨Ø§Ø¹ÙŠ: Ø£Ø¶Ù„Ø§Ø¹Ù‡ Ø§Ù„Ø£Ø±Ø¨Ø¹Ø© Ù…ØªØ³Ø§ÙˆÙŠØ© ÙˆØ²ÙˆØ§ÙŠØ§Ù‡ Ù‚Ø§Ø¦Ù…Ø© (90Â°)."
        },
        {
          "type": "video",
          "title": "ÙÙŠØ¯ÙŠÙˆ Ø³Ø±ÙŠØ¹ Ø¹Ù† Ø®ØµØ§Ø¦Øµ Ø§Ù„Ù…Ø±Ø¨Ø¹",
          "description": "Ø´Ø§Ù‡Ø¯ Ù‡Ø°Ø§ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù„ØªØ«Ø¨ÙŠØª ÙÙƒØ±Ø© Ø§Ù„Ø²ÙˆØ§ÙŠØ§ ÙˆØ§Ù„Ø£Ø¶Ù„Ø§Ø¹ Ø§Ù„Ù…ØªØ³Ø§ÙˆÙŠØ©.",
          "url": "https://www.youtube.com/watch?v=9e3r0W0bKpg"
        },
        {
          "type": "example",
          "text": "Ø¥Ø°Ø§ ÙƒØ§Ù† Ø·ÙˆÙ„ Ø¶Ù„Ø¹ Ø§Ù„Ù…Ø±Ø¨Ø¹ 5 Ø³Ù…ØŒ ÙÙ…Ø­ÙŠØ·Ù‡ = 5 + 5 + 5 + 5 = 20 Ø³Ù….",
          "details": [
            "Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ù…Ø­ÙŠØ·: 4 Ã— Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹.",
            "ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ù‹Ø§ Ø¬Ù…Ø¹ Ø§Ù„Ø¶Ù„Ø¹ 4 Ù…Ø±Ø§Øª."
          ]
        },
        {
          "type": "question",
          "text": "Ø³Ø¤Ø§Ù„ 1: Ø·ÙˆÙ„ Ø¶Ù„Ø¹ Ù…Ø±Ø¨Ø¹ = 7 Ø³Ù…. Ù…Ø§ Ù…Ø­ÙŠØ·Ù‡ØŸ",
          "answer": "28",
          "hints": [
            "Ù…Ø­ÙŠØ· Ø§Ù„Ù…Ø±Ø¨Ø¹ = 4 Ã— Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹.",
            "4 Ã— 7 = ØŸ",
            "Ø§Ø¬Ù…Ø¹ 7 Ø£Ø±Ø¨Ø¹ Ù…Ø±Ø§Øª."
          ],
          "solution": "Ù…Ø­ÙŠØ· Ø§Ù„Ù…Ø±Ø¨Ø¹ = 4 Ã— 7 = 28 Ø³Ù…."
        },
        {
          "type": "question",
          "text": "Ø³Ø¤Ø§Ù„ 2: Ø£ÙŠ Ø¹Ø¨Ø§Ø±Ø© ØµØ­ÙŠØ­Ø© Ø¹Ù† Ø§Ù„Ù…Ø±Ø¨Ø¹ØŸ",
          "choices": [
            "Ù„Ù‡ Ø¶Ù„Ø¹Ø§Ù† Ù…ØªØ³Ø§ÙˆÙŠØ§Ù† ÙÙ‚Ø·",
            "ÙƒÙ„ Ø²ÙˆØ§ÙŠØ§Ù‡ Ù‚Ø§Ø¦Ù…Ø©",
            "Ù…Ø­ÙŠØ·Ù‡ = Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹ Ã— 2",
            "Ù„Ø§ ÙŠÙ…Ù„Ùƒ Ø£Ø¶Ù„Ø§Ø¹Ù‹Ø§ Ù…ØªÙˆØ§Ø²ÙŠØ©"
          ],
          "correctIndex": 1,
          "hints": [
            "Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø´ÙƒÙ„ Ø±Ø¨Ø§Ø¹ÙŠ Ù…Ù†ØªØ¸Ù….",
            "ÙƒÙ„ Ø²ÙˆØ§ÙŠØ§Ù‡ 90Â°.",
            "Ø£Ø¶Ù„Ø§Ø¹Ù‡ Ø§Ù„Ø£Ø±Ø¨Ø¹Ø© Ù…ØªØ³Ø§ÙˆÙŠØ©."
          ],
          "solution": "Ø§Ù„Ø¹Ø¨Ø§Ø±Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: ÙƒÙ„ Ø²ÙˆØ§ÙŠØ§ Ø§Ù„Ù…Ø±Ø¨Ø¹ Ù‚Ø§Ø¦Ù…Ø©."
        }
      ]
    },
    {
      "title": "Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø±Ø¨Ø¹",
      "flow": [
        {
          "type": "goal",
          "text": "Ø£Ù† ÙŠØ­Ø³Ø¨ Ø§Ù„Ø·Ø§Ù„Ø¨ Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø±Ø¨Ø¹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹.",
          "details": [
            "Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø±Ø¨Ø¹ ØªØ¹ØªÙ…Ø¯ Ø¹Ù„Ù‰ Ø§Ù„Ø¶Ù„Ø¹ ÙÙ‚Ø·.",
            "Ø§Ù„ÙˆØ­Ø¯Ø© ØªÙƒÙˆÙ† Ù…Ø±Ø¨Ø¹Ø© (Ø³Ù…Â²)."
          ]
        },
        {
          "type": "explain",
          "text": "Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø±Ø¨Ø¹ = Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹ Ã— Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹ (Ø§Ù„Ø¶Ù„Ø¹Â²)."
        },
        {
          "type": "example",
          "text": "Ø¥Ø°Ø§ ÙƒØ§Ù† Ø·ÙˆÙ„ Ø§Ù„Ø¶Ù„Ø¹ 6 Ø³Ù…ØŒ ÙØ§Ù„Ù…Ø³Ø§Ø­Ø© = 6 Ã— 6 = 36 Ø³Ù…Â²."
        },
        {
          "type": "question",
          "text": "Ø³Ø¤Ø§Ù„ 3: Ø·ÙˆÙ„ Ø¶Ù„Ø¹ Ù…Ø±Ø¨Ø¹ = 9 Ø³Ù…. Ù…Ø§ Ù…Ø³Ø§Ø­ØªÙ‡ØŸ",
          "answer": "81",
          "hints": [
            "Ø§Ù„Ù…Ø³Ø§Ø­Ø© = Ø§Ù„Ø¶Ù„Ø¹ Ã— Ø§Ù„Ø¶Ù„Ø¹.",
            "9 Ã— 9 = ØŸ",
            "Ø§ÙƒØªØ¨ Ø§Ù„Ù†Ø§ØªØ¬ ÙÙ‚Ø·."
          ],
          "solution": "Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø±Ø¨Ø¹ = 9 Ã— 9 = 81 Ø³Ù…Â²."
        },
        {
          "type": "note",
          "text": "ØªØ°ÙƒÙ‘Ø±: Ø§Ù„Ù…Ø­ÙŠØ· ÙŠÙ‚ÙŠØ³ Ø·ÙˆÙ„ Ø§Ù„Ø­Ø¯ÙˆØ¯ØŒ Ø¨ÙŠÙ†Ù…Ø§ Ø§Ù„Ù…Ø³Ø§Ø­Ø© ØªÙ‚ÙŠØ³ Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ø³Ø·Ø­."
        }
      ]
    }
  ]
}

math/public/data/weeks/week999.json
{
  "week": 999,
  "title": "Ø¨Ø·Ø§Ù‚Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ© (week 999) â€” Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ù€ Flow",
  "goals": [
    "ÙÙ‡Ù… ÙÙƒØ±Ø© Ø§Ù„ØªØ¯Ø±Ù‘Ø¬ ÙˆØ²Ø± Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©.",
    "Ø¥ØªÙ‚Ø§Ù† Ø­Ù„ Ù…Ø³Ø§Ø¦Ù„ Ø§Ù„Ù‚Ø³Ù…Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©."
  ],
  "prerequisites": [
    "Ø¥ØªÙ‚Ø§Ù† Ø¬Ø¯Ø§ÙˆÙ„ Ø§Ù„Ø¶Ø±Ø¨ Ø§Ù„Ø¨Ø³ÙŠØ·Ø©.",
    "Ù…Ø¹Ø±ÙØ© Ù…Ø¹Ù†Ù‰ Ø§Ù„Ù‚Ø³Ù…Ø© ÙƒØ¹Ù…Ù„ÙŠØ© ØªÙˆØ²ÙŠØ¹ Ù…ØªØ³Ø§ÙˆÙŠ."
  ],
  "assessment": {
    "title": "ØªÙ‚ÙŠÙŠÙ… Ø³Ø±ÙŠØ¹ Ù„Ù„Ù‚Ø³Ù…Ø©",
    "description": "Ø£Ø¬Ø¨ Ø¹Ù† Ø§Ù„Ø£Ø³Ø¦Ù„Ø© ÙˆØ§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ù†Ù‚Ø§Ø·Ùƒ (Ø¨Ø¯ÙˆÙ† ØªØµÙˆÙŠØ¨ ÙÙˆØ±ÙŠ).",
    "questions": [
      {
        "type": "input",
        "text": "Ø§ÙƒØªØ¨ Ù†Ø§ØªØ¬ 8 Ã· 4",
        "answer": "2",
        "points": 2
      },
      {
        "type": "mcq",
        "text": "Ø£ÙŠ Ø¹Ø¨Ø§Ø±Ø© ØµØ­ÙŠØ­Ø©ØŸ",
        "choices": ["6 Ã· 3 = 1", "6 Ã· 3 = 2", "6 Ã· 3 = 4"],
        "correctIndex": 1,
        "points": 2
      }
    ]
  },
  "concepts": [
    {
      "title": "Ø§Ø®ØªØ¨Ø§Ø± ØªØ¯ÙÙ‘Ù‚ Ø¨Ù„Ø§ Ø­Ø¯ÙˆØ¯",
      "flow": [
        {
          "type": "goal",
          "text": "Ø£Ù† ÙŠÙÙ‡Ù… Ø§Ù„Ø·Ø§Ù„Ø¨ ÙÙƒØ±Ø© Ø§Ù„ØªØ¯Ø±Ù‘Ø¬ØŒ ÙˆØ£Ù† Ø²Ø± (Ù…ØªØ§Ø¨Ø¹Ø©) ÙŠØªØ­ÙˆÙ„ Ù„Ù„ØªØ­Ù‚Ù‚ Ø¹Ù†Ø¯ Ø§Ù„Ø£Ø³Ø¦Ù„Ø©.",
          "details": [
            "ÙƒÙ„ Ù…ØªØ§Ø¨Ø¹Ø© ØªÙƒØ´Ù Ø¹Ù†ØµØ±Ù‹Ø§ Ø¬Ø¯ÙŠØ¯Ù‹Ø§.",
            "Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø¤Ø§Ù„ ØªØªØ­ÙˆÙ„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù„Ù„ØªØ­Ù‚Ù‚."
          ]
        },
        {
          "type": "explain",
          "text": "ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù†Ø¸Ø§Ù…: ÙƒÙ„ Ø¶ØºØ·Ø© (Ù…ØªØ§Ø¨Ø¹Ø©) ØªÙƒØ´Ù Ø§Ù„Ø¹Ù†ØµØ± Ø§Ù„ØªØ§Ù„ÙŠ. Ø¹Ù†Ø¯ Ø§Ù„Ø³Ø¤Ø§Ù„ØŒ Ù†ÙØ³ Ø§Ù„Ø²Ø± ÙŠØµØ¨Ø­ ØªØ­Ù‚Ù‚ Ù„Ù„Ø³Ø¤Ø§Ù„ Ø§Ù„Ø­Ø§Ù„ÙŠ."
        },
        {
          "type": "example",
          "text": "Ù…Ø«Ø§Ù„ Ø³Ø±ÙŠØ¹: 6 Ã· 3 = 2 Ù„Ø£Ù† 3 ØªØ¯Ø®Ù„ ÙÙŠ 6 Ù…Ø±ØªÙŠÙ†."
        },
        {
          "type": "question",
          "text": "Ø§Ù„Ø³Ø¤Ø§Ù„ 1: Ø§ÙƒØªØ¨ Ù†Ø§ØªØ¬ 6 Ã· 3",
          "answer": "2",
          "hints": [
            "ØªØ°ÙƒÙ‘Ø±: ÙƒÙ… Ù…Ø±Ø© 3 ØªØ¯Ø®Ù„ ÙÙŠ 6ØŸ",
            "Ø¬Ø±Ù‘Ø¨: 3 + 3 = 6ØŒ Ø¥Ø°Ù† Ù…Ø±ØªÙŠÙ†.",
            "Ù‚Ø³Ù… 6 Ø¹Ù„Ù‰ 3 Ø¨Ø§Ù„ØªØ³Ø§ÙˆÙŠ: Ù†ØµÙŠØ¨ ÙƒÙ„ ÙˆØ§Ø­Ø¯ 2."
          ],
          "solution": "6 Ã· 3 = 2 Ù„Ø£Ù† 3 ØªØ¯Ø®Ù„ ÙÙŠ 6 Ù…Ø±ØªÙŠÙ†."
        },
        {
          "type": "question",
          "text": "Ø§Ù„Ø³Ø¤Ø§Ù„ 2: Ø£ÙŠ Ø¹Ø¨Ø§Ø±Ø© ØµØ­ÙŠØ­Ø©ØŸ",
          "choices": ["9 Ã· 3 = 2", "9 Ã· 3 = 3", "9 Ã· 3 = 4", "9 Ã· 3 = 5"],
          "correctIndex": 1,
          "hints": [
            "ØªØ­Ù‚Ù‚ Ø¨Ø§Ù„Ø¶Ø±Ø¨: 3 Ã— ØŸ = 9",
            "Ø§Ù„Ø¹Ø¯Ø¯ Ø§Ù„Ù„ÙŠ Ø¥Ø°Ø§ Ø¶Ø±Ø¨Ù†Ø§Ù‡ ÙÙŠ 3 ÙŠØ¹Ø·ÙŠÙ†Ø§ 9 Ù‡Ùˆ 3.",
            "9 = 3 + 3 + 3 (Ø«Ù„Ø§Ø« Ù…Ø±Ø§Øª)."
          ],
          "solution": "Ø§Ù„Ø¥Ø¬Ø§Ø¨Ø© Ø§Ù„ØµØ­ÙŠØ­Ø©: 9 Ã· 3 = 3 Ù„Ø£Ù† 3 Ã— 3 = 9."
        },
        {
          "type": "note",
          "text": "Ù…Ù„Ø§Ø­Ø¸Ø©: Ù„Ø§Ø­Ø¸ ÙƒÙŠÙ Ù†ÙØ³ Ø²Ø± (Ù…ØªØ§Ø¨Ø¹Ø©) ÙƒØ§Ù† ØªØ­Ù‚Ù‚ Ù„Ù„Ø³Ø¤Ø§Ù„ 1 Ø«Ù… ØµØ§Ø± ØªØ­Ù‚Ù‚ Ù„Ù„Ø³Ø¤Ø§Ù„ 2."
        }
      ]
    },
    {
      "title": "Ù…ÙÙ‡ÙˆÙ… Ø¥Ø¶Ø§ÙÙŠ (ØªØ¬Ø±Ø¨Ø© Ø§Ù†ØªÙ‚Ø§Ù„)",
      "flow": [
        {
          "type": "goal",
          "text": "Ø£Ù† ÙŠÙ…ÙŠÙ‘Ø² Ø§Ù„Ø·Ø§Ù„Ø¨ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø¨ÙŠÙ† Ø§Ù„Ù‚Ø³Ù…Ø© ÙˆØ§Ù„Ø¶Ø±Ø¨.",
          "details": [
            "Ø§Ù„Ù‚Ø³Ù…Ø© Ø¹ÙƒØ³ Ø§Ù„Ø¶Ø±Ø¨.",
            "Ø§Ù„ØªØ­Ù‚Ù‚ ÙŠÙƒÙˆÙ† Ø¨Ø¶Ø±Ø¨ Ø§Ù„Ù†Ø§ØªØ¬ ÙÙŠ Ø§Ù„Ù…Ù‚Ø³ÙˆÙ… Ø¹Ù„ÙŠÙ‡."
          ]
        },
        {
          "type": "explain",
          "text": "Ø¥Ø°Ø§ ÙƒØ§Ù† a Ã· b = c ÙÙ‡Ø°Ø§ ÙŠØ¹Ù†ÙŠ Ø£Ù† b Ã— c = a. Ù†Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¶Ø±Ø¨ Ù„Ù„ØªØ­Ù‚Ù‚."
        },
        {
          "type": "question",
          "text": "Ø§ÙƒØªØ¨ Ø¹Ø¯Ø¯Ù‹Ø§ ÙŠØ¬Ø¹Ù„: 5 Ã— â–¡ = 20",
          "answer": "4",
          "hints": [
            "Ø§Ø¨Ø­Ø« Ø¹Ù† Ø¹Ø¯Ø¯ Ø¥Ø°Ø§ Ø¶Ø±Ø¨ØªÙ‡ ÙÙŠ 5 ÙŠØ¹Ø·ÙŠ 20.",
            "20 Ã· 5 = ØŸ",
            "Ø§Ù„Ø¹Ø¯Ø¯ Ù‡Ùˆ 4 Ù„Ø£Ù† 5 Ã— 4 = 20."
          ],
          "solution": "Ø§Ù„Ø¹Ø¯Ø¯ Ù‡Ùˆ 4 Ù„Ø£Ù† 20 Ã· 5 = 4ØŒ ÙˆØ¨Ø§Ù„ØªØ§Ù„ÙŠ 5 Ã— 4 = 20."
        }
      ]
    }
  ]
}

math/.github/workflows/azure-static-web-apps-mango-smoke-0ebe00210.yml
name: Azure Static Web Apps CI/CD

on:
  push:
    branches:
      - main
  pull_request:
    types: [opened, synchronize, reopened, closed]
    branches:
      - main

jobs:
  build_and_deploy_job:
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.action != 'closed')
    runs-on: ubuntu-latest
    name: Build and Deploy Job
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: true
          lfs: false
      - name: Build And Deploy
        id: builddeploy
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_MANGO_SMOKE_0EBE00210 }}
          repo_token: ${{ secrets.GITHUB_TOKEN }} # Used for Github integrations (i.e. PR comments)
          action: "upload"
          ###### Repository/Build Configurations - These values can be configured to match your app requirements. ######
          # For more information regarding Static Web App workflow configurations, please visit: https://aka.ms/swaworkflowconfig
          app_location: "public" # App source code path
          api_location: "api" # Api source code path - optional
          output_location: "public" # Built app content directory - optional
          ###### End of Repository/Build Configurations ######

  close_pull_request_job:
    if: github.event_name == 'pull_request' && github.event.action == 'closed'
    runs-on: ubuntu-latest
    name: Close Pull Request Job
    steps:
      - name: Close Pull Request
        id: closepullrequest
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN_MANGO_SMOKE_0EBE00210 }}
          action: "close"

math/public/admin-card-builder.html
<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2563eb" />
  <title>math â€” Ù…ØµÙ…Ù… Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø©</title>

  <link rel="stylesheet" href="/assets/css/base.css" />
  <link rel="stylesheet" href="/assets/css/toast.css" />
  <link rel="stylesheet" href="/assets/css/admin.css" />
  <link rel="stylesheet" href="/assets/css/admin-builder.css" />
</head>

<body class="is-loading">
  <div class="app">
    <header class="topbar">
      <div class="container topbar-inner">
        <div class="brand" aria-label="math">
          <div class="brand-mark" aria-hidden="true"></div>
          <div class="brand-title">
            <b>math</b>
            <span>Ù…ØµÙ…Ù… Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</span>
          </div>
        </div>

        <div class="row">
          <button id="toolbarSave" class="btn btn-primary btn-sm" type="button">Ø­ÙØ¸</button>
          <a class="btn btn-ghost btn-sm" href="/admin.html" aria-label="Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©">
            Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©
          </a>
        </div>
      </div>
    </header>

    <main class="container section builder">
      <section class="stack">
        <div class="card">
          <div class="card-header">
            <div>
              <h1 class="h1">Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©</h1>
              <p class="p">Ø£Ø¶Ù Ø£Ù‚Ø³Ø§Ù…Ù‹Ø§ ÙˆØ£Ù†ÙˆØ§Ø¹ Ø£Ø³Ø¦Ù„Ø© Ù…ØªØ¹Ø¯Ø¯Ø© ÙƒÙ…Ø§ ÙÙŠ Ù†Ù…Ø§Ø°Ø¬ Ø¬ÙˆØ¬Ù„.</p>
            </div>
            <span class="badge primary">Ø¨Ø·Ø§Ù‚Ø©</span>
          </div>

          <div class="card-body">
            <div class="builder-meta" data-context="card">
              <div class="field">
                <label class="label">Ø±Ù‚Ù… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹</label>
                <input id="cardWeek" class="input ltr" />
              </div>
              <div class="field">
                <label class="label">Ø§Ù„ØµÙ</label>
                <input id="cardClass" class="input" placeholder="Ù…Ø«Ø§Ù„: Ø§Ù„ØµÙ Ø§Ù„Ø±Ø§Ø¨Ø¹" />
              </div>
              <div class="field">
                <label class="label">Ø§Ù„Ø´Ø¹Ø¨ (ÙŠÙ…ÙƒÙ† Ø§Ø®ØªÙŠØ§Ø± Ø£ÙƒØ«Ø± Ù…Ù† Ø´Ø¹Ø¨Ø©)</label>
                <input id="cardSections" class="input" placeholder="Ù…Ø«Ø§Ù„: Ø£ØŒ Ø¨ØŒ Ø¬" />
                <div class="builder-helper">Ø§ÙØµÙ„ Ø¨ÙŠÙ† Ø§Ù„Ø´Ø¹Ø¨ Ø¨ÙØ§ØµÙ„Ø©.</div>
              </div>
              <div class="field">
                <label class="label">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©</label>
                <input id="cardTitle" class="input" />
              </div>
              <div class="field">
                <label class="label">Ø§Ù„Ù…ØªØ·Ù„Ø¨ Ø§Ù„Ø³Ø§Ø¨Ù‚ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
                <input id="cardPrereq" class="input ltr" placeholder="Ù…Ø«Ø§Ù„: 999" />
              </div>
              <div class="field">
                <label class="label">Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ØªÙ‚ÙŠÙŠÙ…</label>
                <input id="assessmentTitle" class="input" placeholder="Ù…Ø«Ø§Ù„: ØªÙ‚ÙŠÙŠÙ… Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹" />
              </div>
              <div class="field">
                <label class="label">ÙˆØµÙ Ø§Ù„ØªÙ‚ÙŠÙŠÙ…</label>
                <textarea id="assessmentDescription" class="input" rows="2" placeholder="ÙˆØµÙ Ù…Ø®ØªØµØ± Ù„Ù„ØªÙ‚ÙŠÙŠÙ…"></textarea>
              </div>
            </div>
          </div>
        </div>

        <div class="builder-block" data-context="goals">
          <div class="builder-block-header">
            <div>
              <h3 class="h3">Ù…Ø§Ø°Ø§ Ø³Ù†ØªØ¹Ù„Ù… Ø§Ù„ÙŠÙˆÙ…</h3>
              <p class="builder-helper">Ø£Ø¶Ù Ø£Ù‡Ø¯Ø§Ù Ø§Ù„Ø­ØµØ© Ø¨Ø´ÙƒÙ„ Ø¹Ø§Ù….</p>
            </div>
            <button class="btn btn-ghost btn-sm" type="button" id="btnAddGoal">Ø¥Ø¶Ø§ÙØ© Ù‡Ø¯Ù</button>
          </div>
          <div id="goalsList" class="builder-sections"></div>
        </div>

        <div class="builder-block" data-context="prereqs">
          <div class="builder-block-header">
            <div>
              <h3 class="h3">Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©</h3>
              <p class="builder-helper">Ø£Ø¶Ù Ø§Ø®ØªØ¨Ø± Ù†ÙØ³ÙŠ Ù„Ù„Ù…Ù‡Ø§Ø±Ø§Øª Ø§Ù„Ù„Ø§Ø²Ù…Ø© Ù‚Ø¨Ù„ Ø§Ù„Ø¯Ø±Ø³.</p>
            </div>
            <button class="btn btn-ghost btn-sm" type="button" id="btnAddPrereq">Ø¥Ø¶Ø§ÙØ© Ù…ØªØ·Ù„Ø¨ Ø³Ø§Ø¨Ù‚</button>
          </div>
          <div id="prereqsList" class="builder-sections"></div>
        </div>

        <div class="builder-block" data-context="concepts">
          <div class="builder-block-header">
            <h3 class="h3">Ø§Ù„Ù…ÙØ§Ù‡ÙŠÙ… ÙˆØ§Ù„Ø£Ù†Ø´Ø·Ø©</h3>
          </div>
          <div id="sectionsList" class="builder-sections"></div>
        </div>
      </section>
    </main>

    <footer class="container section center">
      <p class="small">Â© math â€” Ù…ØµÙ…Ù… Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø£Ø³Ø¦Ù„Ø©</p>
    </footer>
  </div>

  <div class="floating-actions">
    <button id="floatingPreview" class="floating-preview" type="button">Ù…Ø¹Ø§ÙŠÙ†Ø©</button>
    <button id="floatingApply" class="floating-apply" type="button">ØªØ·Ø¨ÙŠÙ‚</button>
    <button id="floatingSave" class="floating-save" type="button" aria-live="polite">ØªÙ… Ø§Ù„Ø­ÙØ¸ âœ“</button>
    <button id="floatingAdd" class="floating-add" type="button" aria-label="Ø¥Ø¶Ø§ÙØ©">+</button>
    <div id="floatingMenu" class="floating-menu hidden" hidden></div>
  </div>

  <div id="builderLoading" class="loading-overlay hidden" hidden>
    <div class="loading-panel" role="status" aria-live="polite">
      <span class="loading-spinner" aria-hidden="true"></span>
      <span>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©...</span>
    </div>
  </div>

  <script type="module" src="/assets/js/card-builder.js"></script>
</body>
</html>

math/public/admin.html
<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2563eb" />
  <title>math â€” Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</title>

  <link rel="stylesheet" href="/assets/css/base.css" />
  <link rel="stylesheet" href="/assets/css/toast.css" />
  <link rel="stylesheet" href="/assets/css/admin.css" />
</head>

<body class="is-loading">
  <div class="app">
    <header class="topbar">
      <div class="container topbar-inner">
        <div class="brand" aria-label="math">
          <div class="brand-mark" aria-hidden="true"></div>
          <div class="brand-title">
            <b>math</b>
          </div>
        </div>

        <div class="row">
          <a class="btn btn-ghost btn-sm" href="/" aria-label="Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©">
            Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
          </a>
          <button id="btnAdminLogout" class="btn btn-ghost btn-sm hidden" type="button">
            ØªØ³Ø¬ÙŠÙ„ Ø®Ø±ÙˆØ¬
          </button>
        </div>
      </div>
    </header>

    <main class="container section">
      <section id="screen-admin-login" class="stack">
        <div class="card">
          <div class="card-header">
            <div>
              <h1 class="h1">Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</h1>
              <p class="p">Ø³Ø¬Ù‘Ù„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù„Ø¥Ø¯Ø§Ø±Ø© Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨ ÙˆØ§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª.</p>
            </div>
            <span class="badge primary">Admin</span>
          </div>

          <div class="card-body">
            <div class="field">
              <label class="label" for="adminUser">Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</label>
              <input id="adminUser" class="input ltr" autocomplete="username" placeholder="admin" />
            </div>

            <div class="field" style="margin-top: 12px;">
              <label class="label" for="adminPass">ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±</label>
              <input id="adminPass" type="password" class="input ltr" autocomplete="current-password" placeholder="Aa@232323445566" />
            </div>

            <div class="row" style="margin-top: 16px;">
              <button id="btnAdminLogin" class="btn btn-primary btn-lg w-100" type="button">Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</button>
            </div>
          </div>
        </div>
      </section>

      <section id="screen-admin" class="stack hidden" hidden style="display:none;">
        <div class="card">
          <div class="card-header">
            <div>
              <h2 class="h2">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</h2>
              <p class="p">Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª ØªÙØ­ÙØ¸ Ø¯Ø§Ø®Ù„ Ø§Ù„Ù…ØªØµÙØ­ ÙˆØªÙØ³ØªØ®Ø¯Ù… Ù…Ø¨Ø§Ø´Ø±Ø© ÙÙŠ Ø§Ù„Ù…Ù†ØµØ©.</p>
            </div>
            <span class="badge primary">Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…</span>
          </div>

          <div class="card-body">
            <div class="admin-security">
              <div>
                <h3 class="h3">Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø­Ø³Ø§Ø¨</h3>
                <p class="p">ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ù…Ù† Ù‡Ù†Ø§.</p>
              </div>
              <div class="builder-meta">
                <div class="field">
                  <label class="label" for="adminOldPass">ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©</label>
                  <input id="adminOldPass" type="password" class="input ltr" autocomplete="current-password" />
                </div>
                <div class="field">
                  <label class="label" for="adminNewPass">ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</label>
                  <input id="adminNewPass" type="password" class="input ltr" autocomplete="new-password" />
                </div>
                <div class="field">
                  <label class="label" for="adminNewPassConfirm">ØªØ£ÙƒÙŠØ¯ ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©</label>
                  <input id="adminNewPassConfirm" type="password" class="input ltr" autocomplete="new-password" />
                </div>
              </div>
              <div class="row">
                <button id="btnAdminChangePassword" class="btn btn-primary btn-sm" type="button">ØªØ­Ø¯ÙŠØ« ÙƒÙ„Ù…Ø© Ø§Ù„Ø³Ø±</button>
              </div>
            </div>

            <div class="admin-tabs">
              <button class="btn btn-outline is-active" type="button" data-tab="students">Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø·Ù„Ø§Ø¨</button>
              <button class="btn btn-outline" type="button" data-tab="cards">Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</button>
            </div>

            <div id="tab-students" class="admin-panel">
              <div class="panel-header">
                <div>
                  <h3 class="h3">Ø§Ù„Ø·Ù„Ø§Ø¨</h3>
                  <p class="p">Ø£Ø¶Ù Ø£Ùˆ Ø¹Ø¯Ù‘Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ©ØŒ Ø³Ù†Ø© Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯ØŒ Ø§Ù„Ø§Ø³Ù…ØŒ ÙˆØ§Ù„ÙØµÙ„.</p>
                </div>
                <div class="row">
                  <button id="btnAddStudent" class="btn btn-primary btn-sm" type="button">Ø¥Ø¶Ø§ÙØ© Ø·Ø§Ù„Ø¨</button>
                  <button id="btnSaveStudents" class="btn btn-ghost btn-sm" type="button">Ø­ÙØ¸ Ø§Ù„Ø¢Ù†</button>
                </div>
              </div>

              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ©</th>
                      <th>Ø³Ù†Ø© Ø§Ù„Ù…ÙŠÙ„Ø§Ø¯</th>
                      <th>Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø£ÙˆÙ„</th>
                      <th>Ø§Ù„Ø§Ø³Ù… Ø§Ù„ÙƒØ§Ù…Ù„</th>
                      <th>Ø§Ù„ÙØµÙ„</th>
                      <th></th>
                    </tr>
                  </thead>
                  <tbody id="studentsTable"></tbody>
                </table>
              </div>
            </div>

            <div id="tab-cards" class="admin-panel hidden" hidden style="display:none;">
              <div class="panel-header">
                <div>
                  <h3 class="h3">Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</h3>
                  <p class="p">ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¶Ø§ÙØ© Ø¨Ø·Ø§Ù‚Ø© Ø¬Ø¯ÙŠØ¯Ø© ÙˆØªØ¹Ø¯ÙŠÙ„ Ø¹Ù†Ø§ØµØ± ÙƒÙ„ Ø¨Ø·Ø§Ù‚Ø©.</p>
                </div>
                <div class="row">
                  <button id="btnAddCard" class="btn btn-primary btn-sm" type="button">Ø¥Ø¶Ø§ÙØ© Ø¨Ø·Ø§Ù‚Ø©</button>
                  <button id="btnSaveCards" class="btn btn-ghost btn-sm" type="button">Ø­ÙØ¸ Ø§Ù„Ø¢Ù†</button>
                </div>
              </div>

              <div id="cardsList" class="admin-card-list"></div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="container section center">
      <p class="small">Â© math â€” Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</p>
    </footer>
  </div>

  <div id="adminLoading" class="loading-overlay hidden" hidden>
    <div class="loading-panel" role="status" aria-live="polite">
      <span class="loading-spinner" aria-hidden="true"></span>
      <span>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª...</span>
    </div>
  </div>

  <script type="module" src="/assets/js/admin.js"></script>
</body>
</html>

math/public/db-template-edit.html
<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2563eb" />
  <title>math â€” Ù…Ø­Ø±Ø± Ù‚ÙˆØ§Ù„Ø¨ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</title>

  <link rel="stylesheet" href="/assets/css/base.css" />
  <link rel="stylesheet" href="/assets/css/db-template-edit.css" />
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="container topbar-inner">
        <div class="brand" aria-label="math">
          <div class="brand-mark" aria-hidden="true"></div>
          <div class="brand-title">
            <b>math</b>
          </div>
        </div>

        <div class="row">
          <a class="btn btn-ghost btn-sm" href="/" aria-label="Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©">Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©</a>
          <a class="btn btn-ghost btn-sm" href="/admin.html" aria-label="Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©">Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©</a>
        </div>
      </div>
    </header>

    <main class="container section">
      <section class="stack">
        <div class="card">
          <div class="card-header">
            <div>
              <h1 class="h1">Ù…Ø­Ø±Ø± db-template-edit</h1>
              <p class="p">Ø§Ø³ØªØ¹Ø±Ø¶ Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„ ÙˆØ§Ù„Ø£Ø¹Ù…Ø¯Ø© ÙˆØ­Ø±Ù‘Ø± Ù‚ÙˆØ§Ù„Ø¨ Ø§Ù„Ù…Ø®Ø·Ø· Ù…Ø­Ù„ÙŠÙ‹Ø§ Ø¨Ø¯ÙˆÙ† Ø£ÙŠ Ø§ØªØµØ§Ù„ Ø¨Ø¨ÙˆØ§Ø¨Ø© Ø¥Ø¯Ø§Ø±Ø© Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</p>
            </div>
            <span class="badge primary">Template</span>
          </div>
          <div class="card-body">
            <div class="note">
              <strong>ØªÙ†Ø¨ÙŠÙ‡:</strong>
              Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø© ØªØ­ÙØ¸ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ù…Ø­Ù„ÙŠÙ‹Ø§ ÙÙŠ Ø§Ù„Ù…ØªØµÙØ­ ÙÙ‚Ø·. Ù„ØªØ·Ø¨ÙŠÙ‚Ù‡Ø§ Ø¹Ù„Ù‰ Azure ÙŠÙ„Ø²Ù… Ù„Ø§Ø­Ù‚Ù‹Ø§ ØªØ´ØºÙŠÙ„ ØªØ±Ø­ÙŠÙ„Ø§Øª Ø£Ùˆ Ø³ÙƒØ±Ø¨ØªØ§Øª SQL Ø¹Ø¨Ø± Ø®Ø· Ù†Ø´Ø±.
            </div>
          </div>
        </div>
      </section>

      <section class="db-layout">
        <aside class="db-sidebar">
          <div class="card">
            <div class="card-header">
              <div>
                <h2 class="h2">Ø§Ù„Ø¬Ø¯Ø§ÙˆÙ„</h2>
                <p class="p">Ø§Ø¨Ø­Ø« Ø£Ùˆ Ø£Ù†Ø´Ø¦ Ø¬Ø¯ÙˆÙ„Ù‹Ø§ Ø¬Ø¯ÙŠØ¯Ù‹Ø§.</p>
              </div>
            </div>
            <div class="card-body">
              <label class="label" for="tableSearch">Ø¨Ø­Ø«</label>
              <input id="tableSearch" class="input" type="search" placeholder="Ø§Ø¨Ø­Ø« Ø¨Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„" />

              <div class="actions" style="margin-top: 12px;">
                <input id="newTableName" class="input" type="text" placeholder="Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ø¬Ø¯ÙŠØ¯" />
                <button id="btnAddTable" class="btn btn-primary btn-sm" type="button">Ø¥Ø¶Ø§ÙØ© Ø¬Ø¯ÙˆÙ„</button>
              </div>

              <ul id="tablesList" class="tables-list" role="list"></ul>
            </div>
          </div>
        </aside>

        <section class="db-editor">
          <div class="card">
            <div class="card-header">
              <div>
                <h2 class="h2">ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ø¬Ø¯ÙˆÙ„</h2>
                <p class="p">Ø­Ø¯Ù‘Ø« Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„ ÙˆØ£Ø¹Ù…Ø¯ØªÙ‡ Ø«Ù… Ø§Ø­ÙØ¸ Ø§Ù„Ù‚Ø§Ù„Ø¨ Ù…Ø­Ù„ÙŠÙ‹Ø§.</p>
              </div>
              <div class="row">
                <button id="btnSaveTemplate" class="btn btn-ghost btn-sm" type="button">Ø­ÙØ¸ Ù…Ø­Ù„ÙŠ</button>
                <button id="btnExportJson" class="btn btn-outline btn-sm" type="button">Ù†Ø³Ø® JSON</button>
              </div>
            </div>
            <div class="card-body">
              <div id="emptyState" class="empty-state">
                <h3 class="h3">Ø§Ø®ØªØ± Ø¬Ø¯ÙˆÙ„Ù‹Ø§</h3>
                <p class="p">Ø§Ø®ØªØ± Ø¬Ø¯ÙˆÙ„Ù‹Ø§ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø£Ùˆ Ø£Ù†Ø´Ø¦ Ø¬Ø¯ÙˆÙ„Ù‹Ø§ Ø¬Ø¯ÙŠØ¯Ù‹Ø§ Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„.</p>
              </div>

              <div id="tableEditor" class="table-editor hidden" hidden>
                <div class="field">
                  <label class="label" for="tableNameInput">Ø§Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„</label>
                  <input id="tableNameInput" class="input" type="text" />
                </div>

                <div class="columns-header">
                  <h3 class="h3">Ø§Ù„Ø£Ø¹Ù…Ø¯Ø©</h3>
                  <button id="btnAddColumn" class="btn btn-primary btn-sm" type="button">Ø¥Ø¶Ø§ÙØ© Ø¹Ù…ÙˆØ¯</button>
                </div>

                <div id="columnsList" class="columns-list"></div>
              </div>
            </div>
          </div>

          <div class="card" style="margin-top: 16px;">
            <div class="card-header">
              <div>
                <h3 class="h3">Ù…Ø¹Ø§ÙŠÙ†Ø© JSON</h3>
                <p class="p">ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø³Ø® Ø§Ù„Ù‚Ø§Ù„Ø¨ ÙˆØ§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ Ù„Ø§Ø­Ù‚Ù‹Ø§ ÙÙŠ Ø³ÙƒØ±Ø¨ØªØ§Øª Ø§Ù„ØªØ±Ø­ÙŠÙ„.</p>
              </div>
            </div>
            <div class="card-body">
              <pre id="jsonPreview" class="json-preview"></pre>
            </div>
          </div>
        </section>
      </section>
    </main>
  </div>

  <script type="module" src="/assets/js/db-template-edit.js"></script>
</body>
</html>

math/public/index.html
<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2563eb" />
  <title>math â€” Ù…Ù†ØµØ© Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ§Øª</title>

  <link rel="stylesheet" href="/assets/css/base.css" />
  <link rel="stylesheet" href="/assets/css/toast.css" />
</head>

<body class="is-loading">
  <div class="app">
    <!-- Topbar -->
    <header class="topbar">
      <div class="container topbar-inner">
        <div class="brand" aria-label="math">
          <div class="brand-mark" aria-hidden="true"></div>
          <div class="brand-title">
            <b>math</b>
          </div>
        </div>

        <div class="row">
          <a class="btn btn-ghost btn-sm" href="/" aria-label="Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©">
            Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
          </a>
          <a class="btn btn-ghost btn-sm" href="/admin.html" aria-label="Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©">
            Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©
          </a>
        </div>
      </div>
    </header>

    <main class="container section">
      <!-- Screen: ID -->
      <section id="screen-id" class="stack">
        <div class="card">
          <div class="card-header">
            <div>
              <h1 class="h1">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</h1>
              <p class="p">Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ© Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙˆØ­ÙØ¸ Ø§Ù„ØªÙ‚Ø¯Ù….</p>
            </div>
            <span class="badge primary">Ù†Ù‡Ø§Ø±ÙŠ</span>
          </div>

          <div class="card-body">
            <div class="field">
              <label class="label" for="studentId">Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ©</label>
              <input id="studentId" class="input ltr" inputmode="numeric" autocomplete="off" placeholder="Ù…Ø«Ø§Ù„: 123456789" />
              <div class="help">ÙŠÙØ³ØªØ®Ø¯Ù… Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ‚Ø¯Ù… Ø¹Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ø¬Ù‡Ø§Ø².</div>
            </div>

            <div class="row">
              <button id="btnLogin" class="btn btn-primary btn-lg w-100">Ø¯Ø®ÙˆÙ„</button>
            </div>
          </div>
        </div>
      </section>

      <!-- Screen: Welcome -->
      <section id="screen-welcome" class="stack hidden" hidden style="display:none;">
        <div class="card">
          <div class="card-header">
            <div>
              <h1 class="h1" id="welcomeTitle">Ù…Ø±Ø­Ø¨Ù‹Ø§ ğŸ‘‹</h1>
              <p class="p" id="welcomeSub">Ù‡Ù„ ØªØ±ÙŠØ¯ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ØŸ</p>
            </div>
            <span class="badge primary" id="welcomeChip">Ø·Ø§Ù„Ø¨</span>
          </div>

          <div class="card-body">
            <div class="field">
              <label class="label">Ø§Ø³Ù… Ø§Ù„Ø·Ø§Ù„Ø¨</label>
              <div id="welcomeName" class="input is-static" role="status">Ø·Ø§Ù„Ø¨</div>
              <div class="help">ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ© Ù…Ù† Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡.</div>
            </div>
            <button id="btnToCards" class="btn btn-primary btn-lg w-100">Ø¹Ø±Ø¶ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</button>
            <button id="btnChangeId" class="btn btn-outline w-100">ØªØºÙŠÙŠØ± Ø±Ù‚Ù… Ø§Ù„Ù‡ÙˆÙŠØ©</button>
          </div>
        </div>
      </section>

      <!-- Screen: Cards -->
      <section id="screen-cards" class="stack hidden" hidden style="display:none;">
        <div class="card">
          <div class="card-header">
            <div>
              <h2 class="h2">Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø¨ÙŠØ¹</h2>
              <p class="p">Ø§Ø®ØªØ± Ø¨Ø·Ø§Ù‚Ø© Ù…ÙØªÙˆØ­Ø©Ø› ØªÙÙØªØ­ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ø§Ù„Ù…Ù‚ÙÙ„Ø© Ø¨Ø¹Ø¯ Ø¥ÙƒÙ…Ø§Ù„ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©.</p>
            </div>
            <div class="row">
              <span class="badge primary" id="cardsStudentName">Ø·Ø§Ù„Ø¨</span>
              <button id="btnLogout" class="btn btn-ghost btn-sm">ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø·Ø§Ù„Ø¨</button>
            </div>
          </div>

          <div class="card-body">
            <div id="cardsList" class="grid cards" aria-live="polite"></div>
          </div>

          <div class="card-footer">
            <span class="small">Ø¨Ø·Ø§Ù‚Ø© ØªØ¬Ø±ÙŠØ¨ÙŠØ©: week=999</span>
          </div>
        </div>
      </section>
    </main>

    <footer class="container section center">
      <p class="small">Â© math â€” Ù…Ù†ØµØ© ØªØ¹Ù„ÙŠÙ…ÙŠØ© ØªÙØ§Ø¹Ù„ÙŠØ©</p>
    </footer>
  </div>

  <script type="module" src="/assets/js/app.js"></script>
</body>
</html>

math/public/lesson.html
<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2563eb" />
  <title>math â€” Ø§Ù„Ø¯Ø±Ø³</title>

  <link rel="stylesheet" href="/assets/css/base.css" />
  <link rel="stylesheet" href="/assets/css/lesson.css" />
  <link rel="stylesheet" href="/assets/css/questions.css" />
  <link rel="stylesheet" href="/assets/css/toast.css" />
</head>

<body>
  <div class="app">
    <!-- Topbar -->
    <header class="topbar">
      <div class="container topbar-inner">
        <div class="brand">
          <div class="brand-mark" aria-hidden="true"></div>
          <div class="brand-title">
            <b>math</b>
            <span>Ø¯Ø±Ø³ ØªÙØ§Ø¹Ù„ÙŠ</span>
          </div>
        </div>

        <a id="btnBackHome" class="btn btn-ghost btn-sm" href="/" aria-label="Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª">
          Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª
        </a>
      </div>
    </header>

    <main class="container section">
      <!-- Lesson Header -->
      <section class="lesson-header">
        <div class="lesson-title">
          <h1 id="lessonTitle" class="h1">ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨Ø·Ø§Ù‚Ø©...</h1>
          <div class="lesson-meta">
            <span id="lessonStudent" class="lesson-student">Ø·Ø§Ù„Ø¨</span>
            <span id="lessonWeek" class="badge primary">week</span>
          </div>
        </div>

        <!-- Progress -->
        <div class="progress-wrap">
          <div class="progress-label">
            <span>Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ÙÙ‡Ù…</span>
            <span id="progressPercent">0%</span>
          </div>
          <div class="progress">
            <i id="progressBar"></i>
          </div>
        </div>
      </section>

      <!-- Lesson Content -->
      <section id="lessonContent" class="stack" aria-live="polite">
        <!-- Concepts rendered here by engine -->
      </section>

      <!-- Completion -->
      <section id="lessonComplete" class="lesson-complete hidden" hidden>
        <div class="card">
          <div class="card-header">
            <div>
              <h2 class="h2">Ø£Ø­Ø³Ù†Øª ğŸ‰</h2>
              <p class="p">Ø£Ù†Ù‡ÙŠØª Ø§Ù„Ø¨Ø·Ø§Ù‚Ø© Ø¨Ù†Ø¬Ø§Ø­.</p>
            </div>
            <span class="badge done">Ù…Ù†Ø¬Ø²Ø©</span>
          </div>

          <div class="card-body">
            <p class="p">ØªÙ… Ø­ÙØ¸ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²ØŒ ÙˆÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªØ§Ù„ÙŠ.</p>
            <div class="row">
              <a href="/" class="btn btn-primary btn-lg w-100">Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ø¨Ø·Ø§Ù‚Ø§Øª</a>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer class="container section center">
      <p class="small">Â© math â€” Ù…Ø­Ø±Ùƒ Ø¯Ø±ÙˆØ³ ØªÙØ§Ø¹Ù„ÙŠ</p>
    </footer>
  </div>

  <script type="module" src="/assets/js/app.js"></script>
</body>
</html>
